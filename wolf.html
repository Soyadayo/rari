<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Pack Evolution RPG</title>
    <style>
        /* General styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27, #1a1a2e, #16213e);
            min-height: 100vh;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.4);
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #8a2be2;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
            align-items: start;
        }

        /* Fixed game-grid to properly align with tiles */
        .game-grid {
            display: grid;
            grid-template-columns: repeat(15, 45px);
            grid-template-rows: repeat(15, 45px);
            gap: 2px;
            background: #111;
            padding: 10px;
            border-radius: 10px;
            border: 3px solid #8a2be2;
            box-shadow: inset 0 0 20px rgba(138, 43, 226, 0.3);
            justify-content: center;
            align-content: center;
            width: fit-content;
            margin: 0 auto;
        }

        .tile {
            width: 45px;
            height: 45px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
            overflow: visible;
        }

        .tile:hover {
            border-color: #8a2be2;
            transform: scale(1.05);
        }

        /* Terrain styles - Original themes */
        .grass { background: linear-gradient(135deg, #2d5016, #3e6b1f); }
        .forest { background: linear-gradient(135deg, #1a3a1a, #2d5a2d); }
        .mountain { background: linear-gradient(135deg, #4a4a4a, #6a6a6a); }
        .water { background: linear-gradient(135deg, #1e3a5f, #2e5a8f); }

        /* New terrain themes */
        .desert { background: linear-gradient(135deg, #c28b3a, #e6b880); }
        .volcano { background: linear-gradient(135deg, #4a0000, #8b0000); }
        .snow { background: linear-gradient(135deg, #e0f2f7, #c6e2e9); }
        .swamp { background: linear-gradient(135deg, #324a3e, #4a6a5e); }
        .crystal { background: linear-gradient(135deg, #a0c4ff, #bdb2ff); }
        .void { background: linear-gradient(135deg, #1a0033, #330066); }

        .goal {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            animation: goalPulse 2s infinite;
        }

        @keyframes goalPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        /* Character styles */
        .player {
            width: 45px;
            height: 45px;
            background-image: url('https://github.com/Soyadayo/Mappon/raw/main/mother_wolf.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: motherWolfGlow 2s infinite;
            position: relative;
        }
        .player.controlled {
            border: 3px solid #00ffff !important;
            border-radius: 6px;
            box-sizing: border-box;
        }

        @keyframes motherWolfGlow {
            0%, 100% { filter: drop-shadow(0 0 3px #ff1493); }
            50% { filter: drop-shadow(0 0 8px #ff1493); }
        }

        .pack-icon {
            width: 45px;
            height: 45px;
            background-image: url('https://github.com/Soyadayo/Mappon/raw/main/pack_wolf.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            animation: packPulse 3s infinite;
        }
        .pack-icon.controlled {
            border: 3px solid #00ffff !important;
            border-radius: 6px;
            box-sizing: border-box;
        }

        @keyframes packPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pack-size {
            position: absolute;
            top: -8px;
            right: -8px;
            background: #ff4444;
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            min-width: 16px;
            text-align: center;
            line-height: 1.2;
            z-index: 10;
        }

        .enemy {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 22px;
            position: relative;
        }

        .hp-bar {
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: #ff4444;
            transition: width 0.3s ease;
        }

        /* UI Panel styles */
        .ui-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(5px);
            overflow-x: hidden;
        }

        .stat-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border-left: 4px solid #8a2be2;
        }

        .stat-bar {
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            height: 22px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .stat-fill {
            height: 100%;
            transition: width 0.5s ease;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            position: relative;
        }

        .stat-fill.hunger {
            background: linear-gradient(90deg, #f39c12, #f1c40f);
        }

        .stat-fill.exp {
            background: linear-gradient(90deg, #8a2be2, #9370db);
        }

        .stat-fill.pack-hp {
            background: linear-gradient(90deg, #00bfff, #87cefa);
        }

        /* Controls - Improved layout */
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .control-btn {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #6a1b9a, #8a2be2);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .action-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            font-size: 13px;
        }

        .control-selection {
            grid-column: span 3;
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            color: #fff;
            font-size: 1.1em;
            flex-wrap: wrap;
        }

        .control-selection button {
            padding: 8px 15px;
            font-size: 14px;
            background: #555;
            border: 2px solid #555;
        }
        .control-selection button.active {
            background: #8a2be2;
            border-color: #00ffff;
            box-shadow: 0 0 8px #00ffff;
        }

        .language-selection {
            grid-column: span 3;
            display: flex;
            justify-content: flex-end;
            gap: 5px;
            margin-bottom: 10px;
        }

        .language-selection button {
            padding: 5px 10px;
            font-size: 12px;
            background: #333;
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .language-selection button.active {
            background: #8a2be2;
            border-color: #00ffff;
        }

        .help-button-container {
            grid-column: span 3;
            display: flex;
            justify-content: flex-start;
            margin-bottom: 10px;
        }

        .help-button {
            padding: 8px 15px;
            font-size: 14px;
            background: linear-gradient(135deg, #FF6B6B, #FF8E8E);
            border: 2px solid #FF4444;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .help-button:hover {
            background: linear-gradient(135deg, #FF4444, #FF6B6B);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .music-controls-container {
            grid-column: span 3;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            margin-top: 10px;
        }

        .music-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .music-controls button {
            background: linear-gradient(135deg, #4CAF50, #2E8B57);
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .music-controls button:hover {
            background: linear-gradient(135deg, #2E8B57, #4CAF50);
        }

        /* Message area */
        .message-area {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            border: 2px solid rgba(138, 43, 226, 0.3);
            font-size: 14px;
            line-height: 1.5;
        }

        .message {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            word-break: break-word;
        }

        .message.hunt {
            border-left: 4px solid #e74c3c;
        }

        .message.pack {
            border-left: 4px solid #9370db;
        }

        .message.level {
            border-left: 4px solid #f39c12;
            font-weight: bold;
        }

        .pack-traits {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .trait-badge {
            background: rgba(147, 112, 219, 0.2);
            border: 1px solid #9370db;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
            word-break: break-word;
        }

        .trait-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }

        .stage-info {
            text-align: center;
            font-size: 18px;
            color: #f39c12;
            margin: 10px 0;
        }

        /* Modal for Game Over */
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #1a1a2e;
            margin: auto;
            padding: 30px;
            border: 2px solid #8a2be2;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .modal-content h2 {
            color: #ff1493;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal-content p {
            font-size: 1.1em;
            margin-bottom: 25px;
        }

        .modal-content button {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #6a1b9a, #8a2be2);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .game-grid {
                grid-template-columns: repeat(15, 35px);
                grid-template-rows: repeat(15, 35px);
            }

            .tile {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }

            .ui-panel {
                width: 100%;
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1 id="gameTitle">ğŸº The Matriarch and the Pack ğŸº</h1>

        <div class="help-button-container">
            <a href="https://www.tacorari.eu/wolfex.html" target="_blank" class="help-button" id="helpButton">ğŸ“– æ“ä½œæ–¹æ³•ãƒ»ã‚²ãƒ¼ãƒ æ¦‚è¦</a>
        </div>

        <div class="language-selection">
            <button id="langJaBtn" class="control-btn active" onclick="setLanguage('ja')">æ—¥æœ¬èª</button>
            <button id="langEnBtn" class="control-btn" onclick="setLanguage('en')">English</button>
            <button id="langZhBtn" class="control-btn" onclick="setLanguage('zh')">ä¸­æ–‡</button>
        </div>

        <div class="stage-info">
            <span id="stageLabel">ã‚¹ãƒ†ãƒ¼ã‚¸</span> <span id="stage">1</span> / 50
        </div>

        <div class="game-area">
            <div class="game-board">
                <div class="game-grid" id="gameGrid"></div>

                <div class="controls">
                    <div class="control-selection">
                        <span id="controlledWolfLabel">ç¾åœ¨æ“ä½œä¸­:</span> <span id="controlledWolfDisplay">æ¯ã‚¦ãƒ«ãƒ•</span>
                        <button id="controlMotherBtn" class="control-btn active" onclick="switchControlledWolf('mother')">æ¯ã‚¦ãƒ«ãƒ•ã‚’æ“ä½œ</button>
                        <button id="controlPackBtn" class="control-btn" onclick="switchControlledWolf('pack')">ç¾¤ã‚Œã‚’æ“ä½œ</button>
                    </div>
                    <button class="control-btn" onclick="move(0, -1)" id="moveWestBtn">â¬…ï¸ è¥¿</button>
                    <button class="control-btn" onclick="move(-1, 0)" id="moveNorthBtn">â¬†ï¸ åŒ—</button>
                    <button class="control-btn" onclick="move(0, 1)" id="moveEastBtn">â¡ï¸ æ±</button>
                    <button class="control-btn action-btn" onclick="howl()" id="howlBtn">ğŸŒ™ é å ãˆ</button>
                    <button class="control-btn" onclick="move(1, 0)" id="moveSouthBtn">â¬‡ï¸ å—</button>
                    <button class="control-btn action-btn" onclick="destroyObstacle()" id="destroyBtn">ğŸ’¥ ç ´å£Š</button>
                    
                    <button class="control-btn action-btn" onclick="resetGame()" id="resetBtn" style="grid-column: span 3;">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>

                    <div class="music-controls-container">
                        <span id="musicControllerLabel">éŸ³æ¥½ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼</span>
                        <div class="music-controls">
                            <button id="prevMusicBtn" onclick="prevSong()">â®ï¸</button>
                            <button id="playPauseBtn" onclick="togglePlayPause()">â–¶ï¸</button>
                            <button id="nextMusicBtn" onclick="nextSong()">â­ï¸</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="ui-panel">
                <div class="stat-group">
                    <h3 id="motherWolfStatsTitle">ğŸº æ¯ã‚¦ãƒ«ãƒ•</h3>
                    <div><span id="levelLabel">ãƒ¬ãƒ™ãƒ«</span>: <span id="level">1</span></div>
                    <div><span id="hpLabel">HP</span>: <span id="health">100</span>/<span id="maxHealth">100</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill" id="healthBar" style="width: 100%"></div>
                    </div>
                    <div><span id="hungerLabel">æº€è…¹åº¦</span>: <span id="hunger">100</span>/100</div>
                    <div class="stat-bar">
                        <div class="stat-fill hunger" id="hungerBar" style="width: 100%"></div>
                    </div>
                    <div><span id="expLabel">çµŒé¨“å€¤</span>: <span id="exp">0</span>/100</div>
                    <div class="stat-bar">
                        <div class="stat-fill exp" id="expBar" style="width: 0%"></div>
                    </div>
                    <div><span id="attackLabel">æ”»æ’ƒåŠ›</span>: <span id="attack">20</span></div>
                </div>

                <div class="stat-group">
                    <h3 id="packInfoTitle">ğŸº ç¾¤ã‚Œæƒ…å ±</h3>
                    <div><span id="totalWolvesLabel">ç·é ­æ•°</span>: <span id="packCount">0</span></div>
                    <div><span id="packHpLabel">ç¾¤ã‚ŒHP</span>: <span id="packHealth">0</span>/<span id="packMaxHealth">0</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill pack-hp" id="packHealthBar" style="width: 0%"></div>
                    </div>
                    <div><span id="totalPackAttackLabel">ç¾¤ã‚Œç·æ”»æ’ƒåŠ›</span>: <span id="packPower">0</span></div>
                    <div class="pack-traits" id="packTraits"></div>
                </div>

                <div class="stat-group">
                    <h3 id="messagesTitle">ğŸ“œ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</h3>
                    <div class="message-area" id="messages"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2 id="gameOverHeading">ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</h2>
            <p id="gameOverMessage">æ¯ã‚¦ãƒ«ãƒ•ã¯å€’ã‚Œã¾ã—ãŸã€‚ã‚ãªãŸã®æ—…ã¯ã“ã“ã§çµ‚ã‚ã‚Šã¾ã™ã€‚</p>
            <button onclick="resetGame()" id="tryAgainBtn">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
        </div>
    </div>

    <audio id="gameMusic" preload="auto"></audio>

    <script>
        // Game state
        let gameState = {
            player: { x: 0, y: 0, health: 100, maxHealth: 100, hunger: 100, maxHunger: 100, level: 1, exp: 0, attack: 20 },
            pack: null,
            packMembers: [],
            packHealth: 0,
            packMaxHealth: 0,
            enemies: [],
            grid: [],
            stage: 1,
            playerMoveCount: 0,
            controlledWolf: 'mother',
            currentLanguage: 'ja',
            currentSongIndex: 0,
            musicPlaying: false,
            imagesLoaded: {
                motherWolf: false,
                packWolf: false
            },
            startPos: { x: 0, y: 0 },
            goalPos: { x: 14, y: 14 }
        };

        function preloadImages() {
            const motherWolfImg = new Image();
            const packWolfImg = new Image();
            
            motherWolfImg.onload = function() {
                gameState.imagesLoaded.motherWolf = true;
                console.log("Mother wolf image loaded successfully");
                updateImageDisplay();
            };
            
            motherWolfImg.onerror = function() {
                gameState.imagesLoaded.motherWolf = false;
                console.log("Mother wolf image failed to load");
                updateImageDisplay();
            };
            
            packWolfImg.onload = function() {
                gameState.imagesLoaded.packWolf = true;
                console.log("Pack wolf image loaded successfully");
                updateImageDisplay();
            };
            
            packWolfImg.onerror = function() {
                gameState.imagesLoaded.packWolf = false;
                console.log("Pack wolf image failed to load");
                updateImageDisplay();
            };
            
            motherWolfImg.src = 'https://github.com/Soyadayo/Mappon/raw/main/mother_wolf.png';
            packWolfImg.src = 'https://github.com/Soyadayo/Mappon/raw/main/pack_wolf.png';
        }

        function updateImageDisplay() {
            if (typeof renderGame === 'function') {
                renderGame();
            }
        }

        const playlist = [
            "https://github.com/Soyadayo/Mappon/blob/main/music1.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music2.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music3.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music4.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music5.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music6.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music7.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music8.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music9.mp3?raw=true"
        ];

        let audioPlayer;

        const translations = {
            ja: {
                title: "ğŸº The Matriarch and the Pack ğŸº",
                helpButton: "ğŸ“– æ“ä½œæ–¹æ³•ãƒ»ã‚²ãƒ¼ãƒ æ¦‚è¦",
                stage: "ã‚¹ãƒ†ãƒ¼ã‚¸",
                controlledBy: "ç¾åœ¨æ“ä½œä¸­:",
                motherWolfControl: "æ¯ã‚¦ãƒ«ãƒ•ã‚’æ“ä½œ",
                packControl: "ç¾¤ã‚Œã‚’æ“ä½œ",
                west: "â¬…ï¸ è¥¿",
                north: "â¬†ï¸ åŒ—",
                east: "â¡ï¸ æ±",
                south: "â¬‡ï¸ å—",
                howl: "ğŸŒ™ é å ãˆ",
                destroy: "ğŸ’¥ ç ´å£Š",
                reset: "ğŸ”„ ãƒªã‚»ãƒƒãƒˆ",
                musicController: "éŸ³æ¥½ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©ãƒ¼",
                motherWolf: "ğŸº æ¯ã‚¦ãƒ«ãƒ•",
                level: "ãƒ¬ãƒ™ãƒ«",
                hp: "HP",
                hunger: "æº€è…¹åº¦",
                exp: "çµŒé¨“å€¤",
                attack: "æ”»æ’ƒåŠ›",
                packInfo: "ğŸº ç¾¤ã‚Œæƒ…å ±",
                totalWolves: "ç·é ­æ•°",
                packHp: "ç¾¤ã‚ŒHP",
                totalPackAttack: "ç¾¤ã‚Œç·æ”»æ’ƒåŠ›",
                messages: "ğŸ“œ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸",
                gameOver: "ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼",
                gameOverMessage1: "æ¯ã‚¦ãƒ«ãƒ•ã¯å€’ã‚Œã¾ã—ãŸã€‚ã‚ãªãŸã®æ—…ã¯ã“ã“ã§çµ‚ã‚ã‚Šã¾ã™ã€‚",
                gameOverMessage2: "ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ã‚ãªãŸã¯ç¾¤ã‚Œã‚’ç‡ã„ã¦æœ€å¼·ã®åœ°ã«å›è‡¨ã—ã¾ã—ãŸï¼",
                tryAgain: "ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤",
                victory: "å‹åˆ©ï¼",
                cannotPassWaterMountain: "ğŸš« {terrainType}ã‚’é€šéã§ãã¾ã›ã‚“ï¼ç ´å£Šãƒœã‚¿ãƒ³ã§ã‚¯ãƒªã‚¢ã—ã¦ãã ã•ã„ã€‚",
                boardEdge: "ğŸš« ãƒœãƒ¼ãƒ‰ã®ç«¯ã§ã™ï¼",
                motherCannotMoveOnPack: "ğŸš« æ¯ã‚¦ãƒ«ãƒ•ã¯ç¾¤ã‚Œã®ä¸Šã«ç§»å‹•ã§ãã¾ã›ã‚“ã€‚",
                packCannotMoveOnMother: "ğŸš« ç¾¤ã‚Œã¯æ¯ã‚¦ãƒ«ãƒ•ã®ä¸Šã«ç§»å‹•ã§ãã¾ã›ã‚“ã€‚",
                noPackToControl: "ğŸº ç¾¤ã‚ŒãŒã„ãªã„ãŸã‚ã€ç§»å‹•ã§ãã¾ã›ã‚“ï¼æ¯ã‚¦ãƒ«ãƒ•ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚",
                controlledWolfSwitched: "æ“ä½œå¯¾è±¡ã‚’{unitType}ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚",
                hungerDamage: "ğŸ– æº€è…¹åº¦ä¸è¶³ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸï¼",
                motherStarved: "æ¯ã‚¦ãƒ«ãƒ•ã¯é£¢ãˆæ­»ã«ã—ã¾ã—ãŸï¼",
                dealtDamage: "ğŸ¦· ã‚ãªãŸã¯{enemyName}ã«{damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸï¼",
                ateEnemy: "ğŸ– ã‚ãªãŸã¯{enemyName}ã‚’é£Ÿã¹ã¾ã—ãŸï¼æº€è…¹åº¦ãŒå›å¾©ã—ã€{exp}çµŒé¨“å€¤ã‚’ç²å¾—ï¼",
                newPupBorn: "âœ¨ '{traitName}'ã®ç‰¹æ€§ã‚’æŒã¤æ–°ã—ã„å­ç‹¼ãŒç”Ÿã¾ã‚Œã¾ã—ãŸï¼",
                defeatedBoss: "ğŸ† æã‚‹ã¹ã{enemyName}ã‚’å€’ã—ã¾ã—ãŸï¼",
                enemyCounterattacked: "ğŸ’¥ {enemyName}ãŒåæ’ƒï¼{damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸã€‚",
                motherDefeated: "æ¯ã‚¦ãƒ«ãƒ•ã¯æ•µã«å€’ã•ã‚Œã¾ã—ãŸï¼",
                packDealtDamage: "ğŸº ã‚ãªãŸã®ç¾¤ã‚Œï¼ˆ{packCount}é ­ï¼‰ã¯{enemyName}ã«{damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸï¼",
                packDefeatedEnemy: "ğŸº ã‚ãªãŸã®ç¾¤ã‚Œã¯{enemyName}ã‚’å€’ã—ã¾ã—ãŸï¼æ¯ã¯{exp}çµŒé¨“å€¤ã‚’ç²å¾—ã€‚",
                packMemberLost: "ğŸ’€ {lostWolves}é ­ã®ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ãŒæˆ¦é—˜ã§å€’ã‚Œã¾ã—ãŸ...",
                packDisbanded: "ğŸ¾ ã‚ãªãŸã®ç¾¤ã‚Œã¯è§£æ•£ã—ã¾ã—ãŸï¼",
                howled: "ğŸŒ™ ã‚ãªãŸã¯é å ãˆã‚’ã—ã¾ã—ãŸï¼æ¯ã¨{healedCount}é ­ã®ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ãŒ{healAmount}HPå›å¾©ï¼",
                tooHungryToHowl: "ğŸš« ç©ºè…¹ã™ãã¦é å ãˆã§ãã¾ã›ã‚“ï¼",
                level3Required: "ğŸš« éšœå®³ç‰©ã‚’ç ´å£Šã™ã‚‹ã«ã¯ãƒ¬ãƒ™ãƒ«3ä»¥ä¸ŠãŒå¿…è¦ã§ã™ï¼",
                motherOnlySkill: "ğŸš« ã“ã®ã‚¹ã‚­ãƒ«ã¯æ¯ã‚¦ãƒ«ãƒ•ã®ã¿ãŒä½¿ç”¨ã§ãã¾ã™ï¼",
                obstacleDestroyed: "ğŸ’¥ éšœå®³ç‰©ã‚’ç ´å£Šã—ã¾ã—ãŸï¼",
                noObstaclesNearby: "ğŸš« å‘¨å›²ã«ç ´å£Šå¯èƒ½ãªéšœå®³ç‰©ã¯ã‚ã‚Šã¾ã›ã‚“ï¼",
                levelUp: "ğŸŒŸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ã‚ãªãŸã¯ãƒ¬ãƒ™ãƒ«{level}ã«ãªã‚Šã¾ã—ãŸï¼",
                destroyAbilityUnlocked: "ğŸ’ª ã“ã‚Œã§éšœå®³ç‰©ç ´å£Šã‚¹ã‚­ãƒ«ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼",
                gameClear: "ğŸ‰ å…¨ã¦ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’åˆ¶è¦‡ã—ã¾ã—ãŸï¼ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼",
                advancingStage: "ğŸ‰ ã‚¹ãƒ†ãƒ¼ã‚¸{stage}ã¸é€²è¡Œï¼",
                hpHungerRestored: "ğŸ’ª ä½“åŠ›ã¨æº€è…¹åº¦ãŒå®Œå…¨ã«å›å¾©ã—ã¾ã—ãŸï¼",
                initialMessage1: "ğŸŒ™ æ¯ã‚¦ãƒ«ãƒ•ã¨ã—ã¦ã€ç¾¤ã‚Œã‚’å½¢æˆã—ã¾ã—ã‚‡ã†ï¼ç²ç‰©ã‹ã‚‰ç‰¹æ€§ã‚’ç¶™æ‰¿ã—ã€æœ€å¼·ã®ç¾¤ã‚Œã‚’ç¯‰ãã¾ã—ã‚‡ã†ï¼",
                initialMessage2: "ğŸ¯ ã‚´ãƒ¼ãƒ«ï¼ˆé‡‘è‰²ã‚¿ã‚¤ãƒ«ï¼‰ã¸å‘ã‹ã„ã¾ã—ã‚‡ã†ï¼",
                packAutoAttacked: "ğŸº ç¾¤ã‚ŒãŒè‡ªå‹•ã§{enemyName}ã‚’æ”»æ’ƒã—ã¾ã—ãŸï¼",
                speed: "æ•æ·æ€§",
                health: "ç”Ÿå‘½åŠ›",
                attack: "åŠ›",
                defense: "é˜²å¾¡",
                vision: "è¦–åŠ›",
                leadership: "çµ±ç‡åŠ›",
                ferocity: "ç°çŒ›ã•",
                draconic: "ç«œã®åŠ›",
                goliath: "å·¨äººã®åŠ›",
                elemental: "å…ƒç´ ã®åŠ›",
                grass: "è‰åŸ",
                forest: "æ£®æ—",
                mountain: "å±±",
                water: "æ°´",
                desert: "ç ‚æ¼ ",
                volcano: "ç«å±±",
                snow: "é›ªåŸ",
                swamp: "æ²¼åœ°",
                crystal: "ã‚¯ãƒªã‚¹ã‚¿ãƒ«",
                void: "è™šç„¡"
            },
            en: {
                title: "ğŸº The Matriarch and the Pack ğŸº",
                helpButton: "ğŸ“– How to Playãƒ»Game Guide",
                stage: "Stage",
                controlledBy: "Currently Controlling:",
                motherWolfControl: "Control Mother Wolf",
                packControl: "Control Pack",
                west: "â¬…ï¸ West",
                north: "â¬†ï¸ North",
                east: "â¡ï¸ East",
                south: "â¬‡ï¸ South",
                howl: "ğŸŒ™ Howl",
                destroy: "ğŸ’¥ Destroy",
                reset: "ğŸ”„ Reset",
                musicController: "Music Controller",
                motherWolf: "ğŸº Mother Wolf",
                level: "Level",
                hp: "HP",
                hunger: "Hunger",
                exp: "EXP",
                attack: "Attack",
                packInfo: "ğŸº Pack Info",
                totalWolves: "Total Wolves",
                packHp: "Pack HP",
                totalPackAttack: "Total Pack Attack",
                messages: "ğŸ“œ Messages",
                gameOver: "Game Over!",
                gameOverMessage1: "The Mother Wolf has fallen. Your journey ends here.",
                gameOverMessage2: "Congratulations! You have led your pack to become the strongest in the land!",
                tryAgain: "Try Again",
                victory: "Victory!",
                cannotPassWaterMountain: "ğŸš« Cannot pass through {terrainType}! Use the Destroy button to clear.",
                boardEdge: "ğŸš« Board edge!",
                motherCannotMoveOnPack: "ğŸš« Mother Wolf cannot move onto Pack's position.",
                packCannotMoveOnMother: "ğŸš« Pack cannot move onto Mother Wolf's position.",
                noPackToControl: "ğŸº No pack members! Cannot control pack. Switching to Mother Wolf.",
                controlledWolfSwitched: "Control switched to {unitType}.",
                hungerDamage: "ğŸ– You took damage from hunger!",
                motherStarved: "The Mother Wolf starved to death!",
                dealtDamage: "ğŸ¦· You dealt {damage} damage to {enemyName}!",
                ateEnemy: "ğŸ– You ate the {enemyName}! Hunger restored +{exp} EXP",
                newPupBorn: "âœ¨ A new pup with the '{traitName}' trait was born!",
                defeatedBoss: "ğŸ† You defeated the mighty {enemyName}!",
                enemyCounterattacked: "ğŸ’¥ {enemyName} counter-attacked! Took {damage} damage.",
                motherDefeated: "The Mother Wolf was defeated by an enemy!",
                packDealtDamage: "ğŸº Your pack ({packCount} wolves) dealt {damage} damage to {enemyName}!",
                packDefeatedEnemy: "ğŸº Your pack defeated {enemyName}! Mother gained {exp} EXP.",
                packMemberLost: "ğŸ’€ {lostWolves} pack members fell in battle...",
                packDisbanded: "ğŸ¾ Your pack has been disbanded!",
                howled: "ğŸŒ™ You howled! Mother and {healedCount} pack members healed for {healAmount} HP!",
                tooHungryToHowl: "ğŸš« Too hungry to howl!",
                level3Required: "ğŸš« You need to be Level 3 or higher to destroy obstacles!",
                motherOnlySkill: "ğŸš« This skill can only be used by the Mother Wolf!",
                obstacleDestroyed: "ğŸ’¥ Obstacle destroyed!",
                noObstaclesNearby: "ğŸš« No destroyable obstacles nearby!",
                levelUp: "ğŸŒŸ Level Up! You are now Level {level}!",
                destroyAbilityUnlocked: "ğŸ’ª You can now use the Destroy Obstacle ability!",
                gameClear: "ğŸ‰ You have conquered all stages! Game Clear!",
                advancingStage: "ğŸ‰ Advancing to Stage {stage}!",
                hpHungerRestored: "ğŸ’ª Health and Hunger fully restored!",
                initialMessage1: "ğŸŒ™ As the Mother Wolf, form your pack! Inherit traits from prey and build the strongest pack!",
                initialMessage2: "ğŸ¯ Head to the Goal (golden tile)!",
                packAutoAttacked: "ğŸº Pack automatically attacked {enemyName}!",
                speed: "Speed",
                health: "Vitality",
                attack: "Strength",
                defense: "Defense",
                vision: "Vision",
                leadership: "Leadership",
                ferocity: "Ferocity",
                draconic: "Draconic Might",
                goliath: "Goliath Strength",
                elemental: "Elemental Power",
                grass: "Grass",
                forest: "Forest",
                mountain: "Mountain",
                water: "Water",
                desert: "Desert",
                volcano: "Volcano",
                snow: "Snow",
                swamp: "Swamp",
                crystal: "Crystal",
                void: "Void"
            },
            zh: {
                title: "ğŸº The Matriarch and the Pack ğŸº",
                helpButton: "ğŸ“– æ“ä½œæ–¹æ³•ãƒ»æ¸¸æˆæŒ‡å—",
                stage: "å…³å¡",
                controlledBy: "å½“å‰æ§åˆ¶:",
                motherWolfControl: "æ§åˆ¶æ¯ç‹¼",
                packControl: "æ§åˆ¶ç‹¼ç¾¤",
                west: "â¬…ï¸ è¥¿",
                north: "â¬†ï¸ åŒ—",
                east: "â¡ï¸ ä¸œ",
                south: "â¬‡ï¸ å—",
                howl: "ğŸŒ™ åšå«",
                destroy: "ğŸ’¥ ç ´å",
                reset: "ğŸ”„ é‡ç½®",
                musicController: "éŸ³ä¹æ§åˆ¶å™¨",
                motherWolf: "ğŸº æ¯ç‹¼",
                level: "ç­‰çº§",
                hp: "ç”Ÿå‘½å€¼",
                hunger: "é¥¥é¥¿åº¦",
                exp: "ç»éªŒå€¼",
                attack: "æ”»å‡»åŠ›",
                packInfo: "ğŸº ç‹¼ç¾¤ä¿¡æ¯",
                totalWolves: "æ€»æ•°é‡",
                packHp: "ç‹¼ç¾¤ç”Ÿå‘½å€¼",
                totalPackAttack: "ç‹¼ç¾¤æ€»æ”»å‡»åŠ›",
                messages: "ğŸ“œ æ¶ˆæ¯",
                gameOver: "æ¸¸æˆç»“æŸï¼",
                gameOverMessage1: "æ¯ç‹¼å€’ä¸‹äº†ã€‚ä½ çš„æ—…ç¨‹åœ¨æ­¤ç»“æŸã€‚",
                gameOverMessage2: "æ­å–œï¼ä½ å¸¦é¢†ç‹¼ç¾¤æˆä¸ºäº†è¿™ç‰‡åœŸåœ°ä¸Šæœ€å¼ºçš„å­˜åœ¨ï¼",
                tryAgain: "å†æ¬¡å°è¯•",
                victory: "èƒœåˆ©ï¼",
                cannotPassWaterMountain: "ğŸš« æ— æ³•é€šè¿‡{terrainType}ï¼ä½¿ç”¨ç ´åæŒ‰é’®æ¸…é™¤ã€‚",
                boardEdge: "ğŸš« åœ°å›¾è¾¹ç¼˜ï¼",
                motherCannotMoveOnPack: "ğŸš« æ¯ç‹¼ä¸èƒ½ç§»åŠ¨åˆ°ç‹¼ç¾¤ä½ç½®ã€‚",
                packCannotMoveOnMother: "ğŸš« ç‹¼ç¾¤ä¸èƒ½ç§»åŠ¨åˆ°æ¯ç‹¼ä½ç½®ã€‚",
                noPackToControl: "ğŸº æ²¡æœ‰ç‹¼ç¾¤æˆå‘˜ï¼æ— æ³•æ§åˆ¶ç‹¼ç¾¤ã€‚åˆ‡æ¢åˆ°æ¯ç‹¼ã€‚",
                controlledWolfSwitched: "æ§åˆ¶åˆ‡æ¢åˆ°{unitType}ã€‚",
                hungerDamage: "ğŸ– ä½ å› é¥¥é¥¿å—åˆ°ä¼¤å®³ï¼",
                motherStarved: "æ¯ç‹¼é¥¿æ­»äº†ï¼",
                dealtDamage: "ğŸ¦· ä½ å¯¹{enemyName}é€ æˆäº†{damage}ç‚¹ä¼¤å®³ï¼",
                ateEnemy: "ğŸ– ä½ åƒæ‰äº†{enemyName}ï¼é¥¥é¥¿åº¦æ¢å¤ +{exp}ç»éªŒå€¼",
                newPupBorn: "âœ¨ ä¸€åªæ‹¥æœ‰'{traitName}'ç‰¹æ€§çš„æ–°å¹¼ç‹¼è¯ç”Ÿäº†ï¼",
                defeatedBoss: "ğŸ† ä½ å‡»è´¥äº†å¼ºå¤§çš„{enemyName}ï¼",
                enemyCounterattacked: "ğŸ’¥ {enemyName}åå‡»ï¼å—åˆ°{damage}ç‚¹ä¼¤å®³ã€‚",
                motherDefeated: "æ¯ç‹¼è¢«æ•Œäººå‡»è´¥äº†ï¼",
                packDealtDamage: "ğŸº ä½ çš„ç‹¼ç¾¤ï¼ˆ{packCount}åªç‹¼ï¼‰å¯¹{enemyName}é€ æˆäº†{damage}ç‚¹ä¼¤å®³ï¼",
                packDefeatedEnemy: "ğŸº ä½ çš„ç‹¼ç¾¤å‡»è´¥äº†{enemyName}ï¼æ¯ç‹¼è·å¾—{exp}ç»éªŒå€¼ã€‚",
                packMemberLost: "ğŸ’€ {lostWolves}åªç‹¼ç¾¤æˆå‘˜åœ¨æˆ˜æ–—ä¸­å€’ä¸‹äº†...",
                packDisbanded: "ğŸ¾ ä½ çš„ç‹¼ç¾¤è§£æ•£äº†ï¼",
                howled: "ğŸŒ™ ä½ åšå«äº†ï¼æ¯ç‹¼å’Œ{healedCount}åªç‹¼ç¾¤æˆå‘˜æ¢å¤äº†{healAmount}ç”Ÿå‘½å€¼ï¼",
                tooHungryToHowl: "ğŸš« å¤ªé¥¿äº†æ— æ³•åšå«ï¼",
                level3Required: "ğŸš« ä½ éœ€è¦è¾¾åˆ°3çº§æˆ–æ›´é«˜æ‰èƒ½ç ´åéšœç¢ç‰©ï¼",
                motherOnlySkill: "ğŸš« è¿™ä¸ªæŠ€èƒ½åªèƒ½ç”±æ¯ç‹¼ä½¿ç”¨ï¼",
                obstacleDestroyed: "ğŸ’¥ éšœç¢ç‰©è¢«ç ´åäº†ï¼",
                noObstaclesNearby: "ğŸš« é™„è¿‘æ²¡æœ‰å¯ç ´åçš„éšœç¢ç‰©ï¼",
                levelUp: "ğŸŒŸ å‡çº§ï¼ä½ ç°åœ¨æ˜¯{level}çº§ï¼",
                destroyAbilityUnlocked: "ğŸ’ª ä½ ç°åœ¨å¯ä»¥ä½¿ç”¨ç ´åéšœç¢ç‰©èƒ½åŠ›äº†ï¼",
                gameClear: "ğŸ‰ ä½ å¾æœäº†æ‰€æœ‰å…³å¡ï¼æ¸¸æˆé€šå…³ï¼",
                advancingStage: "ğŸ‰ å‰è¿›åˆ°ç¬¬{stage}å…³ï¼",
                hpHungerRestored: "ğŸ’ª ç”Ÿå‘½å€¼å’Œé¥¥é¥¿åº¦å®Œå…¨æ¢å¤ï¼",
                initialMessage1: "ğŸŒ™ ä½œä¸ºæ¯ç‹¼ï¼Œç»„å»ºä½ çš„ç‹¼ç¾¤ï¼ä»çŒç‰©é‚£é‡Œç»§æ‰¿ç‰¹æ€§ï¼Œå»ºç«‹æœ€å¼ºçš„ç‹¼ç¾¤ï¼",
                initialMessage2: "ğŸ¯ å‰å¾€ç›®æ ‡ï¼ˆé‡‘è‰²æ–¹å—ï¼‰ï¼",
                packAutoAttacked: "ğŸº ç‹¼ç¾¤è‡ªåŠ¨æ”»å‡»äº†{enemyName}ï¼",
                speed: "é€Ÿåº¦",
                health: "ç”Ÿå‘½åŠ›",
                attack: "åŠ›é‡",
                defense: "é˜²å¾¡",
                vision: "è§†è§‰",
                leadership: "é¢†å¯¼åŠ›",
                ferocity: "å‡¶çŒ›",
                draconic: "é¾™ä¹‹åŠ›",
                goliath: "å·¨äººä¹‹åŠ›",
                elemental: "å…ƒç´ ä¹‹åŠ›",
                grass: "è‰åŸ",
                forest: "æ£®æ—",
                mountain: "å±±",
                water: "æ°´",
                desert: "æ²™æ¼ ",
                volcano: "ç«å±±",
                snow: "é›ªåŸ",
                swamp: "æ²¼æ³½",
                crystal: "æ°´æ™¶",
                void: "è™šç©º"
            }
        };

        function getTranslation(key, params = {}) {
            let text = translations[gameState.currentLanguage][key] || key;
            for (const [paramKey, value] of Object.entries(params)) {
                text = text.replace(`{${paramKey}}`, value);
            }
            return text;
        }

        function setLanguage(lang) {
            gameState.currentLanguage = lang;
            
            document.getElementById('langJaBtn').classList.remove('active');
            document.getElementById('langEnBtn').classList.remove('active');
            document.getElementById('langZhBtn').classList.remove('active');
            document.getElementById(`lang${lang === 'ja' ? 'Ja' : lang === 'en' ? 'En' : 'Zh'}Btn`).classList.add('active');
            
            document.getElementById('gameTitle').textContent = getTranslation('title');
            document.getElementById('helpButton').textContent = getTranslation('helpButton');
            document.getElementById('stageLabel').textContent = getTranslation('stage');
            document.getElementById('controlledWolfLabel').textContent = getTranslation('controlledBy');
            document.getElementById('controlMotherBtn').textContent = getTranslation('motherWolfControl');
            document.getElementById('controlPackBtn').textContent = getTranslation('packControl');
            document.getElementById('moveWestBtn').textContent = getTranslation('west');
            document.getElementById('moveNorthBtn').textContent = getTranslation('north');
            document.getElementById('moveEastBtn').textContent = getTranslation('east');
            document.getElementById('moveSouthBtn').textContent = getTranslation('south');
            document.getElementById('howlBtn').textContent = getTranslation('howl');
            document.getElementById('destroyBtn').textContent = getTranslation('destroy');
            document.getElementById('resetBtn').textContent = getTranslation('reset');
            document.getElementById('musicControllerLabel').textContent = getTranslation('musicController');
            document.getElementById('motherWolfStatsTitle').textContent = getTranslation('motherWolf');
            document.getElementById('levelLabel').textContent = getTranslation('level');
            document.getElementById('hpLabel').textContent = getTranslation('hp');
            document.getElementById('hungerLabel').textContent = getTranslation('hunger');
            document.getElementById('expLabel').textContent = getTranslation('exp');
            document.getElementById('attackLabel').textContent = getTranslation('attack');
            document.getElementById('packInfoTitle').textContent = getTranslation('packInfo');
            document.getElementById('totalWolvesLabel').textContent = getTranslation('totalWolves');
            document.getElementById('packHpLabel').textContent = getTranslation('packHp');
            document.getElementById('totalPackAttackLabel').textContent = getTranslation('totalPackAttack');
            document.getElementById('messagesTitle').textContent = getTranslation('messages');
            document.getElementById('gameOverHeading').textContent = getTranslation('gameOver');
            document.getElementById('tryAgainBtn').textContent = getTranslation('tryAgain');
            
            const unitType = gameState.controlledWolf === 'mother' ? 
                (lang === 'ja' ? 'æ¯ã‚¦ãƒ«ãƒ•' : lang === 'en' ? 'Mother Wolf' : 'æ¯ç‹¼') : 
                (lang === 'ja' ? 'ç¾¤ã‚Œ' : lang === 'en' ? 'Pack' : 'ç‹¼ç¾¤');
            document.getElementById('controlledWolfDisplay').textContent = unitType;
        }

        const GAME_BOARD_SIZE = 15;  // Increased board size
        const MAX_STAGE = 50;
        const BOSS_STAGE_INTERVAL = 10;
        const STAGE_THEME_INTERVAL = 10;

        const TERRAIN = {
            GRASS: 'grass',
            FOREST: 'forest',
            MOUNTAIN: 'mountain',
            WATER: 'water',
            DESERT: 'desert',
            VOLCANO: 'volcano',
            SNOW: 'snow',
            SWAMP: 'swamp',
            CRYSTAL: 'crystal',
            VOID: 'void',
            GOAL: 'goal'
        };

        const ENEMY_TYPES = [
            { icon: 'ğŸ°', name: 'Rabbit', baseHealth: 30, baseAttack: 5, exp: 15, speed: 2, trait: 'speed' },
            { icon: 'ğŸ¦Œ', name: 'Deer', baseHealth: 50, baseAttack: 10, exp: 25, speed: 1, trait: 'health' },
            { icon: 'ğŸ—', name: 'Boar', baseHealth: 70, baseAttack: 15, exp: 35, speed: 1, trait: 'attack' },
            { icon: 'ğŸ»', name: 'Bear', baseHealth: 100, baseAttack: 20, exp: 50, speed: 1, trait: 'defense' },
            { icon: 'ğŸ¦…', name: 'Eagle', baseHealth: 40, baseAttack: 25, exp: 40, speed: 2, trait: 'vision' }
        ];

        const BOSS_TYPES = [
            { icon: 'ğŸº', name: 'Alpha Wolf', baseHealth: 300, baseAttack: 40, exp: 200, speed: 1, trait: 'leadership' },
            { icon: 'ğŸ…', name: 'Saber-tooth Tiger', baseHealth: 500, baseAttack: 60, exp: 300, speed: 2, trait: 'ferocity' },
            { icon: 'ğŸ‰', name: 'Ancient Dragon', baseHealth: 800, baseAttack: 80, exp: 500, speed: 1, trait: 'draconic' },
            { icon: 'ğŸ¦', name: 'King Kong', baseHealth: 1200, baseAttack: 100, exp: 800, speed: 1, trait: 'goliath' },
            { icon: 'ğŸ”¥', name: 'Elemental Lord', baseHealth: 1500, baseAttack: 120, exp: 1000, speed: 2, trait: 'elemental' }
        ];

        function initGame() {
            generateRandomPositions();
            generateTerrain();
            generateEnemies();
            setupAudioPlayer();
            preloadImages();
            setLanguage(gameState.currentLanguage);
            updatePackHealth();
            addMessage(getTranslation("initialMessage1"), "level");
            addMessage(getTranslation("initialMessage2"), "level");
            updateControlButtons();
            renderGame();
            startMusicOnLoad();
        }

        // Generate random start and goal positions
        function generateRandomPositions() {
            // Generate random start position (not in corners)
            let startX, startY;
            do {
                startX = Math.floor(Math.random() * GAME_BOARD_SIZE);
                startY = Math.floor(Math.random() * GAME_BOARD_SIZE);
            } while ((startX === 0 && startY === 0) || 
                     (startX === GAME_BOARD_SIZE-1 && startY === GAME_BOARD_SIZE-1) ||
                     (startX === 0 && startY === GAME_BOARD_SIZE-1) || 
                     (startX === GAME_BOARD_SIZE-1 && startY === 0));
            
            gameState.startPos = { x: startX, y: startY };
            gameState.player.x = startX;
            gameState.player.y = startY;

            // Generate random goal position (ensure it's far enough from start)
            let goalX, goalY;
            do {
                goalX = Math.floor(Math.random() * GAME_BOARD_SIZE);
                goalY = Math.floor(Math.random() * GAME_BOARD_SIZE);
            } while (Math.abs(goalX - startX) + Math.abs(goalY - startY) < GAME_BOARD_SIZE / 2);
            
            gameState.goalPos = { x: goalX, y: goalY };
        }

        function startMusicOnLoad() {
            setTimeout(() => {
                if (audioPlayer && playlist.length > 0) {
                    audioPlayer.play().then(() => {
                        gameState.musicPlaying = true;
                        document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
                        console.log("Music auto-started successfully");
                    }).catch(error => {
                        console.log("Auto-play was prevented by browser policy:", error);
                        gameState.musicPlaying = false;
                        document.getElementById('playPauseBtn').textContent = 'â–¶ï¸';
                        
                        const startMusicOnFirstClick = () => {
                            if (!gameState.musicPlaying) {
                                audioPlayer.play().then(() => {
                                    gameState.musicPlaying = true;
                                    document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
                                    console.log("Music started after user interaction");
                                }).catch(err => {
                                    console.log("Still could not start music:", err);
                                });
                            }
                            document.removeEventListener('click', startMusicOnFirstClick);
                            document.removeEventListener('keydown', startMusicOnFirstClick);
                        };
                        
                        document.addEventListener('click', startMusicOnFirstClick, { once: true });
                        document.addEventListener('keydown', startMusicOnFirstClick, { once: true });
                    });
                }
            }, 500);
        }

        function setupAudioPlayer() {
            audioPlayer = document.getElementById('gameMusic');
            audioPlayer.volume = 0.3;
            
            if (playlist.length > 0) {
                audioPlayer.src = playlist[gameState.currentSongIndex];
                audioPlayer.load();
            }

            audioPlayer.addEventListener('ended', () => {
                nextSong(true);
            });
            
            audioPlayer.addEventListener('error', (e) => {
                console.log("Audio file could not be loaded:", e);
                if (gameState.musicPlaying) {
                    nextSong(true);
                }
            });

            audioPlayer.addEventListener('canplaythrough', () => {
                updateMusicDisplay();
            });

            audioPlayer.addEventListener('loadeddata', () => {
                console.log(`Music ${gameState.currentSongIndex + 1} loaded successfully`);
            });
        }

        function updateMusicDisplay() {
            if (gameState.musicPlaying && !audioPlayer.paused) {
                document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
            } else {
                document.getElementById('playPauseBtn').textContent = 'â–¶ï¸';
            }
        }

        function togglePlayPause() {
            if (!audioPlayer || playlist.length === 0) return;
            
            if (gameState.musicPlaying && !audioPlayer.paused) {
                audioPlayer.pause();
                gameState.musicPlaying = false;
                document.getElementById('playPauseBtn').textContent = 'â–¶ï¸';
            } else {
                audioPlayer.play().then(() => {
                    gameState.musicPlaying = true;
                    document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
                }).catch(error => {
                    console.log("Could not play audio:", error);
                    audioPlayer.load();
                    setTimeout(() => {
                        audioPlayer.play().then(() => {
                            gameState.musicPlaying = true;
                            document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
                        }).catch(err => {
                            console.log("Still could not play audio:", err);
                            document.getElementById('playPauseBtn').textContent = 'âŒ';
                        });
                    }, 1000);
                });
            }
        }

        function nextSong(autoAdvance = false) {
            if (playlist.length === 0) return;
            
            gameState.currentSongIndex = (gameState.currentSongIndex + 1) % playlist.length;
            audioPlayer.src = playlist[gameState.currentSongIndex];
            audioPlayer.load();
            
            if (gameState.musicPlaying || autoAdvance) {
                audioPlayer.addEventListener('canplaythrough', () => {
                    audioPlayer.play().then(() => {
                        gameState.musicPlaying = true;
                        document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
                    }).catch(error => {
                        console.log("Could not play next song:", error);
                        gameState.musicPlaying = false;
                        document.getElementById('playPauseBtn').textContent = 'â–¶ï¸';
                    });
                }, { once: true });
            }
            
            updateMusicDisplay();
        }

        function prevSong() {
            if (playlist.length === 0) return;
            
            gameState.currentSongIndex = (gameState.currentSongIndex - 1 + playlist.length) % playlist.length;
            audioPlayer.src = playlist[gameState.currentSongIndex];
            audioPlayer.load();
            
            if (gameState.musicPlaying) {
                audioPlayer.addEventListener('canplaythrough', () => {
                    audioPlayer.play().then(() => {
                        gameState.musicPlaying = true;
                        document.getElementById('playPauseBtn').textContent = 'â¸ï¸';
                    }).catch(error => {
                        console.log("Could not play previous song:", error);
                        gameState.musicPlaying = false;
                        document.getElementById('playPauseBtn').textContent = 'â–¶ï¸';
                    });
                }, { once: true });
            }
            
            updateMusicDisplay();
        }

        function generateTerrain() {
            gameState.grid = [];
            let currentTerrainTypes = [];

            const themeIndex = Math.floor((gameState.stage - 1) / STAGE_THEME_INTERVAL);
            switch (themeIndex) {
                case 0:
                    currentTerrainTypes = [TERRAIN.GRASS, TERRAIN.FOREST, TERRAIN.MOUNTAIN, TERRAIN.WATER];
                    break;
                case 1:
                    currentTerrainTypes = [TERRAIN.DESERT, TERRAIN.MOUNTAIN, TERRAIN.WATER];
                    break;
                case 2:
                    currentTerrainTypes = [TERRAIN.VOLCANO, TERRAIN.MOUNTAIN, TERRAIN.WATER];
                    break;
                case 3:
                    currentTerrainTypes = [TERRAIN.SNOW, TERRAIN.FOREST, TERRAIN.WATER];
                    break;
                case 4:
                    currentTerrainTypes = [TERRAIN.SWAMP, TERRAIN.FOREST, TERRAIN.WATER];
                    break;
                case 5:
                    currentTerrainTypes = [TERRAIN.CRYSTAL, TERRAIN.VOID, TERRAIN.WATER];
                    break;
                default:
                    currentTerrainTypes = [TERRAIN.GRASS, TERRAIN.FOREST, TERRAIN.MOUNTAIN, TERRAIN.WATER];
                    break;
            }

            for (let row = 0; row < GAME_BOARD_SIZE; row++) {
                gameState.grid[row] = [];
                for (let col = 0; col < GAME_BOARD_SIZE; col++) {
                    if (row === gameState.startPos.x && col === gameState.startPos.y) {
                        gameState.grid[row][col] = currentTerrainTypes[0];
                    } else if (row === gameState.goalPos.x && col === gameState.goalPos.y) {
                        gameState.grid[row][col] = TERRAIN.GOAL;
                    } else {
                        const randomIndex = Math.floor(Math.random() * currentTerrainTypes.length);
                        gameState.grid[row][col] = currentTerrainTypes[randomIndex];
                    }
                }
            }

            ensurePathExists();
        }

        function ensurePathExists() {
            // Simple pathfinding to ensure there's always a path from start to goal
            const queue = [{x: gameState.startPos.x, y: gameState.startPos.y}];
            const visited = new Set();
            visited.add(`${gameState.startPos.x},${gameState.startPos.y}`);
            
            // Clear a path from start to goal if needed
            while (queue.length > 0) {
                const current = queue.shift();
                
                if (current.x === gameState.goalPos.x && current.y === gameState.goalPos.y) {
                    return; // Path exists
                }
                
                // Check all 4 directions
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (const [dx, dy] of directions) {
                    const newX = current.x + dx;
                    const newY = current.y + dy;
                    const key = `${newX},${newY}`;
                    
                    if (newX >= 0 && newX < GAME_BOARD_SIZE && 
                        newY >= 0 && newY < GAME_BOARD_SIZE && 
                        !visited.has(key)) {
                        
                        visited.add(key);
                        
                        // If this is an impassable terrain, make it passable
                        if (gameState.grid[newX][newY] === TERRAIN.WATER || 
                            gameState.grid[newX][newY] === TERRAIN.MOUNTAIN ||
                            gameState.grid[newX][newY] === TERRAIN.VOLCANO || 
                            gameState.grid[newX][newY] === TERRAIN.VOID) {
                            gameState.grid[newX][newY] = TERRAIN.GRASS;
                        }
                        
                        queue.push({x: newX, y: newY});
                    }
                }
            }
        }

        function generateEnemies() {
            gameState.enemies = [];
            let enemyCount = 8 + Math.floor(gameState.stage / 2);

            if (gameState.stage % BOSS_STAGE_INTERVAL === 0 && gameState.stage <= MAX_STAGE) {
                const bossIndex = (gameState.stage / BOSS_STAGE_INTERVAL) - 1;
                const bossType = BOSS_TYPES[bossIndex];

                let x, y;
                do {
                    x = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    y = Math.floor(Math.random() * GAME_BOARD_SIZE);
                } while ((x === gameState.player.x && y === gameState.player.y) || 
                         (gameState.pack && x === gameState.pack.x && y === gameState.pack.y) ||
                         (x === gameState.goalPos.x && y === gameState.goalPos.y) ||
                         gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN ||
                         gameState.grid[x][y] === TERRAIN.VOLCANO || gameState.grid[x][y] === TERRAIN.VOID);

                gameState.enemies.push({
                    x, y,
                    icon: bossType.icon,
                    name: bossType.name,
                    health: bossType.baseHealth + (gameState.stage * 10),
                    maxHealth: bossType.baseHealth + (gameState.stage * 10),
                    attack: bossType.baseAttack + (gameState.stage * 3),
                    exp: bossType.exp + (gameState.stage * 5),
                    speed: bossType.speed,
                    trait: bossType.trait,
                    traitName: getTranslation(bossType.trait),
                    id: Date.now() + Math.random(),
                    moveCounter: 0,
                    isBoss: true
                });
                enemyCount = 0;
            }

            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    y = Math.floor(Math.random() * GAME_BOARD_SIZE);
                } while ((x === gameState.player.x && y === gameState.player.y) || 
                         (gameState.pack && x === gameState.pack.x && y === gameState.pack.y) ||
                         (x === gameState.goalPos.x && y === gameState.goalPos.y) ||
                         gameState.enemies.some(e => e.x === x && e.y === y) ||
                         gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN ||
                         gameState.grid[x][y] === TERRAIN.VOLCANO || gameState.grid[x][y] === TERRAIN.VOID);

                const typeIndex = Math.min(Math.floor(Math.random() * ENEMY_TYPES.length),
                                          Math.floor(gameState.stage / 5));
                const enemyType = ENEMY_TYPES[typeIndex];

                gameState.enemies.push({
                    x, y,
                    icon: enemyType.icon,
                    name: enemyType.name,
                    health: enemyType.baseHealth + (gameState.stage * 2),
                    maxHealth: enemyType.baseHealth + (gameState.stage * 2),
                    attack: enemyType.baseAttack + Math.floor(gameState.stage / 3),
                    exp: enemyType.exp + Math.floor(gameState.stage / 2),
                    speed: enemyType.speed,
                    trait: enemyType.trait,
                    traitName: getTranslation(enemyType.trait),
                    id: Date.now() + Math.random(),
                    moveCounter: 0,
                    isBoss: false
                });
            }
        }

        function renderGame() {
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';

            for (let row = 0; row < GAME_BOARD_SIZE; row++) {
                for (let col = 0; col < GAME_BOARD_SIZE; col++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${gameState.grid[row][col]}`;

                    let content = '';

                    if (gameState.player.x === row && gameState.player.y === col) {
                        const controlledClass = gameState.controlledWolf === 'mother' ? ' controlled' : '';
                        if (gameState.imagesLoaded.motherWolf) {
                            content = `<span class="player${controlledClass}"></span>`;
                        } else {
                            content = `<span class="player${controlledClass}" style="background-image: none; color: #ff1493; font-size: 24px;">ğŸº</span>`;
                        }
                    }
                    else if (gameState.pack && gameState.pack.x === row && gameState.pack.y === col) {
                        const controlledClass = gameState.controlledWolf === 'pack' ? ' controlled' : '';
                        if (gameState.imagesLoaded.packWolf) {
                            content = `<span class="pack-icon${controlledClass}"><span class="pack-size">${gameState.packMembers.length}</span></span>`;
                        } else {
                            content = `<span class="pack-icon${controlledClass}" style="background-image: none; color: #9370db; font-size: 22px;">ğŸº<span class="pack-size">${gameState.packMembers.length}</span></span>`;
                        }
                    }
                    else if (gameState.enemies.some(e => e.x === row && e.y === col)) {
                        const enemy = gameState.enemies.find(e => e.x === row && e.y === col);
                        const hpPercent = (enemy.health / enemy.maxHealth) * 100;
                        content = `
                            <span class="enemy">${enemy.icon}</span>
                            <div class="hp-bar">
                                <div class="hp-fill" style="width: ${hpPercent}%"></div>
                            </div>
                        `;
                    }
                    else {
                        const terrainIconMap = {
                            [TERRAIN.GRASS]: 'ğŸŒ¾',
                            [TERRAIN.FOREST]: 'ğŸŒ²',
                            [TERRAIN.MOUNTAIN]: 'â›°ï¸',
                            [TERRAIN.WATER]: 'ğŸ’§',
                            [TERRAIN.DESERT]: 'ğŸœï¸',
                            [TERRAIN.VOLCANO]: 'ğŸŒ‹',
                            [TERRAIN.SNOW]: 'â„ï¸',
                            [TERRAIN.SWAMP]: 'ğŸŒ¿',
                            [TERRAIN.CRYSTAL]: 'ğŸ’',
                            [TERRAIN.VOID]: 'âš«',
                            [TERRAIN.GOAL]: 'ğŸ'
                        };
                        content = terrainIconMap[gameState.grid[row][col]] || '';
                    }

                    tile.innerHTML = content;
                    grid.appendChild(tile);
                }
            }

            updateUI();
        }

        function updateUI() {
            document.getElementById('stage').textContent = gameState.stage;
            document.getElementById('level').textContent = gameState.player.level;
            document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.player.health));
            document.getElementById('maxHealth').textContent = gameState.player.maxHealth;
            document.getElementById('hunger').textContent = Math.floor(gameState.player.hunger);
            document.getElementById('exp').textContent = gameState.player.exp;
            document.getElementById('attack').textContent = gameState.player.attack;
            document.getElementById('packCount').textContent = gameState.packMembers.length;
            document.getElementById('packHealth').textContent = Math.floor(gameState.packHealth);
            document.getElementById('packMaxHealth').textContent = gameState.packMaxHealth;

            let packPower = 0;
            gameState.packMembers.forEach(member => {
                packPower += member.attack;
            });
            document.getElementById('packPower').textContent = packPower;

            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const hungerPercent = (gameState.player.hunger / gameState.player.maxHunger) * 100;
            const expPercent = (gameState.player.exp / (gameState.player.level * 100)) * 100;
            const packHealthPercent = (gameState.packMembers.length > 0) ? (gameState.packHealth / gameState.packMaxHealth) * 100 : 0;

            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('hungerBar').style.width = hungerPercent + '%';
            document.getElementById('expBar').style.width = expPercent + '%';
            document.getElementById('packHealthBar').style.width = packHealthPercent + '%';

            const traitsDiv = document.getElementById('packTraits');
            traitsDiv.innerHTML = '';

            const traits = {};
            gameState.packMembers.forEach(member => {
                if (member.trait) {
                    traits[member.trait] = (traits[member.trait] || 0) + 1;
                }
            });

            const allEnemyTypes = [...ENEMY_TYPES, ...BOSS_TYPES];

            Object.entries(traits).forEach(([trait, count]) => {
                const traitBadge = document.createElement('div');
                traitBadge.className = 'trait-badge';
                const traitInfo = allEnemyTypes.find(e => e.trait === trait);
                if (traitInfo) {
                    traitBadge.innerHTML = `
                        <span>${traitInfo.icon}</span>
                        <span>${getTranslation(traitInfo.trait)}</span>
                        <span class="trait-count">Ã—${count}</span>
                    `;
                    traitsDiv.appendChild(traitBadge);
                }
            });

            const unitType = gameState.controlledWolf === 'mother' ? 
                (gameState.currentLanguage === 'ja' ? 'æ¯ã‚¦ãƒ«ãƒ•' : gameState.currentLanguage === 'en' ? 'Mother Wolf' : 'æ¯ç‹¼') : 
                (gameState.currentLanguage === 'ja' ? 'ç¾¤ã‚Œ' : gameState.currentLanguage === 'en' ? 'Pack' : 'ç‹¼ç¾¤');
            document.getElementById('controlledWolfDisplay').textContent = unitType;
        }

        function updatePackHealth() {
            let totalPackHealth = 0;
            let totalPackMaxHealth = 0;
            gameState.packMembers.forEach(member => {
                totalPackHealth += member.health;
                totalPackMaxHealth += member.maxHealth;
            });
            gameState.packHealth = totalPackHealth;
            gameState.packMaxHealth = totalPackMaxHealth;
        }

        function switchControlledWolf(target) {
            if (gameState.packMembers.length === 0 && target === 'pack') {
                addMessage(getTranslation("noPackToControl"), "hunt");
                return;
            }
            gameState.controlledWolf = target;
            const unitType = target === 'mother' ? 
                (gameState.currentLanguage === 'ja' ? 'æ¯ã‚¦ãƒ«ãƒ•' : gameState.currentLanguage === 'en' ? 'Mother Wolf' : 'æ¯ç‹¼') : 
                (gameState.currentLanguage === 'ja' ? 'ç¾¤ã‚Œ' : gameState.currentLanguage === 'en' ? 'Pack' : 'ç‹¼ç¾¤');
            addMessage(getTranslation("controlledWolfSwitched", {unitType}), "level");
            updateControlButtons();
            renderGame();
        }

        function updateControlButtons() {
            document.getElementById('controlMotherBtn').classList.remove('active');
            document.getElementById('controlPackBtn').classList.remove('active');
            if (gameState.controlledWolf === 'mother') {
                document.getElementById('controlMotherBtn').classList.add('active');
            } else {
                document.getElementById('controlPackBtn').classList.add('active');
            }
        }

        function move(dx, dy) {
            let activeUnit;
            let isMotherControlled = (gameState.controlledWolf === 'mother');

            if (isMotherControlled) {
                activeUnit = gameState.player;
            } else {
                if (!gameState.pack || gameState.packMembers.length === 0) {
                    addMessage(getTranslation("noPackToControl"), "hunt");
                    switchControlledWolf('mother');
                    return;
                }
                activeUnit = gameState.pack;
            }

            const newX = activeUnit.x + dx;
            const newY = activeUnit.y + dy;

            if (newX < 0 || newX >= GAME_BOARD_SIZE || newY < 0 || newY >= GAME_BOARD_SIZE) {
                addMessage(getTranslation("boardEdge"), "hunt");
                return;
            }

            const terrain = gameState.grid[newX][newY];
            if (terrain === TERRAIN.WATER || terrain === TERRAIN.MOUNTAIN || terrain === TERRAIN.VOLCANO || terrain === TERRAIN.VOID) {
                const terrainType = getTranslation(terrain);
                addMessage(getTranslation("cannotPassWaterMountain", {terrainType}), "hunt");
                return;
            }

            if (isMotherControlled && gameState.pack && newX === gameState.pack.x && newY === gameState.pack.y) {
                addMessage(getTranslation("motherCannotMoveOnPack"), "hunt");
                return;
            } else if (!isMotherControlled && newX === gameState.player.x && newY === gameState.player.y) {
                addMessage(getTranslation("packCannotMoveOnMother"), "hunt");
                return;
            }

            activeUnit.x = newX;
            activeUnit.y = newY;
            gameState.playerMoveCount++;

            const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                if (isMotherControlled) {
                    hunt(enemy);
                } else {
                    packAttack(enemy);
                }
            }

            // Check if goal reached (only Mother Wolf can reach goal)
            if (gameState.player.x === gameState.goalPos.x && gameState.player.y === gameState.goalPos.y) {
                nextStage();
                return;
            }

            gameState.player.hunger = Math.max(0, gameState.player.hunger - 2);
            if (gameState.player.hunger === 0) {
                gameState.player.health -= 5;
                addMessage(getTranslation("hungerDamage"), "hunt");
                if (gameState.player.health <= 0) {
                    gameOver(getTranslation("motherStarved"));
                    return;
                }
            }

            if (gameState.playerMoveCount % 2 === 0) {
                autoMoveFriendly();
            }

            moveEnemies();
            renderGame();
        }

        function autoMoveFriendly() {
            let autoUnit;
            let controlledUnit;

            if (gameState.controlledWolf === 'mother') {
                autoUnit = gameState.pack;
                controlledUnit = gameState.player;
            } else {
                autoUnit = gameState.player;
                controlledUnit = gameState.pack;
            }

            if (!autoUnit || (autoUnit === gameState.pack && gameState.packMembers.length === 0)) {
                return;
            }

            let targetX = autoUnit.x;
            let targetY = autoUnit.y;
            let foundTarget = false;

            // 1. Look for nearby enemies to attack
            let nearestEnemy = null;
            let minDistance = Infinity;
            gameState.enemies.forEach(enemy => {
                const distance = Math.abs(enemy.x - autoUnit.x) + Math.abs(enemy.y - autoUnit.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy && minDistance <= 5) {
                targetX = nearestEnemy.x;
                targetY = nearestEnemy.y;
                foundTarget = true;
            }
            else if (autoUnit === gameState.player && (autoUnit.x !== gameState.goalPos.x || autoUnit.y !== gameState.goalPos.y)) {
                targetX = gameState.goalPos.x;
                targetY = gameState.goalPos.y;
                foundTarget = true;
            }
            else {
                targetX = controlledUnit.x;
                targetY = controlledUnit.y;
                foundTarget = true;
            }

            if (!foundTarget) return;

            const dx = Math.sign(targetX - autoUnit.x);
            const dy = Math.sign(targetY - autoUnit.y);

            let newX = autoUnit.x;
            let newY = autoUnit.y;

            let moved = false;
            if (dx !== 0 && isValidAutoMove(autoUnit, autoUnit.x + dx, autoUnit.y, controlledUnit)) {
                newX += dx;
                moved = true;
            } else if (dy !== 0 && isValidAutoMove(autoUnit, autoUnit.x, autoUnit.y + dy, controlledUnit)) {
                newY += dy;
                moved = true;
            } else if (dx !== 0 && dy !== 0 && isValidAutoMove(autoUnit, autoUnit.x + dx, autoUnit.y + dy, controlledUnit)) {
                newX += dx;
                newY += dy;
                moved = true;
            }

            if (moved) {
                autoUnit.x = newX;
                autoUnit.y = newY;

                const encounteredEnemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
                if (encounteredEnemy) {
                    if (autoUnit === gameState.player) {
                        addMessage(getTranslation("packAutoAttacked", {enemyName: encounteredEnemy.name}), "hunt");
                        hunt(encounteredEnemy);
                    } else {
                        addMessage(getTranslation("packAutoAttacked", {enemyName: encounteredEnemy.name}), "pack");
                        packAttack(encounteredEnemy);
                    }
                }
            }
        }

        function isValidAutoMove(autoUnit, x, y, controlledUnit) {
            if (x < 0 || x >= GAME_BOARD_SIZE || y < 0 || y >= GAME_BOARD_SIZE) return false;

            const terrain = gameState.grid[x][y];
            if (terrain === TERRAIN.WATER || terrain === TERRAIN.MOUNTAIN || terrain === TERRAIN.VOLCANO || terrain === TERRAIN.VOID) return false;

            if (x === controlledUnit.x && y === controlledUnit.y) return false;

            return true;
        }

        function hunt(enemy) {
            const playerDamage = gameState.player.attack + Math.floor(Math.random() * (10 + gameState.player.level));
            enemy.health -= playerDamage;

            addMessage(getTranslation("dealtDamage", {enemyName: enemy.name, damage: playerDamage}), "hunt");

            if (enemy.health <= 0) {
                gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 40);
                gameState.player.exp += enemy.exp;

                addMessage(getTranslation("ateEnemy", {enemyName: enemy.name, exp: enemy.exp}), "pack");

                if (!enemy.isBoss) {
                    addMessage(getTranslation("newPupBorn", {traitName: enemy.traitName}), "pack");
                    createWolfWithTrait(enemy);
                } else {
                    addMessage(getTranslation("defeatedBoss", {enemyName: enemy.name}), "level");
                }

                gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                checkLevelUp();
            } else {
                const enemyDamage = enemy.attack + Math.floor(Math.random() * 10);
                gameState.player.health -= enemyDamage;
                addMessage(getTranslation("enemyCounterattacked", {enemyName: enemy.name, damage: enemyDamage}), "hunt");

                if (gameState.player.health <= 0) {
                    gameOver(getTranslation("motherDefeated"));
                    return;
                }
            }
            renderGame();
        }

        function createWolfWithTrait(enemy) {
            const baseHealth = 50 + gameState.player.level * 5;
            const baseAttack = 15 + gameState.player.level * 2;

            const newWolf = {
                health: baseHealth,
                maxHealth: baseHealth,
                attack: baseAttack,
                trait: enemy.trait,
                icon: enemy.icon,
                id: Date.now() + Math.random()
            };

            switch (enemy.trait) {
                case 'speed':
                    newWolf.attack += 5;
                    break;
                case 'health':
                    newWolf.health += 20;
                    newWolf.maxHealth += 20;
                    break;
                case 'attack':
                    newWolf.attack += 10;
                    break;
                case 'defense':
                    newWolf.health += 10;
                    newWolf.maxHealth += 10;
                    newWolf.attack += 2;
                    break;
                case 'vision':
                    break;
            }

            gameState.packMembers.push(newWolf);

            if (!gameState.pack) {
                const px = gameState.player.x;
                const py = gameState.player.y;
                let packX = px;
                let packY = py + 1;

                if (packY >= GAME_BOARD_SIZE) {
                    packX = px + 1;
                    packY = py;
                }
                if (packX >= GAME_BOARD_SIZE) {
                    packX = px;
                    packY = py;
                }

                gameState.pack = {
                    x: packX,
                    y: packY
                };
            }
            updatePackHealth();
        }

        function packAttack(enemy) {
            if (gameState.packMembers.length === 0) return;

            let totalDamage = 0;
            let defenseBonus = 0;

            gameState.packMembers.forEach(member => {
                totalDamage += member.attack;
                if (member.trait === 'defense') {
                    defenseBonus += 1;
                }
            });

            totalDamage += Math.floor(gameState.packMembers.length * 2);

            if (enemy.trait === 'defense') {
                totalDamage = Math.max(1, totalDamage - (enemy.attack / 2));
            }
            if (enemy.isBoss) {
                totalDamage = Math.max(1, totalDamage - (enemy.maxHealth / 20));
            }

            enemy.health -= totalDamage;
            addMessage(getTranslation("packDealtDamage", {packCount: gameState.packMembers.length, enemyName: enemy.name, damage: totalDamage}), "pack");

            if (enemy.health <= 0) {
                gameState.player.exp += Math.floor(enemy.exp * 0.8);
                gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                addMessage(getTranslation("packDefeatedEnemy", {enemyName: enemy.name, exp: Math.floor(enemy.exp * 0.8)}), "pack");

                checkLevelUp();

                const healAmount = 5 + Math.floor(enemy.exp / 10);
                gameState.packMembers.forEach(member => {
                    member.health = Math.min(member.maxHealth, member.health + healAmount);
                });
                updatePackHealth();
            } else {
                const individualDamage = Math.ceil(totalDamage / gameState.packMembers.length);
                gameState.packMembers.forEach(member => {
                    member.health = Math.max(0, member.health - individualDamage);
                });
                updatePackHealth();

                let initialPackCount = gameState.packMembers.length;
                gameState.packMembers = gameState.packMembers.filter(member => member.health > 0);
                let lostWolves = initialPackCount - gameState.packMembers.length;

                if (lostWolves > 0) {
                    addMessage(getTranslation("packMemberLost", {lostWolves}), "hunt");
                }

                if (gameState.packMembers.length === 0) {
                    gameState.pack = null;
                    addMessage(getTranslation("packDisbanded"), "hunt");
                    if (gameState.controlledWolf === 'pack') {
                        switchControlledWolf('mother');
                    }
                }
            }
        }

        function moveEnemies() {
            gameState.enemies.forEach(enemy => {
                enemy.moveCounter++;

                const moveFrequency = enemy.speed === 2 ? 1 : 2;
                if (enemy.moveCounter % moveFrequency !== 0) return;

                let targetX = gameState.player.x;
                let targetY = gameState.player.y;
                let targetType = 'player';

                if (gameState.pack && gameState.packMembers.length > 0) {
                    const packDistance = Math.abs(gameState.pack.x - enemy.x) + Math.abs(gameState.pack.y - enemy.y);
                    const playerDistance = Math.abs(gameState.player.x - enemy.x) + Math.abs(gameState.player.y - enemy.y);

                    if (packDistance <= playerDistance) {
                        targetX = gameState.pack.x;
                        targetY = gameState.pack.y;
                        targetType = 'pack';
                    }
                }

                const distance = Math.abs(targetX - enemy.x) + Math.abs(targetY - enemy.y);

                if (distance <= (enemy.isBoss ? 8 : 5)) {
                    const dx = Math.sign(targetX - enemy.x);
                    const dy = Math.sign(targetY - enemy.y);

                    let newX = enemy.x;
                    let newY = enemy.y;

                    if (dx !== 0 && isValidEnemyMove(enemy.x + dx, enemy.y, enemy)) {
                        newX += dx;
                    } else if (dy !== 0 && isValidEnemyMove(enemy.x, enemy.y + dy, enemy)) {
                        newY += dy;
                    } else if (isValidEnemyMove(enemy.x + dx, enemy.y + dy, enemy)) {
                        newX += dx;
                        newY += dy;
                    }

                    if (newX !== enemy.x || newY !== enemy.y) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }

                    if ((enemy.x === targetX && Math.abs(enemy.y - targetY) <= 1) ||
                        (enemy.y === targetY && Math.abs(enemy.x - targetX) <= 1))
                    {
                        if (targetType === 'player') {
                            enemyAttackPlayer(enemy);
                        } else if (targetType === 'pack') {
                            enemyAttackPack(enemy);
                        }
                    }
                }
            });
        }

        function isValidEnemyMove(x, y, currentEnemy) {
            return x >= 0 && x < GAME_BOARD_SIZE && y >= 0 && y < GAME_BOARD_SIZE &&
                   gameState.grid[x][y] !== TERRAIN.WATER &&
                   gameState.grid[x][y] !== TERRAIN.MOUNTAIN &&
                   gameState.grid[x][y] !== TERRAIN.VOLCANO &&
                   gameState.grid[x][y] !== TERRAIN.VOID &&
                   !(gameState.player.x === x && gameState.player.y === y) &&
                   !(gameState.pack && gameState.pack.x === x && gameState.pack.y === y) &&
                   !gameState.enemies.some(e => e !== currentEnemy && e.x === x && e.y === y);
        }

        function enemyAttackPlayer(enemy) {
            const damage = enemy.attack + Math.floor(Math.random() * 10);
            gameState.player.health -= damage;
            addMessage(getTranslation("enemyCounterattacked", {enemyName: enemy.name, damage}), "hunt");

            if (gameState.player.health <= 0) {
                gameOver(getTranslation("motherDefeated"));
                return;
            }
        }

        function enemyAttackPack(enemy) {
            if (gameState.packMembers.length === 0) return;

            const damage = enemy.attack;
            let actualDamage = damage;

            const defenseWolves = gameState.packMembers.filter(m => m.trait === 'defense').length;
            if (defenseWolves > 0) {
                actualDamage = Math.max(1, damage - (defenseWolves * 5));
            }

            gameState.packHealth -= actualDamage;
            addMessage(getTranslation("enemyCounterattacked", {enemyName: enemy.name, damage: actualDamage}), "hunt");

            if (gameState.packHealth <= 0) {
                let initialPackCount = gameState.packMembers.length;
                let lostWolves = 0;

                gameState.packMembers.sort((a, b) => (a.health + a.attack) - (b.health + b.attack));
                while (gameState.packHealth <= 0 && gameState.packMembers.length > 0) {
                    gameState.packMembers.pop();
                    lostWolves++;
                    updatePackHealth();
                }

                if (lostWolves > 0) {
                    addMessage(getTranslation("packMemberLost", {lostWolves}), "hunt");
                }

                if (gameState.packMembers.length === 0) {
                    gameState.pack = null;
                    addMessage(getTranslation("packDisbanded"), "hunt");
                    if (gameState.controlledWolf === 'pack') {
                        switchControlledWolf('mother');
                    }
                }
            } else {
                const individualDamage = Math.ceil(actualDamage / gameState.packMembers.length);
                gameState.packMembers.forEach(member => {
                    member.health = Math.max(0, member.health - individualDamage);
                });
            }
            updatePackHealth();
        }

        function howl() {
            if (gameState.player.hunger >= 20) {
                gameState.player.hunger -= 20;

                const healAmount = 20 + gameState.player.level * 5;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);

                let healedCount = 0;
                gameState.packMembers.forEach(member => {
                    if (member.health < member.maxHealth) {
                        member.health = Math.min(member.maxHealth, member.health + healAmount);
                        healedCount++;
                    }
                });

                updatePackHealth();

                addMessage(getTranslation("howled", {healedCount, healAmount}), "pack");
                renderGame();
            } else {
                addMessage(getTranslation("tooHungryToHowl"), "hunt");
            }
        }

        function destroyObstacle() {
            if (gameState.player.level < 3) {
                addMessage(getTranslation("level3Required"), "hunt");
                return;
            }
            if (gameState.controlledWolf !== 'mother') {
                addMessage(getTranslation("motherOnlySkill"), "hunt");
                return;
            }

            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let destroyed = false;

            directions.forEach(([dx, dy]) => {
                const x = gameState.player.x + dx;
                const y = gameState.player.y + dy;

                if (x >= 0 && x < GAME_BOARD_SIZE && y >= 0 && y < GAME_BOARD_SIZE) {
                    if (gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN ||
                        gameState.grid[x][y] === TERRAIN.VOLCANO || gameState.grid[x][y] === TERRAIN.VOID) {
                        gameState.grid[x][y] = TERRAIN.GRASS;
                        destroyed = true;
                    }
                }
            });

            if (destroyed) {
                addMessage(getTranslation("obstacleDestroyed"), "level");
                gameState.player.hunger -= 10;
                renderGame();
            } else {
                addMessage(getTranslation("noObstaclesNearby"), "hunt");
            }
        }

        function checkLevelUp() {
            const requiredExp = gameState.player.level * 100;
            if (gameState.player.exp >= requiredExp) {
                gameState.player.level++;
                gameState.player.exp = gameState.player.exp - requiredExp;
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.maxHunger += 20;
                gameState.player.hunger = gameState.player.maxHunger;
                gameState.player.attack += 10;

                addMessage(getTranslation("levelUp", {level: gameState.player.level}), "level");

                if (gameState.player.level === 3) {
                    addMessage(getTranslation("destroyAbilityUnlocked"), "level");
                }
            }
        }

        function gameOver(message) {
            gameState.player.health = 0;
            addMessage(`ğŸ’€ ${message} ${getTranslation("gameOver")}`, "hunt");
            
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverHeading').textContent = getTranslation("gameOver");
            document.getElementById('tryAgainBtn').textContent = getTranslation("tryAgain");
            
            document.getElementById('gameOverModal').style.display = 'flex';
            
            setTimeout(() => {
                resetGame();
            }, 3000);
        }

        function nextStage() {
            if (gameState.stage >= MAX_STAGE) {
                addMessage(getTranslation("gameClear"), "level");
                
                document.getElementById('gameOverMessage').textContent = getTranslation("gameOverMessage2");
                document.getElementById('gameOverHeading').textContent = getTranslation("victory");
                document.getElementById('tryAgainBtn').textContent = getTranslation("tryAgain");
                document.getElementById('gameOverModal').style.display = 'flex';
                
                setTimeout(() => {
                    resetGame();
                }, 5000);
                return;
            }

            gameState.stage++;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.hunger = gameState.player.maxHunger;
            gameState.playerMoveCount = 0;

            addMessage(getTranslation("advancingStage", {stage: gameState.stage}), "level");
            addMessage(getTranslation("hpHungerRestored"), "pack");

            // Generate new random positions for next stage
            generateRandomPositions();

            if (gameState.pack) {
                // Move pack near player but not on same tile
                let packX = gameState.player.x;
                let packY = gameState.player.y + 1;

                if (packY >= GAME_BOARD_SIZE) {
                    packX = gameState.player.x + 1;
                    packY = gameState.player.y;
                }
                if (packX >= GAME_BOARD_SIZE) {
                    packX = gameState.player.x;
                    packY = gameState.player.y;
                }

                gameState.pack.x = packX;
                gameState.pack.y = packY;

                gameState.packMembers.forEach(member => {
                    member.health = member.maxHealth;
                });
                updatePackHealth();
            }

            generateTerrain();
            generateEnemies();
            renderGame();
        }

        function addMessage(text, type = "") {
            const messages = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;

            while (messages.children.length > 10) {
                messages.removeChild(messages.firstChild);
            }
        }

        function resetGame() {
            document.getElementById('gameOverModal').style.display = 'none';

            gameState = {
                player: { x: 0, y: 0, health: 100, maxHealth: 100, hunger: 100, maxHunger: 100, level: 1, exp: 0, attack: 20 },
                pack: null,
                packMembers: [],
                packHealth: 0,
                packMaxHealth: 0,
                enemies: [],
                grid: [],
                stage: 1,
                playerMoveCount: 0,
                controlledWolf: 'mother',
                currentLanguage: gameState.currentLanguage || 'ja',
                currentSongIndex: gameState.currentSongIndex || 0,
                musicPlaying: gameState.musicPlaying || false,
                imagesLoaded: gameState.imagesLoaded || { motherWolf: false, packWolf: false },
                startPos: { x: 0, y: 0 },
                goalPos: { x: 14, y: 14 }
            };

            document.getElementById('messages').innerHTML = '';
            
            document.getElementById('gameOverHeading').textContent = gameState.currentLanguage === 'ja' ? 'ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼' : 'Game Over!';
            document.getElementById('tryAgainBtn').textContent = gameState.currentLanguage === 'ja' ? 'ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤' : 'Try Again';
            
            generateRandomPositions();
            generateTerrain();
            generateEnemies();
            updatePackHealth();
            setLanguage(gameState.currentLanguage);
            addMessage(getTranslation("initialMessage1"), "level");
            addMessage(getTranslation("initialMessage2"), "level");
            updateControlButtons();
            renderGame();
        }

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameOverModal').style.display === 'flex') {
                return;
            }
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W': move(-1, 0); break;
                case 'ArrowDown': case 's': case 'S': move(1, 0); break;
                case 'ArrowLeft': case 'a': case 'A': move(0, -1); break;
                case 'ArrowRight': case 'd': case 'D': move(0, 1); break;
                case ' ': howl(); break;
                case 'x': case 'X': destroyObstacle(); break;
                case 'q': case 'Q': switchControlledWolf('mother'); break;
                case 'e': case 'E': switchControlledWolf('pack'); break;
            }
        });

        setInterval(() => {
            if (gameState.player.hunger < gameState.player.maxHunger && gameState.player.health > 0) {
                gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 0.5);
                updateUI();
            }
        }, 3000);

        window.onload = initGame;
    </script>
</body>
</html>

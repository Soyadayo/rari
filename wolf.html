<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hunger Within - 2D SRPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #fff;
            padding: 20px;
            overflow-x: auto;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: auto 300px;
            gap: 20px;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(12, 45px);
            grid-template-rows: repeat(12, 45px);
            gap: 2px;
            background: #111;
            padding: 10px;
            border-radius: 10px;
            border: 3px solid #8a2be2;
            width: fit-content;
            box-shadow: inset 0 0 20px rgba(138, 43, 226, 0.3);
            margin-bottom: 20px;
            transition: border-color 0.5s, background-color 0.5s, box-shadow 0.5s;
        }

        .cell {
            width: 45px;
            height: 45px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: #222;
            border-radius: 3px;
            transition: all 0.2s;
            position: relative;
        }

        .cell.path { background: #444; }
        .cell.wall { background: #111; border-color: #555; }
        .cell.water { background: #1e3a5f; }
        .cell.mountain { background: #5a5a5a; }
        .cell.forest { background: #2d5016; }
        .cell.desert { background: #8B4513; }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
            max-width: 600px;
        }

        .control-selection {
            grid-column: 1 / -1;
            margin-bottom: 15px;
            text-align: center;
        }

        .control-btn {
            padding: 15px 10px;
            background: #2a2a2a;
            border: 2px solid #555;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            min-height: 50px;
        }

        .control-btn:hover {
            background: #3a3a3a;
            border-color: #777;
        }

        .control-btn.active {
            background: #4a4a4a;
            border-color: #888;
        }

        .control-btn.compact {
            padding: 12px 8px;
            font-size: 18px;
            min-width: auto;
        }

        .control-btn.action-btn {
            background: #3a2a2a;
            border-color: #8a2be2;
        }

        .control-btn.action-btn:hover {
            background: #4a3a3a;
            border-color: #9a3bf2;
        }

        .sidebar {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #333;
        }

        .stat-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .stat-section h3 {
            color: #8a2be2;
            margin-bottom: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .stat-bar {
            background: #333;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
            border: 1px solid #555;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .health-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
        .hunger-fill { background: linear-gradient(90deg, #ff8800, #ffaa00); }
        .exp-fill { background: linear-gradient(90deg, #4488ff, #66aaff); }

        .messages {
            max-height: 300px;
            overflow-y: auto;
            background: #111;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
        }

        .message {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .message.combat { color: #ff6666; }
        .message.level { color: #66ff66; }
        .message.pack { color: #ffaa00; }
        .message.info { color: #66aaff; }

        .title {
            text-align: center;
            margin-bottom: 20px;
            color: #8a2be2;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        .stage-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            color: #fff;
        }

        .pack-member {
            background: #2a2a2a;
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #444;
        }

        .pack-member.injured {
            border-color: #ff4444;
            background: #3a2a2a;
        }

        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .controls {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <h1 class="title">The Hunger Within</h1>
            <div class="stage-info">
                <span>ã‚¹ãƒ†ãƒ¼ã‚¸: <span id="stageDisplay">1</span></span>
                <span style="margin-left: 20px;">ã‚¿ãƒ¼ãƒ³: <span id="turnDisplay">0</span></span>
            </div>
            <div id="gameGrid" class="game-grid"></div>
            
            <div class="controls">
                <div class="control-selection">
                    <span id="controlledWolfLabel">ç¾åœ¨æ“ä½œä¸­:</span> 
                    <span id="controlledWolfDisplay">æ¯ã‚¦ãƒ«ãƒ•</span>
                    <br><br>
                    <button id="controlMotherBtn" class="control-btn active" onclick="switchControlledWolf('mother')">æ¯ã‚¦ãƒ«ãƒ•ã‚’æ“ä½œ</button>
                    <button id="controlPackBtn" class="control-btn" onclick="switchControlledWolf('pack')">ç¾¤ã‚Œã‚’æ“ä½œ</button>
                </div>
                
                <button class="control-btn" onclick="move(0, -1)" id="moveWestBtn">â¬…ï¸ è¥¿</button>
                <button class="control-btn" onclick="move(-1, 0)" id="moveNorthBtn">â¬†ï¸ åŒ—</button>
                <button class="control-btn" onclick="move(0, 1)" id="moveEastBtn">â¡ï¸ æ±</button>
                
                <button class="control-btn" onclick="move(1, 0)" id="moveSouthBtn">â¬‡ï¸ å—</button>
                <button class="control-btn action-btn compact" onclick="howl()" id="howlBtn" title="é å ãˆ">ğŸŒ™</button>
                <button class="control-btn action-btn compact" onclick="destroyObstacle()" id="destroyBtn" title="ç ´å£Š">ğŸ’¥</button>
                
                <button class="control-btn action-btn" onclick="rest()" id="restBtn">ğŸ˜´ ä¼‘æ¯</button>
                <button class="control-btn action-btn" onclick="hunt()" id="huntBtn">ğŸ¦Œ ç‹©ã‚Š</button>
                <button class="control-btn action-btn" onclick="resetGame()" id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
            </div>
        </div>

        <div class="sidebar">
            <div class="stat-section">
                <h3>æ¯ã‚¦ãƒ«ãƒ• ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</h3>
                <div>ãƒ¬ãƒ™ãƒ«: <span id="playerLevel">1</span></div>
                <div>
                    HP: <span id="playerHP">100</span>/<span id="playerMaxHP">100</span>
                    <div class="stat-bar">
                        <div class="stat-fill health-fill" id="playerHPBar"></div>
                    </div>
                </div>
                <div>
                    ç©ºè…¹åº¦: <span id="playerHunger">100</span>/<span id="playerMaxHunger">100</span>
                    <div class="stat-bar">
                        <div class="stat-fill hunger-fill" id="playerHungerBar"></div>
                    </div>
                </div>
                <div>
                    çµŒé¨“å€¤: <span id="playerExp">0</span>/<span id="playerExpToNext">100</span>
                    <div class="stat-bar">
                        <div class="stat-fill exp-fill" id="playerExpBar"></div>
                    </div>
                </div>
                <div>æ”»æ’ƒåŠ›: <span id="playerAttack">20</span></div>
                <div>ç§»å‹•ç¯„å›²: <span id="playerMoveRange">2</span></div>
            </div>

            <div class="stat-section" id="packSection" style="display: none;">
                <h3>ç¾¤ã‚Œã®çŠ¶æ…‹</h3>
                <div>ç¾¤ã‚Œã‚µã‚¤ã‚º: <span id="packSize">0</span></div>
                <div id="packMembers"></div>
            </div>

            <div class="stat-section">
                <h3>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ­ã‚°</h3>
                <div id="messages" class="messages"></div>
            </div>
        </div>
    </div>

    <script>
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã®åˆæœŸåŒ–
        const GRID_SIZE = 12;
        const MAX_STAGE = 50;

        // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ†ãƒ¼ãƒã®å®šç¾©
        const STAGE_THEMES = {
            1: { // ã‚¹ãƒ†ãƒ¼ã‚¸ 1-10: æ£®æ—ãƒ†ãƒ¼ãƒ
                borderColor: '#2d5016',
                backgroundColor: '#1a3a1a',
                shadowColor: 'rgba(45, 80, 22, 0.3)'
            },
            11: { // ã‚¹ãƒ†ãƒ¼ã‚¸ 11-20: å±±å²³ãƒ†ãƒ¼ãƒ
                borderColor: '#4a4a4a',
                backgroundColor: '#2a2a2a',
                shadowColor: 'rgba(74, 74, 74, 0.3)'
            },
            21: { // ã‚¹ãƒ†ãƒ¼ã‚¸ 21-30: æ°´è¾ºãƒ†ãƒ¼ãƒ
                borderColor: '#1e3a5f',
                backgroundColor: '#0f1f3f',
                shadowColor: 'rgba(30, 58, 95, 0.3)'
            },
            31: { // ã‚¹ãƒ†ãƒ¼ã‚¸ 31-40: ç ‚æ¼ ãƒ†ãƒ¼ãƒ
                borderColor: '#8B4513',
                backgroundColor: '#4A2511',
                shadowColor: 'rgba(139, 69, 19, 0.3)'
            },
            41: { // ã‚¹ãƒ†ãƒ¼ã‚¸ 41-50: é­”ç•Œãƒ†ãƒ¼ãƒ
                borderColor: '#8a2be2',
                backgroundColor: '#4a1a5a',
                shadowColor: 'rgba(138, 43, 226, 0.3)'
            }
        };

        let gameState = {
            stage: 1,
            turn: 0,
            controlledUnit: 'mother', // 'mother' ã¾ãŸã¯ 'pack'
            player: {
                x: 0, y: 0,
                health: 100, maxHealth: 100,
                hunger: 100, maxHunger: 100,
                level: 1, exp: 0, expToNext: 100,
                attack: 20, moveRange: 2
            },
            pack: null,
            packMembers: [],
            grid: [],
            enemies: [],
            terrain: [],
            playerMoveCount: 0
        };

        // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ†ãƒ¼ãƒã‚’é©ç”¨ã™ã‚‹é–¢æ•°
        function applyStageTheme() {
            const currentStage = gameState.stage;
            let theme = STAGE_THEMES[1]; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ†ãƒ¼ãƒ
            
            // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã«é©ã—ãŸãƒ†ãƒ¼ãƒã‚’é¸æŠ
            const themeKeys = Object.keys(STAGE_THEMES).map(Number).sort((a, b) => a - b);
            for (let i = themeKeys.length - 1; i >= 0; i--) {
                if (currentStage >= themeKeys[i]) {
                    theme = STAGE_THEMES[themeKeys[i]];
                    break;
                }
            }
            
            // CSSã‚’å‹•çš„ã«é©ç”¨
            const gameGrid = document.getElementById('gameGrid');
            gameGrid.style.borderColor = theme.borderColor;
            gameGrid.style.backgroundColor = theme.backgroundColor;
            gameGrid.style.boxShadow = `inset 0 0 20px ${theme.shadowColor}`;
        }

        // ç¿»è¨³ã‚·ã‚¹ãƒ†ãƒ 
        const translations = {
            advancingStage: "ã‚¹ãƒ†ãƒ¼ã‚¸ {stage} ã«é€²ã¿ã¾ã™ï¼",
            hpHungerRestored: "HPã¨ç©ºè…¹åº¦ãŒå›å¾©ã—ã¾ã—ãŸã€‚",
            movedTo: "{direction}ã«ç§»å‹•ã—ã¾ã—ãŸã€‚",
            cannotMove: "ãã“ã«ã¯ç§»å‹•ã§ãã¾ã›ã‚“ã€‚",
            enemyDefeated: "æ•µã‚’å€’ã—ã¾ã—ãŸï¼",
            tookDamage: "{damage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸã€‚",
            levelUp: "ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ãƒ¬ãƒ™ãƒ«{level}ã«ãªã‚Šã¾ã—ãŸã€‚",
            packJoined: "æ–°ã—ã„ä»²é–“ãŒç¾¤ã‚Œã«åŠ ã‚ã‚Šã¾ã—ãŸï¼",
            hunted: "ç‹©ã‚Šã‚’è¡Œã„ã¾ã—ãŸã€‚ç©ºè…¹åº¦ãŒå›å¾©ã—ã¾ã—ãŸã€‚",
            rested: "ä¼‘æ¯ã—ã¾ã—ãŸã€‚HPãŒå›å¾©ã—ã¾ã—ãŸã€‚",
            howled: "é å ãˆã—ã¾ã—ãŸã€‚è¿‘ãã®ä»²é–“ã‚’å‘¼ã³å¯„ã›ã¾ã—ãŸã€‚",
            obstacleDestroyed: "éšœå®³ç‰©ã‚’ç ´å£Šã—ã¾ã—ãŸã€‚",
            gameOver: "ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼",
            gameCleared: "å…¨ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼"
        };

        function getTranslation(key, params = {}) {
            let text = translations[key] || key;
            Object.keys(params).forEach(param => {
                text = text.replace(`{${param}}`, params[param]);
            });
            return text;
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
        function addMessage(text, type = 'info') {
            const messages = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ•°åˆ¶é™
            while (messages.children.length > 50) {
                messages.removeChild(messages.firstChild);
            }
        }

        // ã‚°ãƒªãƒƒãƒ‰åˆæœŸåŒ–
        function initializeGrid() {
            gameState.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        }

        // åœ°å½¢ç”Ÿæˆ
        function generateTerrain() {
            gameState.terrain = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill('path'));
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ã«å¿œã˜ãŸåœ°å½¢ç”Ÿæˆ
            const stageType = Math.floor((gameState.stage - 1) / 10);
            
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const rand = Math.random();
                    
                    switch (stageType) {
                        case 0: // æ£®æ— (1-10)
                            if (rand < 0.15) gameState.terrain[x][y] = 'forest';
                            else if (rand < 0.25) gameState.terrain[x][y] = 'wall';
                            break;
                        case 1: // å±±å²³ (11-20)
                            if (rand < 0.2) gameState.terrain[x][y] = 'mountain';
                            else if (rand < 0.3) gameState.terrain[x][y] = 'wall';
                            break;
                        case 2: // æ°´è¾º (21-30)
                            if (rand < 0.15) gameState.terrain[x][y] = 'water';
                            else if (rand < 0.25) gameState.terrain[x][y] = 'wall';
                            break;
                        case 3: // ç ‚æ¼  (31-40)
                            if (rand < 0.1) gameState.terrain[x][y] = 'desert';
                            else if (rand < 0.2) gameState.terrain[x][y] = 'wall';
                            break;
                        default: // é­”ç•Œ (41-50)
                            if (rand < 0.3) gameState.terrain[x][y] = 'wall';
                            break;
                    }
                }
            }
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–‹å§‹ä½ç½®ã‚’ã‚¯ãƒªã‚¢
            gameState.terrain[0][0] = 'path';
            if (gameState.pack) {
                gameState.terrain[1][1] = 'path';
            }
        }

        // æ•µç”Ÿæˆ
        function generateEnemies() {
            gameState.enemies = [];
            const enemyCount = Math.min(3 + Math.floor(gameState.stage / 5), 8);
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while (
                    (x === gameState.player.x && y === gameState.player.y) ||
                    (gameState.pack && x === gameState.pack.x && y === gameState.pack.y) ||
                    gameState.terrain[x][y] === 'wall' ||
                    gameState.enemies.some(enemy => enemy.x === x && enemy.y === y)
                );

                gameState.enemies.push({
                    x, y,
                    health: 30 + gameState.stage * 5,
                    maxHealth: 30 + gameState.stage * 5,
                    attack: 10 + gameState.stage * 2,
                    moveRange: 1
                });
            }
        }

        // æ“ä½œãƒ¦ãƒ‹ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆ
        function switchControlledWolf(unit) {
            gameState.controlledUnit = unit;
            
            document.getElementById('controlMotherBtn').classList.toggle('active', unit === 'mother');
            document.getElementById('controlPackBtn').classList.toggle('active', unit === 'pack');
            
            const display = document.getElementById('controlledWolfDisplay');
            display.textContent = unit === 'mother' ? 'æ¯ã‚¦ãƒ«ãƒ•' : 'ç¾¤ã‚Œ';
            
            addMessage(`${unit === 'mother' ? 'æ¯ã‚¦ãƒ«ãƒ•' : 'ç¾¤ã‚Œ'}ã‚’æ“ä½œã—ã¾ã™ã€‚`, 'info');
        }

        // ç§»å‹•å‡¦ç†
        function move(dx, dy) {
            const currentUnit = gameState.controlledUnit === 'mother' ? gameState.player : gameState.pack;
            
            if (!currentUnit) {
                addMessage("æ“ä½œå¯èƒ½ãªãƒ¦ãƒ‹ãƒƒãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚", 'info');
                return;
            }

            const newX = currentUnit.x + dx;
            const newY = currentUnit.y + dy;

            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                addMessage(getTranslation("cannotMove"), 'info');
                return;
            }

            if (gameState.terrain[newX][newY] === 'wall') {
                addMessage(getTranslation("cannotMove"), 'info');
                return;
            }

            // æ•µã¨ã®æˆ¦é—˜ãƒã‚§ãƒƒã‚¯
            const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                combat(currentUnit, enemy);
                return;
            }

            // ç§»å‹•å®Ÿè¡Œ
            currentUnit.x = newX;
            currentUnit.y = newY;

            const directions = {
                '0,-1': 'è¥¿', '-1,0': 'åŒ—', '0,1': 'æ±', '1,0': 'å—'
            };
            addMessage(getTranslation("movedTo", {direction: directions[`${dx},${dy}`]}), 'info');

            // ç©ºè…¹åº¦æ¸›å°‘
            if (gameState.controlledUnit === 'mother') {
                gameState.player.hunger = Math.max(0, gameState.player.hunger - 2);
                gameState.playerMoveCount++;
            }

            // ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢æ¡ä»¶ãƒã‚§ãƒƒã‚¯
            if (newX === GRID_SIZE - 1 && newY === GRID_SIZE - 1) {
                nextStage();
                return;
            }

            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // æˆ¦é—˜å‡¦ç†
        function combat(attacker, defender) {
            const damage = Math.floor(attacker.attack * (0.8 + Math.random() * 0.4));
            defender.health -= damage;

            addMessage(`${damage}ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸï¼`, 'combat');

            if (defender.health <= 0) {
                const index = gameState.enemies.indexOf(defender);
                if (index > -1) {
                    gameState.enemies.splice(index, 1);
                    addMessage(getTranslation("enemyDefeated"), 'combat');
                    
                    // çµŒé¨“å€¤ç²å¾—
                    if (gameState.controlledUnit === 'mother') {
                        gainExp(20 + gameState.stage * 5);
                    }
                }
            } else {
                // æ•µã®åæ’ƒ
                const counterDamage = Math.floor(defender.attack * (0.8 + Math.random() * 0.4));
                attacker.health -= counterDamage;
                addMessage(getTranslation("tookDamage", {damage: counterDamage}), 'combat');

                if (attacker.health <= 0) {
                    if (attacker === gameState.player) {
                        gameOver();
                        return;
                    }
                }
            }

            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // çµŒé¨“å€¤ç²å¾—
        function gainExp(amount) {
            gameState.player.exp += amount;
            
            while (gameState.player.exp >= gameState.player.expToNext) {
                gameState.player.exp -= gameState.player.expToNext;
                gameState.player.level++;
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.attack += 5;
                gameState.player.expToNext = Math.floor(gameState.player.expToNext * 1.2);
                
                addMessage(getTranslation("levelUp", {level: gameState.player.level}), 'level');
                
                // ç¾¤ã‚ŒåŠ å…¥ãƒã‚§ãƒƒã‚¯
                if (gameState.player.level >= 3 && !gameState.pack) {
                    createPack();
                }
            }
        }

        // ç¾¤ã‚Œä½œæˆ
        function createPack() {
            gameState.pack = {
                x: 1, y: 1,
                health: 80, maxHealth: 80
            };
            
            gameState.packMembers = [
                { name: "è‹¥ã„ã‚ªã‚ªã‚«ãƒŸ", health: 60, maxHealth: 60, attack: 15 },
                { name: "çµŒé¨“è±Šå¯Œãªã‚ªã‚ªã‚«ãƒŸ", health: 80, maxHealth: 80, attack: 18 }
            ];

            document.getElementById('packSection').style.display = 'block';
            addMessage(getTranslation("packJoined"), 'pack');
        }

        // æ•µã®ã‚¿ãƒ¼ãƒ³
        function enemyTurn() {
            gameState.enemies.forEach(enemy => {
                // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¾ãŸã¯ç¾¤ã‚Œã«å‘ã‹ã£ã¦ç§»å‹•
                const targets = [gameState.player];
                if (gameState.pack) targets.push(gameState.pack);
                
                let closestTarget = targets[0];
                let minDistance = Math.abs(enemy.x - closestTarget.x) + Math.abs(enemy.y - closestTarget.y);
                
                targets.forEach(target => {
                    const distance = Math.abs(enemy.x - target.x) + Math.abs(enemy.y - target.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTarget = target;
                    }
                });

                // ç§»å‹•æ–¹å‘æ±ºå®š
                let dx = 0, dy = 0;
                if (enemy.x < closestTarget.x) dx = 1;
                else if (enemy.x > closestTarget.x) dx = -1;
                
                if (enemy.y < closestTarget.y) dy = 1;
                else if (enemy.y > closestTarget.y) dy = -1;

                const newX = enemy.x + dx;
                const newY = enemy.y + dy;

                // ç§»å‹•å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
                if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
                    gameState.terrain[newX][newY] !== 'wall') {
                    
                    // ä»–ã®æ•µã¨é‡è¤‡ãƒã‚§ãƒƒã‚¯
                    if (!gameState.enemies.some(other => other !== enemy && other.x === newX && other.y === newY)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
            });
        }

        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ç‹©ã‚Š
        function hunt() {
            if (gameState.controlledUnit !== 'mother') {
                addMessage("ç‹©ã‚Šã¯æ¯ã‚¦ãƒ«ãƒ•ã®ã¿å¯èƒ½ã§ã™ã€‚", 'info');
                return;
            }

            gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 30);
            addMessage(getTranslation("hunted"), 'pack');
            
            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ä¼‘æ¯
        function rest() {
            const currentUnit = gameState.controlledUnit === 'mother' ? gameState.player : gameState.pack;
            if (!currentUnit) return;

            currentUnit.health = Math.min(currentUnit.maxHealth, currentUnit.health + 20);
            addMessage(getTranslation("rested"), 'pack');
            
            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: é å ãˆ
        function howl() {
            if (gameState.controlledUnit !== 'mother') {
                addMessage("é å ãˆã¯æ¯ã‚¦ãƒ«ãƒ•ã®ã¿å¯èƒ½ã§ã™ã€‚", 'info');
                return;
            }

            addMessage(getTranslation("howled"), 'pack');
            
            // è¿‘ãã®æ•µã‚’æ€¯ã¾ã›ã‚‹åŠ¹æœ
            gameState.enemies.forEach(enemy => {
                const distance = Math.abs(enemy.x - gameState.player.x) + Math.abs(enemy.y - gameState.player.y);
                if (distance <= 3) {
                    enemy.health -= 10;
                }
            });

            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³: ç ´å£Š
        function destroyObstacle() {
            const currentUnit = gameState.controlledUnit === 'mother' ? gameState.player : gameState.pack;
            if (!currentUnit) return;

            // éš£æ¥ã™ã‚‹éšœå®³ç‰©ã‚’ç ´å£Š
            const directions = [[-1,0], [1,0], [0,-1], [0,1]];
            let destroyed = false;

            directions.forEach(([dx, dy]) => {
                const x = currentUnit.x + dx;
                const y = currentUnit.y + dy;
                
                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && 
                    gameState.terrain[x][y] === 'wall') {
                    gameState.terrain[x][y] = 'path';
                    destroyed = true;
                }
            });

            if (destroyed) {
                addMessage(getTranslation("obstacleDestroyed"), 'info');
            } else {
                addMessage("ç ´å£Šã§ãã‚‹éšœå®³ç‰©ãŒè¿‘ãã«ã‚ã‚Šã¾ã›ã‚“ã€‚", 'info');
            }
            
            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸
        function nextStage() {
            if (gameState.stage >= MAX_STAGE) {
                addMessage(getTranslation("gameCleared"), 'level');
                return;
            }

            gameState.stage++;
            gameState.player.x = 0;
            gameState.player.y = 0;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.hunger = gameState.player.maxHunger;
            gameState.playerMoveCount = 0;

            addMessage(getTranslation("advancingStage", {stage: gameState.stage}), "level");
            addMessage(getTranslation("hpHungerRestored"), "pack");

            if (gameState.pack) {
                gameState.pack.x = 1;
                gameState.pack.y = 1;
                gameState.packMembers.forEach(member => {
                    member.health = member.maxHealth;
                });
            }

            generateTerrain();
            generateEnemies();
            renderGame();
        }

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        function gameOver() {
            addMessage(getTranslation("gameOver"), 'combat');
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†
        }

        // ã‚²ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆ
        function resetGame() {
            gameState = {
                stage: 1,
                turn: 0,
                controlledUnit: 'mother',
                player: {
                    x: 0, y: 0,
                    health: 100, maxHealth: 100,
                    hunger: 100, maxHunger: 100,
                    level: 1, exp: 0, expToNext: 100,
                    attack: 20, moveRange: 2
                },
                pack: null,
                packMembers: [],
                grid: [],
                enemies: [],
                terrain: [],
                playerMoveCount: 0
            };

            document.getElementById('packSection').style.display = 'none';
            document.getElementById('messages').innerHTML = '';
            
            initializeGrid();
            generateTerrain();
            generateEnemies();
            renderGame();
            
            addMessage("ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸã€‚", 'info');
        }

        // UIæ›´æ–°
        function updateUI() {
            document.getElementById('stageDisplay').textContent = gameState.stage;
            document.getElementById('turnDisplay').textContent = gameState.turn;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            document.getElementById('playerLevel').textContent = gameState.player.level;
            document.getElementById('playerHP').textContent = gameState.player.health;
            document.getElementById('playerMaxHP').textContent = gameState.player.maxHealth;
            document.getElementById('playerHunger').textContent = gameState.player.hunger;
            document.getElementById('playerMaxHunger').textContent = gameState.player.maxHunger;
            document.getElementById('playerExp').textContent = gameState.player.exp;
            document.getElementById('playerExpToNext').textContent = gameState.player.expToNext;
            document.getElementById('playerAttack').textContent = gameState.player.attack;
            document.getElementById('playerMoveRange').textContent = gameState.player.moveRange;

            // HPãƒãƒ¼æ›´æ–°
            const hpPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('playerHPBar').style.width = hpPercent + '%';

            // ç©ºè…¹åº¦ãƒãƒ¼æ›´æ–°
            const hungerPercent = (gameState.player.hunger / gameState.player.maxHunger) * 100;
            document.getElementById('playerHungerBar').style.width = hungerPercent + '%';

            // çµŒé¨“å€¤ãƒãƒ¼æ›´æ–°
            const expPercent = (gameState.player.exp / gameState.player.expToNext) * 100;
            document.getElementById('playerExpBar').style.width = expPercent + '%';

            // ç¾¤ã‚Œã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°
            if (gameState.pack) {
                document.getElementById('packSize').textContent = gameState.packMembers.length;
                
                const packMembersDiv = document.getElementById('packMembers');
                packMembersDiv.innerHTML = '';
                
                gameState.packMembers.forEach(member => {
                    const memberDiv = document.createElement('div');
                    memberDiv.className = 'pack-member';
                    if (member.health < member.maxHealth * 0.5) {
                        memberDiv.classList.add('injured');
                    }
                    memberDiv.innerHTML = `
                        <div>${member.name}</div>
                        <div>HP: ${member.health}/${member.maxHealth}</div>
                    `;
                    packMembersDiv.appendChild(memberDiv);
                });
            }
        }

        // ã‚²ãƒ¼ãƒ æç”»
        function renderGame() {
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';
            
            // ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ†ãƒ¼ãƒã‚’é©ç”¨
            applyStageTheme();
            
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${gameState.terrain[x][y]}`;
                    
                    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤º
                    if (gameState.player.x === x && gameState.player.y === y) {
                        cell.textContent = 'ğŸº';
                        cell.style.backgroundColor = '#4a4a4a';
                    }
                    // ç¾¤ã‚Œè¡¨ç¤º
                    else if (gameState.pack && gameState.pack.x === x && gameState.pack.y === y) {
                        cell.textContent = 'ğŸºğŸº';
                        cell.style.backgroundColor = '#3a3a3a';
                        cell.style.fontSize = '16px';
                    }
                    // æ•µè¡¨ç¤º
                    else if (gameState.enemies.some(enemy => enemy.x === x && enemy.y === y)) {
                        cell.textContent = 'ğŸ‘¹';
                        cell.style.backgroundColor = '#5a2a2a';
                    }
                    // ã‚´ãƒ¼ãƒ«è¡¨ç¤º
                    else if (x === GRID_SIZE - 1 && y === GRID_SIZE - 1) {
                        cell.textContent = 'ğŸ';
                        cell.style.backgroundColor = '#2a5a2a';
                    }
                    // åœ°å½¢è¡¨ç¤º
                    else {
                        switch (gameState.terrain[x][y]) {
                            case 'wall': cell.textContent = 'ğŸ§±'; break;
                            case 'water': cell.textContent = 'ğŸŒŠ'; break;
                            case 'mountain': cell.textContent = 'â›°ï¸'; break;
                            case 'forest': cell.textContent = 'ğŸŒ²'; break;
                            case 'desert': cell.textContent = 'ğŸœï¸'; break;
                        }
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            updateUI();
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    move(-1, 0);
                    break;
                case 'ArrowDown': case 's': case 'S':
                    move(1, 0);
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    move(0, -1);
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    move(0, 1);
                    break;
                case 'h': case 'H':
                    hunt();
                    break;
                case 'r': case 'R':
                    rest();
                    break;
                case '1':
                    switchControlledWolf('mother');
                    break;
                case '2':
                    switchControlledWolf('pack');
                    break;
                case ' ':
                    howl();
                    break;
                case 'x': case 'X':
                    destroyObstacle();
                    break;
            }
        });

        // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
        function initGame() {
            initializeGrid();
            generateTerrain();
            generateEnemies();
            renderGame();
            addMessage("The Hunger Within ã¸ã‚ˆã†ã“ãï¼", 'info');
            addMessage("çŸ¢å°ã‚­ãƒ¼ã¾ãŸã¯WASDã§ç§»å‹•ã€Hã§ç‹©ã‚Šã€Rã§ä¼‘æ¯ã€ã‚¹ãƒšãƒ¼ã‚¹ã§é å ãˆã€Xã§ç ´å£Š", 'info');
        }

        // ã‚²ãƒ¼ãƒ é–‹å§‹
        initGame();
    </script>
</body>
</html>

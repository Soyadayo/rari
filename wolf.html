<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Hunger Within - 2D SRPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #fff;
            padding: 20px;
            overflow-x: auto;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: auto 300px;
            gap: 20px;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(12, 45px);
            grid-template-rows: repeat(12, 45px);
            gap: 2px;
            background: #111;
            padding: 10px;
            border-radius: 10px;
            border: 3px solid #8a2be2;
            width: fit-content;
            box-shadow: inset 0 0 20px rgba(138, 43, 226, 0.3);
            margin-bottom: 20px;
            transition: border-color 0.5s, background-color 0.5s, box-shadow 0.5s;
        }

        .cell {
            width: 45px;
            height: 45px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            background: #222;
            border-radius: 3px;
            transition: all 0.2s;
            position: relative;
        }

        .cell.path { background: #444; }
        .cell.wall { background: #111; border-color: #555; }
        .cell.water { background: #1e3a5f; }
        .cell.mountain { background: #5a5a5a; }
        .cell.forest { background: #2d5016; }
        .cell.desert { background: #8B4513; }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
            max-width: 600px;
        }

        .control-selection {
            grid-column: 1 / -1;
            margin-bottom: 15px;
            text-align: center;
        }

        .control-btn {
            padding: 15px 10px;
            background: #2a2a2a;
            border: 2px solid #555;
            color: #fff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s;
            min-height: 50px;
        }

        .control-btn:hover {
            background: #3a3a3a;
            border-color: #777;
        }

        .control-btn.active {
            background: #4a4a4a;
            border-color: #888;
        }

        .control-btn.compact {
            padding: 12px 8px;
            font-size: 18px;
            min-width: auto;
        }

        .control-btn.action-btn {
            background: #3a2a2a;
            border-color: #8a2be2;
        }

        .control-btn.action-btn:hover {
            background: #4a3a3a;
            border-color: #9a3bf2;
        }

        .sidebar {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #333;
        }

        .stat-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #222;
            border-radius: 8px;
            border: 1px solid #444;
        }

        .stat-section h3 {
            color: #8a2be2;
            margin-bottom: 10px;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }

        .stat-bar {
            background: #333;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin: 5px 0;
            border: 1px solid #555;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.3s;
        }

        .health-fill { background: linear-gradient(90deg, #ff4444, #ff6666); }
        .hunger-fill { background: linear-gradient(90deg, #ff8800, #ffaa00); }
        .exp-fill { background: linear-gradient(90deg, #4488ff, #66aaff); }

        .messages {
            max-height: 300px;
            overflow-y: auto;
            background: #111;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #333;
        }

        .message {
            margin: 2px 0;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .message.combat { color: #ff6666; }
        .message.level { color: #66ff66; }
        .message.pack { color: #ffaa00; }
        .message.info { color: #66aaff; }

        .title {
            text-align: center;
            margin-bottom: 20px;
            color: #8a2be2;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        .stage-info {
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            color: #fff;
        }

        .pack-member {
            background: #2a2a2a;
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #444;
        }

        .pack-member.injured {
            border-color: #ff4444;
            background: #3a2a2a;
        }

        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .controls {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <h1 class="title">The Hunger Within</h1>
            <div class="stage-info">
                <span>„Çπ„ÉÜ„Éº„Ç∏: <span id="stageDisplay">1</span></span>
                <span style="margin-left: 20px;">„Çø„Éº„É≥: <span id="turnDisplay">0</span></span>
            </div>
            <div id="gameGrid" class="game-grid"></div>
            
            <div class="controls">
                <div class="control-selection">
                    <span id="controlledWolfLabel">ÁèæÂú®Êìç‰Ωú‰∏≠:</span> 
                    <span id="controlledWolfDisplay">ÊØç„Ç¶„É´„Éï</span>
                    <br><br>
                    <button id="controlMotherBtn" class="control-btn active" onclick="switchControlledWolf('mother')">ÊØç„Ç¶„É´„Éï„ÇíÊìç‰Ωú</button>
                    <button id="controlPackBtn" class="control-btn" onclick="switchControlledWolf('pack')">Áæ§„Çå„ÇíÊìç‰Ωú</button>
                </div>
                
                <button class="control-btn" onclick="move(0, -1)" id="moveWestBtn">‚¨ÖÔ∏è Ë•ø</button>
                <button class="control-btn" onclick="move(-1, 0)" id="moveNorthBtn">‚¨ÜÔ∏è Âåó</button>
                <button class="control-btn" onclick="move(0, 1)" id="moveEastBtn">‚û°Ô∏è Êù±</button>
                
                <button class="control-btn" onclick="move(1, 0)" id="moveSouthBtn">‚¨áÔ∏è Âçó</button>
                <button class="control-btn action-btn compact" onclick="howl()" id="howlBtn" title="ÈÅ†Âê†„Åà">üåô</button>
                <button class="control-btn action-btn compact" onclick="destroyObstacle()" id="destroyBtn" title="Á†¥Â£ä">üí•</button>
                
                <button class="control-btn action-btn" onclick="rest()" id="restBtn">üò¥ ‰ºëÊÅØ</button>
                <button class="control-btn action-btn" onclick="hunt()" id="huntBtn">ü¶å Áã©„Çä</button>
                <button class="control-btn action-btn" onclick="resetGame()" id="resetBtn">üîÑ „É™„Çª„ÉÉ„Éà</button>
            </div>
        </div>

        <div class="sidebar">
            <div class="stat-section">
                <h3>ÊØç„Ç¶„É´„Éï „Çπ„ÉÜ„Éº„Çø„Çπ</h3>
                <div>„É¨„Éô„É´: <span id="playerLevel">1</span></div>
                <div>
                    HP: <span id="playerHP">100</span>/<span id="playerMaxHP">100</span>
                    <div class="stat-bar">
                        <div class="stat-fill health-fill" id="playerHPBar"></div>
                    </div>
                </div>
                <div>
                    Á©∫ËÖπÂ∫¶: <span id="playerHunger">100</span>/<span id="playerMaxHunger">100</span>
                    <div class="stat-bar">
                        <div class="stat-fill hunger-fill" id="playerHungerBar"></div>
                    </div>
                </div>
                <div>
                    ÁµåÈ®ìÂÄ§: <span id="playerExp">0</span>/<span id="playerExpToNext">100</span>
                    <div class="stat-bar">
                        <div class="stat-fill exp-fill" id="playerExpBar"></div>
                    </div>
                </div>
                <div>ÊîªÊíÉÂäõ: <span id="playerAttack">20</span></div>
                <div>ÁßªÂãïÁØÑÂõ≤: <span id="playerMoveRange">2</span></div>
            </div>

            <div class="stat-section" id="packSection" style="display: none;">
                <h3>Áæ§„Çå„ÅÆÁä∂ÊÖã</h3>
                <div>Áæ§„Çå„Çµ„Ç§„Ç∫: <span id="packSize">0</span></div>
                <div id="packMembers"></div>
            </div>

            <div class="stat-section">
                <h3>„É°„ÉÉ„Çª„Éº„Ç∏„É≠„Ç∞</h3>
                <div id="messages" class="messages"></div>
            </div>
        </div>
    </div>

    <script>
        // „Ç≤„Éº„É†Áä∂ÊÖã„ÅÆÂàùÊúüÂåñ
        const GRID_SIZE = 12;
        const MAX_STAGE = 50;

        // „Çπ„ÉÜ„Éº„Ç∏„ÉÜ„Éº„Éû„ÅÆÂÆöÁæ©
        const STAGE_THEMES = {
            1: { // „Çπ„ÉÜ„Éº„Ç∏ 1-10: Ê£ÆÊûó„ÉÜ„Éº„Éû
                borderColor: '#2d5016',
                backgroundColor: '#1a3a1a',
                shadowColor: 'rgba(45, 80, 22, 0.3)'
            },
            11: { // „Çπ„ÉÜ„Éº„Ç∏ 11-20: Â±±Â≤≥„ÉÜ„Éº„Éû
                borderColor: '#4a4a4a',
                backgroundColor: '#2a2a2a',
                shadowColor: 'rgba(74, 74, 74, 0.3)'
            },
            21: { // „Çπ„ÉÜ„Éº„Ç∏ 21-30: Ê∞¥Ëæ∫„ÉÜ„Éº„Éû
                borderColor: '#1e3a5f',
                backgroundColor: '#0f1f3f',
                shadowColor: 'rgba(30, 58, 95, 0.3)'
            },
            31: { // „Çπ„ÉÜ„Éº„Ç∏ 31-40: Á†ÇÊº†„ÉÜ„Éº„Éû
                borderColor: '#8B4513',
                backgroundColor: '#4A2511',
                shadowColor: 'rgba(139, 69, 19, 0.3)'
            },
            41: { // „Çπ„ÉÜ„Éº„Ç∏ 41-50: È≠îÁïå„ÉÜ„Éº„Éû
                borderColor: '#8a2be2',
                backgroundColor: '#4a1a5a',
                shadowColor: 'rgba(138, 43, 226, 0.3)'
            }
        };

        let gameState = {
            stage: 1,
            turn: 0,
            controlledUnit: 'mother', // 'mother' „Åæ„Åü„ÅØ 'pack'
            player: {
                x: 0, y: 0,
                health: 100, maxHealth: 100,
                hunger: 100, maxHunger: 100,
                level: 1, exp: 0, expToNext: 100,
                attack: 20, moveRange: 2
            },
            pack: null,
            packMembers: [],
            grid: [],
            enemies: [],
            terrain: [],
            playerMoveCount: 0
        };

        // „Çπ„ÉÜ„Éº„Ç∏„ÉÜ„Éº„Éû„ÇíÈÅ©Áî®„Åô„ÇãÈñ¢Êï∞
        function applyStageTheme() {
            const currentStage = gameState.stage;
            let theme = STAGE_THEMES[1]; // „Éá„Éï„Ç©„É´„Éà„ÉÜ„Éº„Éû
            
            // ÁèæÂú®„ÅÆ„Çπ„ÉÜ„Éº„Ç∏„Å´ÈÅ©„Åó„Åü„ÉÜ„Éº„Éû„ÇíÈÅ∏Êäû
            const themeKeys = Object.keys(STAGE_THEMES).map(Number).sort((a, b) => a - b);
            for (let i = themeKeys.length - 1; i >= 0; i--) {
                if (currentStage >= themeKeys[i]) {
                    theme = STAGE_THEMES[themeKeys[i]];
                    break;
                }
            }
            
            // CSS„ÇíÂãïÁöÑ„Å´ÈÅ©Áî®
            const gameGrid = document.getElementById('gameGrid');
            gameGrid.style.borderColor = theme.borderColor;
            gameGrid.style.backgroundColor = theme.backgroundColor;
            gameGrid.style.boxShadow = `inset 0 0 20px ${theme.shadowColor}`;
        }

        // ÁøªË®≥„Ç∑„Çπ„ÉÜ„É†
        const translations = {
            advancingStage: "„Çπ„ÉÜ„Éº„Ç∏ {stage} „Å´ÈÄ≤„Åø„Åæ„ÅôÔºÅ",
            hpHungerRestored: "HP„Å®Á©∫ËÖπÂ∫¶„ÅåÂõûÂæ©„Åó„Åæ„Åó„Åü„ÄÇ",
            movedTo: "{direction}„Å´ÁßªÂãï„Åó„Åæ„Åó„Åü„ÄÇ",
            cannotMove: "„Åù„Åì„Å´„ÅØÁßªÂãï„Åß„Åç„Åæ„Åõ„Çì„ÄÇ",
            enemyDefeated: "Êïµ„ÇíÂÄí„Åó„Åæ„Åó„ÅüÔºÅ",
            tookDamage: "{damage}„ÅÆ„ÉÄ„É°„Éº„Ç∏„ÇíÂèó„Åë„Åæ„Åó„Åü„ÄÇ",
            levelUp: "„É¨„Éô„É´„Ç¢„ÉÉ„ÉóÔºÅ„É¨„Éô„É´{level}„Å´„Å™„Çä„Åæ„Åó„Åü„ÄÇ",
            packJoined: "Êñ∞„Åó„ÅÑ‰ª≤Èñì„ÅåÁæ§„Çå„Å´Âä†„Çè„Çä„Åæ„Åó„ÅüÔºÅ",
            hunted: "Áã©„Çä„ÇíË°å„ÅÑ„Åæ„Åó„Åü„ÄÇÁ©∫ËÖπÂ∫¶„ÅåÂõûÂæ©„Åó„Åæ„Åó„Åü„ÄÇ",
            rested: "‰ºëÊÅØ„Åó„Åæ„Åó„Åü„ÄÇHP„ÅåÂõûÂæ©„Åó„Åæ„Åó„Åü„ÄÇ",
            howled: "ÈÅ†Âê†„Åà„Åó„Åæ„Åó„Åü„ÄÇËøë„Åè„ÅÆ‰ª≤Èñì„ÇíÂëº„Å≥ÂØÑ„Åõ„Åæ„Åó„Åü„ÄÇ",
            obstacleDestroyed: "ÈöúÂÆ≥Áâ©„ÇíÁ†¥Â£ä„Åó„Åæ„Åó„Åü„ÄÇ",
            gameOver: "„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº",
            gameCleared: "ÂÖ®„Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢ÔºÅ„Åä„ÇÅ„Åß„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅ"
        };

        function getTranslation(key, params = {}) {
            let text = translations[key] || key;
            Object.keys(params).forEach(param => {
                text = text.replace(`{${param}}`, params[param]);
            });
            return text;
        }

        // „É°„ÉÉ„Çª„Éº„Ç∏Ë°®Á§∫
        function addMessage(text, type = 'info') {
            const messages = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight;

            // „É°„ÉÉ„Çª„Éº„Ç∏Êï∞Âà∂Èôê
            while (messages.children.length > 50) {
                messages.removeChild(messages.firstChild);
            }
        }

        // „Ç∞„É™„ÉÉ„ÉâÂàùÊúüÂåñ
        function initializeGrid() {
            gameState.grid = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(0));
        }

        // Âú∞ÂΩ¢ÁîüÊàê
        function generateTerrain() {
            gameState.terrain = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill('path'));
            
            // „Çπ„ÉÜ„Éº„Ç∏„Å´Âøú„Åò„ÅüÂú∞ÂΩ¢ÁîüÊàê
            const stageType = Math.floor((gameState.stage - 1) / 10);
            
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const rand = Math.random();
                    
                    switch (stageType) {
                        case 0: // Ê£ÆÊûó (1-10)
                            if (rand < 0.15) gameState.terrain[x][y] = 'forest';
                            else if (rand < 0.25) gameState.terrain[x][y] = 'wall';
                            break;
                        case 1: // Â±±Â≤≥ (11-20)
                            if (rand < 0.2) gameState.terrain[x][y] = 'mountain';
                            else if (rand < 0.3) gameState.terrain[x][y] = 'wall';
                            break;
                        case 2: // Ê∞¥Ëæ∫ (21-30)
                            if (rand < 0.15) gameState.terrain[x][y] = 'water';
                            else if (rand < 0.25) gameState.terrain[x][y] = 'wall';
                            break;
                        case 3: // Á†ÇÊº† (31-40)
                            if (rand < 0.1) gameState.terrain[x][y] = 'desert';
                            else if (rand < 0.2) gameState.terrain[x][y] = 'wall';
                            break;
                        default: // È≠îÁïå (41-50)
                            if (rand < 0.3) gameState.terrain[x][y] = 'wall';
                            break;
                    }
                }
            }
            
            // „Éó„É¨„Ç§„É§„ÉºÈñãÂßã‰ΩçÁΩÆ„Çí„ÇØ„É™„Ç¢
            gameState.terrain[0][0] = 'path';
            if (gameState.pack) {
                gameState.terrain[1][1] = 'path';
            }
        }

        // ÊïµÁîüÊàê
        function generateEnemies() {
            gameState.enemies = [];
            const enemyCount = Math.min(3 + Math.floor(gameState.stage / 5), 8);
            
            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                } while (
                    (x === gameState.player.x && y === gameState.player.y) ||
                    (gameState.pack && x === gameState.pack.x && y === gameState.pack.y) ||
                    gameState.terrain[x][y] === 'wall' ||
                    gameState.enemies.some(enemy => enemy.x === x && enemy.y === y)
                );

                gameState.enemies.push({
                    x, y,
                    health: 30 + gameState.stage * 5,
                    maxHealth: 30 + gameState.stage * 5,
                    attack: 10 + gameState.stage * 2,
                    moveRange: 1
                });
            }
        }

        // Êìç‰Ωú„É¶„Éã„ÉÉ„ÉàÂàá„ÇäÊõø„Åà
        function switchControlledWolf(unit) {
            gameState.controlledUnit = unit;
            
            document.getElementById('controlMotherBtn').classList.toggle('active', unit === 'mother');
            document.getElementById('controlPackBtn').classList.toggle('active', unit === 'pack');
            
            const display = document.getElementById('controlledWolfDisplay');
            display.textContent = unit === 'mother' ? 'ÊØç„Ç¶„É´„Éï' : 'Áæ§„Çå';
            
            addMessage(`${unit === 'mother' ? 'ÊØç„Ç¶„É´„Éï' : 'Áæ§„Çå'}„ÇíÊìç‰Ωú„Åó„Åæ„Åô„ÄÇ`, 'info');
        }

        // ÁßªÂãïÂá¶ÁêÜ
        function move(dx, dy) {
            const currentUnit = gameState.controlledUnit === 'mother' ? gameState.player : gameState.pack;
            
            if (!currentUnit) {
                addMessage("Êìç‰ΩúÂèØËÉΩ„Å™„É¶„Éã„ÉÉ„Éà„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ", 'info');
                return;
            }

            const newX = currentUnit.x + dx;
            const newY = currentUnit.y + dy;

            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                addMessage(getTranslation("cannotMove"), 'info');
                return;
            }

            if (gameState.terrain[newX][newY] === 'wall') {
                addMessage(getTranslation("cannotMove"), 'info');
                return;
            }

            // Êïµ„Å®„ÅÆÊà¶Èóò„ÉÅ„Çß„ÉÉ„ÇØ
            const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                combat(currentUnit, enemy);
                return;
            }

            // ÁßªÂãïÂÆüË°å
            currentUnit.x = newX;
            currentUnit.y = newY;

            const directions = {
                '0,-1': 'Ë•ø', '-1,0': 'Âåó', '0,1': 'Êù±', '1,0': 'Âçó'
            };
            addMessage(getTranslation("movedTo", {direction: directions[`${dx},${dy}`]}), 'info');

            // Á©∫ËÖπÂ∫¶Ê∏õÂ∞ë
            if (gameState.controlledUnit === 'mother') {
                gameState.player.hunger = Math.max(0, gameState.player.hunger - 2);
                gameState.playerMoveCount++;
            }

            // „Çπ„ÉÜ„Éº„Ç∏„ÇØ„É™„Ç¢Êù°‰ª∂„ÉÅ„Çß„ÉÉ„ÇØ
            if (newX === GRID_SIZE - 1 && newY === GRID_SIZE - 1) {
                nextStage();
                return;
            }

            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // Êà¶ÈóòÂá¶ÁêÜ
        function combat(attacker, defender) {
            const damage = Math.floor(attacker.attack * (0.8 + Math.random() * 0.4));
            defender.health -= damage;

            addMessage(`${damage}„ÅÆ„ÉÄ„É°„Éº„Ç∏„Çí‰∏é„Åà„Åæ„Åó„ÅüÔºÅ`, 'combat');

            if (defender.health <= 0) {
                const index = gameState.enemies.indexOf(defender);
                if (index > -1) {
                    gameState.enemies.splice(index, 1);
                    addMessage(getTranslation("enemyDefeated"), 'combat');
                    
                    // ÁµåÈ®ìÂÄ§Áç≤Âæó
                    if (gameState.controlledUnit === 'mother') {
                        gainExp(20 + gameState.stage * 5);
                    }
                }
            } else {
                // Êïµ„ÅÆÂèçÊíÉ
                const counterDamage = Math.floor(defender.attack * (0.8 + Math.random() * 0.4));
                attacker.health -= counterDamage;
                addMessage(getTranslation("tookDamage", {damage: counterDamage}), 'combat');

                if (attacker.health <= 0) {
                    if (attacker === gameState.player) {
                        gameOver();
                        return;
                    }
                }
            }

            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // ÁµåÈ®ìÂÄ§Áç≤Âæó
        function gainExp(amount) {
            gameState.player.exp += amount;
            
            while (gameState.player.exp >= gameState.player.expToNext) {
                gameState.player.exp -= gameState.player.expToNext;
                gameState.player.level++;
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.attack += 5;
                gameState.player.expToNext = Math.floor(gameState.player.expToNext * 1.2);
                
                addMessage(getTranslation("levelUp", {level: gameState.player.level}), 'level');
                
                // Áæ§„ÇåÂä†ÂÖ•„ÉÅ„Çß„ÉÉ„ÇØ
                if (gameState.player.level >= 3 && !gameState.pack) {
                    createPack();
                }
            }
        }

        // Áæ§„Çå‰ΩúÊàê
        function createPack() {
            gameState.pack = {
                x: 1, y: 1,
                health: 80, maxHealth: 80
            };
            
            gameState.packMembers = [
                { name: "Ëã•„ÅÑ„Ç™„Ç™„Ç´„Éü", health: 60, maxHealth: 60, attack: 15 },
                { name: "ÁµåÈ®ìË±äÂØå„Å™„Ç™„Ç™„Ç´„Éü", health: 80, maxHealth: 80, attack: 18 }
            ];

            document.getElementById('packSection').style.display = 'block';
            addMessage(getTranslation("packJoined"), 'pack');
        }

        // Êïµ„ÅÆ„Çø„Éº„É≥
        function enemyTurn() {
            gameState.enemies.forEach(enemy => {
                // „Éó„É¨„Ç§„É§„Éº„Åæ„Åü„ÅØÁæ§„Çå„Å´Âêë„Åã„Å£„Å¶ÁßªÂãï
                const targets = [gameState.player];
                if (gameState.pack) targets.push(gameState.pack);
                
                let closestTarget = targets[0];
                let minDistance = Math.abs(enemy.x - closestTarget.x) + Math.abs(enemy.y - closestTarget.y);
                
                targets.forEach(target => {
                    const distance = Math.abs(enemy.x - target.x) + Math.abs(enemy.y - target.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestTarget = target;
                    }
                });

                // ÁßªÂãïÊñπÂêëÊ±∫ÂÆö
                let dx = 0, dy = 0;
                if (enemy.x < closestTarget.x) dx = 1;
                else if (enemy.x > closestTarget.x) dx = -1;
                
                if (enemy.y < closestTarget.y) dy = 1;
                else if (enemy.y > closestTarget.y) dy = -1;

                const newX = enemy.x + dx;
                const newY = enemy.y + dy;

                // ÁßªÂãïÂèØËÉΩ„Åã„ÉÅ„Çß„ÉÉ„ÇØ
                if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE && 
                    gameState.terrain[newX][newY] !== 'wall') {
                    
                    // ‰ªñ„ÅÆÊïµ„Å®ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                    if (!gameState.enemies.some(other => other !== enemy && other.x === newX && other.y === newY)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                }
            });
        }

        // „Ç¢„ÇØ„Ç∑„Éß„É≥: Áã©„Çä
        function hunt() {
            if (gameState.controlledUnit !== 'mother') {
                addMessage("Áã©„Çä„ÅØÊØç„Ç¶„É´„Éï„ÅÆ„ÅøÂèØËÉΩ„Åß„Åô„ÄÇ", 'info');
                return;
            }

            gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 30);
            addMessage(getTranslation("hunted"), 'pack');
            
            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // „Ç¢„ÇØ„Ç∑„Éß„É≥: ‰ºëÊÅØ
        function rest() {
            const currentUnit = gameState.controlledUnit === 'mother' ? gameState.player : gameState.pack;
            if (!currentUnit) return;

            currentUnit.health = Math.min(currentUnit.maxHealth, currentUnit.health + 20);
            addMessage(getTranslation("rested"), 'pack');
            
            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // „Ç¢„ÇØ„Ç∑„Éß„É≥: ÈÅ†Âê†„Åà
        function howl() {
            if (gameState.controlledUnit !== 'mother') {
                addMessage("ÈÅ†Âê†„Åà„ÅØÊØç„Ç¶„É´„Éï„ÅÆ„ÅøÂèØËÉΩ„Åß„Åô„ÄÇ", 'info');
                return;
            }

            addMessage(getTranslation("howled"), 'pack');
            
            // Ëøë„Åè„ÅÆÊïµ„ÇíÊÄØ„Åæ„Åõ„ÇãÂäπÊûú
            gameState.enemies.forEach(enemy => {
                const distance = Math.abs(enemy.x - gameState.player.x) + Math.abs(enemy.y - gameState.player.y);
                if (distance <= 3) {
                    enemy.health -= 10;
                }
            });

            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // „Ç¢„ÇØ„Ç∑„Éß„É≥: Á†¥Â£ä
        function destroyObstacle() {
            const currentUnit = gameState.controlledUnit === 'mother' ? gameState.player : gameState.pack;
            if (!currentUnit) return;

            // Èö£Êé•„Åô„ÇãÈöúÂÆ≥Áâ©„ÇíÁ†¥Â£ä
            const directions = [[-1,0], [1,0], [0,-1], [0,1]];
            let destroyed = false;

            directions.forEach(([dx, dy]) => {
                const x = currentUnit.x + dx;
                const y = currentUnit.y + dy;
                
                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && 
                    gameState.terrain[x][y] === 'wall') {
                    gameState.terrain[x][y] = 'path';
                    destroyed = true;
                }
            });

            if (destroyed) {
                addMessage(getTranslation("obstacleDestroyed"), 'info');
            } else {
                addMessage("Á†¥Â£ä„Åß„Åç„ÇãÈöúÂÆ≥Áâ©„ÅåËøë„Åè„Å´„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ", 'info');
            }
            
            gameState.turn++;
            enemyTurn();
            renderGame();
        }

        // Ê¨°„ÅÆ„Çπ„ÉÜ„Éº„Ç∏
        function nextStage() {
            if (gameState.stage >= MAX_STAGE) {
                addMessage(getTranslation("gameCleared"), 'level');
                return;
            }

            gameState.stage++;
            gameState.player.x = 0;
            gameState.player.y = 0;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.hunger = gameState.player.maxHunger;
            gameState.playerMoveCount = 0;

            addMessage(getTranslation("advancingStage", {stage: gameState.stage}), "level");
            addMessage(getTranslation("hpHungerRestored"), "pack");

            if (gameState.pack) {
                gameState.pack.x = 1;
                gameState.pack.y = 1;
                gameState.packMembers.forEach(member => {
                    member.health = member.maxHealth;
                });
            }

            generateTerrain();
            generateEnemies();
            renderGame();
        }

        // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº
        function gameOver() {
            addMessage(getTranslation("gameOver"), 'combat');
            // „Ç≤„Éº„É†„Ç™„Éº„Éê„ÉºÂá¶ÁêÜ
        }

        // „Ç≤„Éº„É†„É™„Çª„ÉÉ„Éà
        function resetGame() {
            gameState = {
                stage: 1,
                turn: 0,
                controlledUnit: 'mother',
                player: {
                    x: 0, y: 0,
                    health: 100, maxHealth: 100,
                    hunger: 100, maxHunger: 100,
                    level: 1, exp: 0, expToNext: 100,
                    attack: 20, moveRange: 2
                },
                pack: null,
                packMembers: [],
                grid: [],
                enemies: [],
                terrain: [],
                playerMoveCount: 0
            };

            document.getElementById('packSection').style.display = 'none';
            document.getElementById('messages').innerHTML = '';
            
            initializeGrid();
            generateTerrain();
            generateEnemies();
            renderGame();
            
            addMessage("„Ç≤„Éº„É†„Çí„É™„Çª„ÉÉ„Éà„Åó„Åæ„Åó„Åü„ÄÇ", 'info');
        }

        // UIÊõ¥Êñ∞
        function updateUI() {
            document.getElementById('stageDisplay').textContent = gameState.stage;
            document.getElementById('turnDisplay').textContent = gameState.turn;
            
            // „Éó„É¨„Ç§„É§„Éº„Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞
            document.getElementById('playerLevel').textContent = gameState.player.level;
            document.getElementById('playerHP').textContent = gameState.player.health;
            document.getElementById('playerMaxHP').textContent = gameState.player.maxHealth;
            document.getElementById('playerHunger').textContent = gameState.player.hunger;
            document.getElementById('playerMaxHunger').textContent = gameState.player.maxHunger;
            document.getElementById('playerExp').textContent = gameState.player.exp;
            document.getElementById('playerExpToNext').textContent = gameState.player.expToNext;
            document.getElementById('playerAttack').textContent = gameState.player.attack;
            document.getElementById('playerMoveRange').textContent = gameState.player.moveRange;

            // HP„Éê„ÉºÊõ¥Êñ∞
            const hpPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            document.getElementById('playerHPBar').style.width = hpPercent + '%';

            // Á©∫ËÖπÂ∫¶„Éê„ÉºÊõ¥Êñ∞
            const hungerPercent = (gameState.player.hunger / gameState.player.maxHunger) * 100;
            document.getElementById('playerHungerBar').style.width = hungerPercent + '%';

            // ÁµåÈ®ìÂÄ§„Éê„ÉºÊõ¥Êñ∞
            const expPercent = (gameState.player.exp / gameState.player.expToNext) * 100;
            document.getElementById('playerExpBar').style.width = expPercent + '%';

            // Áæ§„Çå„Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞
            if (gameState.pack) {
                document.getElementById('packSize').textContent = gameState.packMembers.length;
                
                const packMembersDiv = document.getElementById('packMembers');
                packMembersDiv.innerHTML = '';
                
                gameState.packMembers.forEach(member => {
                    const memberDiv = document.createElement('div');
                    memberDiv.className = 'pack-member';
                    if (member.health < member.maxHealth * 0.5) {
                        memberDiv.classList.add('injured');
                    }
                    memberDiv.innerHTML = `
                        <div>${member.name}</div>
                        <div>HP: ${member.health}/${member.maxHealth}</div>
                    `;
                    packMembersDiv.appendChild(memberDiv);
                });
            }
        }

        // „Ç≤„Éº„É†ÊèèÁîª
        function renderGame() {
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';
            
            // „Çπ„ÉÜ„Éº„Ç∏„ÉÜ„Éº„Éû„ÇíÈÅ©Áî®
            applyStageTheme();
            
            for (let x = 0; x < GRID_SIZE; x++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    const cell = document.createElement('div');
                    cell.className = `cell ${gameState.terrain[x][y]}`;
                    
                    // „Éó„É¨„Ç§„É§„ÉºË°®Á§∫
                    if (gameState.player.x === x && gameState.player.y === y) {
                        cell.textContent = 'üê∫';
                        cell.style.backgroundColor = '#4a4a4a';
                    }
                    // Áæ§„ÇåË°®Á§∫
                    else if (gameState.pack && gameState.pack.x === x && gameState.pack.y === y) {
                        cell.textContent = 'üê∫üê∫';
                        cell.style.backgroundColor = '#3a3a3a';
                        cell.style.fontSize = '16px';
                    }
                    // ÊïµË°®Á§∫
                    else if (gameState.enemies.some(enemy => enemy.x === x && enemy.y === y)) {
                        cell.textContent = 'üëπ';
                        cell.style.backgroundColor = '#5a2a2a';
                    }
                    // „Ç¥„Éº„É´Ë°®Á§∫
                    else if (x === GRID_SIZE - 1 && y === GRID_SIZE - 1) {
                        cell.textContent = 'üèÅ';
                        cell.style.backgroundColor = '#2a5a2a';
                    }
                    // Âú∞ÂΩ¢Ë°®Á§∫
                    else {
                        switch (gameState.terrain[x][y]) {
                            case 'wall': cell.textContent = 'üß±'; break;
                            case 'water': cell.textContent = 'üåä'; break;
                            case 'mountain': cell.textContent = '‚õ∞Ô∏è'; break;
                            case 'forest': cell.textContent = 'üå≤'; break;
                            case 'desert': cell.textContent = 'üèúÔ∏è'; break;
                        }
                    }
                    
                    grid.appendChild(cell);
                }
            }
            
            updateUI();
        }

        // „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú
        document.addEventListener('keydown', (e) => {
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    move(-1, 0);
                    break;
                case 'ArrowDown': case 's': case 'S':
                    move(1, 0);
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    move(0, -1);
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    move(0, 1);
                    break;
                case 'h': case 'H':
                    hunt();
                    break;
                case 'r': case 'R':
                    rest();
                    break;
                case '1':
                    switchControlledWolf('mother');
                    break;
                case '2':
                    switchControlledWolf('pack');
                    break;
                case ' ':
                    howl();
                    break;
                case 'x': case 'X':
                    destroyObstacle();
                    break;
            }
        });

        // „Ç≤„Éº„É†ÂàùÊúüÂåñ
        function initGame() {
            initializeGrid();
            generateTerrain();
            generateEnemies();
            renderGame();
            addMessage("The Hunger Within „Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ", 'info');
            addMessage("Áü¢Âç∞„Ç≠„Éº„Åæ„Åü„ÅØWASD„ÅßÁßªÂãï„ÄÅH„ÅßÁã©„Çä„ÄÅR„Åß‰ºëÊÅØ„ÄÅ„Çπ„Éö„Éº„Çπ„ÅßÈÅ†Âê†„Åà„ÄÅX„ÅßÁ†¥Â£ä", 'info');
        }

        // „Ç≤„Éº„É†ÈñãÂßã
        initGame();
    </script>
</body>
</html>

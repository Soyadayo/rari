<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Pack Evolution RPG</title>
    <style>
        /* General styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27, #1a1a2e, #16213e);
            min-height: 100vh;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.4);
            max-width: 1300px;
            width: 100%;
            /* マップの外枠と形状を合わせるために追加 */
            overflow: hidden;
        }

        h1 {
            text-align: center;
            color: #8a2be2;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(138, 43, 226, 0.7);
        }

        .game-area {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .game-info {
            flex: 1;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(138, 43, 226, 0.3);
        }

        .game-info h2 {
            color: #8a2be2;
            margin-bottom: 15px;
            font-size: 1.8em;
            border-bottom: 2px solid rgba(138, 43, 226, 0.5);
            padding-bottom: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .stat-item {
            background: rgba(138, 43, 226, 0.1);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9em;
        }

        .stat-item strong {
            color: #a27ae6;
        }

        .controls-section h3, .pack-info h3 {
            color: #8a2be2;
            margin-bottom: 10px;
            font-size: 1.4em;
        }

        .controls-section ul {
            list-style: none;
        }

        .controls-section li {
            margin-bottom: 8px;
            background: rgba(138, 43, 226, 0.05);
            padding: 5px 10px;
            border-radius: 3px;
        }

        .pack-member {
            margin-bottom: 10px;
            padding: 8px;
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 5px;
            background: rgba(138, 43, 226, 0.1);
        }

        .pack-member strong {
            color: #c7a7ed;
        }

        .game-grid-container {
            flex: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #gameGrid {
            display: grid;
            /* JavaScriptでgrid-template-columnsとrowsが設定されます */
            border: 2px solid #8a2be2;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.7);
            transition: border-color 0.5s ease-in-out, box-shadow 0.5s ease-in-out;
            /* マップの外枠と形状を合わせるために追加 */
            border-radius: 10px;
            overflow: hidden; /* 子要素がはみ出さないように */
        }

        /* 10ステージごとのマップテーマ */
        #gameGrid.theme-forest {
            border-color: #228B22; /* Forest green */
            box-shadow: 0 0 20px rgba(34, 139, 34, 0.7);
        }

        #gameGrid.theme-desert {
            border-color: #DAA520; /* Goldenrod */
            box-shadow: 0 0 20px rgba(218, 165, 32, 0.7);
        }

        #gameGrid.theme-snow {
            border-color: #B0E0E6; /* Powder blue */
            box-shadow: 0 0 20px rgba(176, 224, 230, 0.7);
        }

        #gameGrid.theme-volcano {
            border-color: #FF4500; /* Orange red */
            box-shadow: 0 0 20px rgba(255, 69, 0, 0.7);
        }

        #gameGrid.theme-swamp {
            border-color: #556B2F; /* Dark olive green */
            box-shadow: 0 0 20px rgba(85, 107, 47, 0.7);
        }


        .grid-cell {
            width: 30px; /* Adjust cell size as needed */
            height: 30px; /* Adjust cell size as needed */
            background-color: rgba(25, 25, 112, 0.6); /* Midnight blue */
            border: 0.5px solid rgba(138, 43, 226, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2em;
            color: #fff;
            transition: background-color 0.3s ease;
        }

        /* Entities */
        .player-wolf { background-color: #ADD8E6; } /* Light blue */
        .mother-wolf { background-color: #FFD700; } /* Gold */
        .pack-wolf { background-color: #90EE90; } /* Light green */
        .prey { background-color: #964B00; } /* Brown */
        .obstacle { background-color: #808080; } /* Gray */
        .den { background-color: #8B4513; } /* Saddle brown */
        .water { background-color: #4682B4; } /* Steel blue */
        .item { background-color: #FFA500; } /* Orange */
        .enemy { background-color: #DC143C; } /* Crimson */
        .path { background-color: rgba(25, 25, 112, 0.8); } /* Slightly darker path */

        /* Player indicator for controlled wolf */
        .controlled-wolf {
            border: 2px solid white;
            box-shadow: 0 0 5px white;
        }

        /* UI elements */
        .status-bar {
            width: 100%;
            height: 20px;
            background-color: #333;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
            border: 1px solid #555;
        }

        .status-bar-fill {
            height: 100%;
            width: 0%;
            border-radius: 10px;
            transition: width 0.3s ease-out;
        }

        .health-fill { background-color: #FF6347; } /* Tomato */
        .hunger-fill { background-color: #DAA520; } /* Goldenrod */
        .stamina-fill { background-color: #6A5ACD; } /* Slate blue */
        .xp-fill { background-color: #32CD32; } /* Lime green */

        .level-info {
            font-size: 0.9em;
            margin-top: 5px;
            text-align: right;
            color: #bbb;
        }

        /* Game Over Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid #8a2be2;
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.8);
        }

        .modal-content h2 {
            color: #FF4500;
            font-size: 3em;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #FF4500;
        }

        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #ccc;
        }

        .modal-content button {
            background-color: #8a2be2;
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .modal-content button:hover {
            background-color: #9932CC;
            transform: scale(1.05);
        }

        /* New button styles for mobile/touch */
        .mobile-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
            width: 100%;
        }

        .mobile-button {
            background-color: #8a2be2;
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 10px rgba(138, 43, 226, 0.5);
            flex: 1; /* ボタンが均等に幅を占めるように */
            max-width: 200px; /* 最大幅を設定 */
        }

        .mobile-button:hover {
            background-color: #9932CC;
            transform: scale(1.05);
        }

        @media (max-width: 1024px) {
            .game-area {
                flex-direction: column;
                align-items: center;
            }

            .game-info {
                width: 100%;
                margin-bottom: 20px;
            }

            .game-grid-container {
                width: 100%;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                padding: 15px;
            }

            h1 {
                font-size: 2em;
            }

            .game-info h2 {
                font-size: 1.5em;
            }

            .stat-item {
                font-size: 0.8em;
                padding: 8px;
            }

            .grid-cell {
                width: 25px;
                height: 25px;
            }

            .mobile-button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .grid-cell {
                width: 20px;
                height: 20px;
            }
            .mobile-controls {
                flex-direction: column; /* 小さい画面では縦に並べる */
                gap: 10px;
            }
            .mobile-button {
                width: 80%; /* 幅を広げる */
                max-width: none; /* 最大幅を解除 */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>Wolf Pack Evolution RPG</h1>
        <div class="game-area">
            <div class="game-info">
                <h2>Player Stats</h2>
                <div class="stats-grid">
                    <div class="stat-item"><strong>Health:</strong> <span id="healthValue"></span><div class="status-bar"><div id="healthBar" class="status-bar-fill health-fill"></div></div></div>
                    <div class="stat-item"><strong>Hunger:</strong> <span id="hungerValue"></span><div class="status-bar"><div id="hungerBar" class="status-bar-fill hunger-fill"></div></div></div>
                    <div class="stat-item"><strong>Stamina:</strong> <span id="staminaValue"></span><div class="status-bar"><div id="staminaBar" class="status-bar-fill stamina-fill"></div></div></div>
                    <div class="stat-item"><strong>XP:</strong> <span id="xpValue"></span><div class="status-bar"><div id="xpBar" class="status-bar-fill xp-fill"></div></div></div>
                    <div class="stat-item"><strong>Level:</strong> <span id="levelValue"></span></div>
                    <div class="stat-item"><strong>Stage:</strong> <span id="stageValue"></span></div>
                    <div class="stat-item"><strong>Controlled:</strong> <span id="controlledWolf"></span></div>
                    <div class="stat-item"><strong>Prey Eaten:</strong> <span id="preyEaten"></span></div>
                    <div class="stat-item"><strong>Obstacles Destroyed:</strong> <span id="obstaclesDestroyed"></span></div>
                </div>

                <div class="pack-info">
                    <h3>Pack Members (<span id="packCount">0</span>)</h3>
                    <div id="packMembersList">
                        </div>
                </div>

                <div class="controls-section">
                    <h3>Controls</h3>
                    <ul>
                        <li><strong>Movement:</strong> Arrow Keys or W/A/S/D</li>
                        <li><strong>Howl (Call Pack/Intimidate):</strong> Spacebar</li>
                        <li><strong>Destroy Obstacle:</strong> X</li>
                        <li><strong>Switch to Mother Wolf:</strong> Q</li>
                        <li><strong>Switch to Pack Wolf:</strong> E</li>
                    </ul>
                </div>
            </div>

            <div class="game-grid-container">
                <div id="gameGrid"></div>
                <div class="mobile-controls">
                    <button class="mobile-button" id="howlButton">遠吠え</button>
                    <button class="mobile-button" id="destroyButton">破壊</button>
                </div>
            </div>
        </div>
    </div>

    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2>Game Over!</h2>
            <p id="gameOverReason"></p>
            <p>You survived <span id="finalStage"></span> stages and ate <span id="finalPrey"></span> prey.</p>
            <button id="restartButton">Restart Game</button>
        </div>
    </div>

    <script>
        // Game state and configurations
        const gridSize = 20; // 20x20 grid
        const cellSize = 30; // pixels
        const initialPackSize = 2; // Number of initial pack members
        const packGrowthInterval = 5; // New pack member every X stages

        const gameState = {
            player: {
                x: 0, y: 0,
                health: 100, maxHealth: 100,
                hunger: 100, maxHunger: 100,
                stamina: 100, maxStamina: 100,
                xp: 0, level: 1, xpToNextLevel: 100,
                speed: 1, // Movement speed
                attack: 10, // Attack power
                howlPower: 1, // Power of howl for intimidation/calling
                canDestroy: false, // Can destroy obstacles
                preyEaten: 0,
                obstaclesDestroyed: 0
            },
            motherWolf: {
                x: -1, y: -1, // Not on map initially
                health: 100, maxHealth: 100,
                hunger: 100, maxHunger: 100,
                stamina: 100, maxStamina: 100,
                attack: 15,
                howlPower: 1.5
            },
            pack: [],
            grid: [],
            entities: {}, // Stores positions and types of entities
            controlledWolf: 'player', // 'player', 'mother', 'pack'
            currentStage: 1,
            gameRunning: true,
            gameOverReason: ''
        };

        const entityTypes = {
            PLAYER: 'player-wolf',
            MOTHER: 'mother-wolf',
            PACK: 'pack-wolf',
            PREY: 'prey',
            OBSTACLE: 'obstacle',
            DEN: 'den',
            WATER: 'water',
            ITEM: 'item',
            ENEMY: 'enemy'
        };

        // UI Elements
        const gameGridElement = document.getElementById('gameGrid');
        const healthBar = document.getElementById('healthBar');
        const hungerBar = document.getElementById('hungerBar');
        const staminaBar = document.getElementById('staminaBar');
        const xpBar = document.getElementById('xpBar');
        const healthValue = document.getElementById('healthValue');
        const hungerValue = document.getElementById('hungerValue');
        const staminaValue = document.getElementById('staminaValue');
        const xpValue = document.getElementById('xpValue');
        const levelValue = document.getElementById('levelValue');
        const stageValue = document.getElementById('stageValue');
        const controlledWolfDisplay = document.getElementById('controlledWolf');
        const packMembersList = document.getElementById('packMembersList');
        const preyEatenDisplay = document.getElementById('preyEaten');
        const obstaclesDestroyedDisplay = document.getElementById('obstaclesDestroyed');
        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverReason = document.getElementById('gameOverReason');
        const finalStageDisplay = document.getElementById('finalStage');
        const finalPreyDisplay = document.getElementById('finalPrey');
        const restartButton = document.getElementById('restartButton');
        const howlButton = document.getElementById('howlButton'); // 追加
        const destroyButton = document.getElementById('destroyButton'); // 追加

        // Game Initialization
        function initGame() {
            // Reset game state
            gameState.player = {
                x: 0, y: 0,
                health: 100, maxHealth: 100,
                hunger: 100, maxHunger: 100,
                stamina: 100, maxStamina: 100,
                xp: 0, level: 1, xpToNextLevel: 100,
                speed: 1, attack: 10, howlPower: 1, canDestroy: false,
                preyEaten: 0, obstaclesDestroyed: 0
            };
            gameState.motherWolf = {
                x: -1, y: -1,
                health: 100, maxHealth: 100,
                hunger: 100, maxHunger: 100,
                stamina: 100, maxStamina: 100,
                attack: 15, howlPower: 1.5
            };
            gameState.pack = [];
            gameState.entities = {};
            gameState.controlledWolf = 'player';
            gameState.currentStage = 1;
            gameState.gameRunning = true;
            gameState.gameOverReason = '';

            gameOverModal.style.display = 'none'; // Hide game over modal

            setupGameGrid();
            placeInitialEntities();
            addPackMembers(initialPackSize); // Add initial pack members
            updateUI();
        }

        function setupGameGrid() {
            gameGridElement.innerHTML = '';
            gameGridElement.style.gridTemplateColumns = `repeat(${gridSize}, ${cellSize}px)`;
            gameGridElement.style.gridTemplateRows = `repeat(${gridSize}, ${cellSize}px)`;
            gameGridElement.style.width = `${gridSize * cellSize}px`;
            gameGridElement.style.height = `${gridSize * cellSize}px`;

            gameState.grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0)); // 0 for empty
            gameState.entities = {}; // Clear entities

            // Apply initial map theme
            updateMapTheme();

            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.x = j;
                    cell.dataset.y = i;
                    gameGridElement.appendChild(cell);
                }
            }
        }

        // Function to update map theme based on stage
        function updateMapTheme() {
            gameGridElement.classList.remove('theme-forest', 'theme-desert', 'theme-snow', 'theme-volcano', 'theme-swamp');
            const stage = gameState.currentStage;

            if (stage % 50 === 0) { // 例: 50ステージごとに森
                gameGridElement.classList.add('theme-forest');
            } else if (stage % 40 === 0) { // 例: 40ステージごとに砂漠
                gameGridElement.classList.add('theme-desert');
            } else if (stage % 30 === 0) { // 例: 30ステージごとに雪原
                gameGridElement.classList.add('theme-snow');
            } else if (stage % 20 === 0) { // 例: 20ステージごとに火山
                gameGridElement.classList.add('theme-volcano');
            } else if (stage % 10 === 0) { // 例: 10ステージごとに沼地
                gameGridElement.classList.add('theme-swamp');
            } else {
                // デフォルトのテーマ (紫の枠線)
            }
        }


        function placeInitialEntities() {
            // Place player at random position
            let px, py;
            do {
                px = Math.floor(Math.random() * gridSize);
                py = Math.floor(Math.random() * gridSize);
            } while (isOccupied(px, py));
            gameState.player.x = px;
            gameState.player.y = py;
            placeEntity(px, py, entityTypes.PLAYER);

            // Place mother wolf near player, or at a random valid spot
            let mx, my;
            do {
                mx = px + Math.floor(Math.random() * 3) - 1; // -1, 0, 1 from player x
                my = py + Math.floor(Math.random() * 3) - 1; // -1, 0, 1 from player y
            } while (!isValidPosition(mx, my) || isOccupied(mx, my));
            gameState.motherWolf.x = mx;
            gameState.motherWolf.y = my;
            placeEntity(mx, my, entityTypes.MOTHER);

            // Place den
            let dx, dy;
            do {
                dx = Math.floor(Math.random() * gridSize);
                dy = Math.floor(Math.random() * gridSize);
            } while (isOccupied(dx, dy));
            placeEntity(dx, dy, entityTypes.DEN);

            // Place initial prey
            for (let i = 0; i < 5; i++) {
                placeRandomEntity(entityTypes.PREY);
            }

            // Place initial obstacles
            for (let i = 0; i < 10; i++) {
                placeRandomEntity(entityTypes.OBSTACLE);
            }
        }

        function placeRandomEntity(type) {
            let x, y;
            do {
                x = Math.floor(Math.random() * gridSize);
                y = Math.floor(Math.random() * gridSize);
            } while (isOccupied(x, y));
            placeEntity(x, y, type);
        }

        function placeEntity(x, y, type, id = null) {
            const pos = `${x},${y}`;
            gameState.entities[pos] = { type: type, id: id };
            drawEntity(x, y, type, id);
        }

        function removeEntity(x, y) {
            const pos = `${x},${y}`;
            const entity = gameState.entities[pos];
            if (entity) {
                const cell = document.querySelector(`.grid-cell[data-x="${x}"][data-y="${y}"]`);
                if (cell) {
                    cell.classList.remove(entity.type);
                    if (entity.id) {
                        cell.classList.remove(`id-${entity.id}`);
                    }
                }
                delete gameState.entities[pos];
            }
        }

        function drawEntity(x, y, type, id = null) {
            const cell = document.querySelector(`.grid-cell[data-x="${x}"][data-y="${y}"]`);
            if (cell) {
                // Clear existing entity classes before adding new one
                cell.classList.forEach(className => {
                    if (Object.values(entityTypes).includes(className) || className.startsWith('id-')) {
                        cell.classList.remove(className);
                    }
                });
                cell.classList.add(type);
                if (id) {
                    cell.classList.add(`id-${id}`);
                }
            }
        }

        function updateControlledWolfDisplay() {
            // Clear previous controlled wolf highlight
            document.querySelectorAll('.controlled-wolf').forEach(el => el.classList.remove('controlled-wolf'));

            const controlled = getControlledWolf();
            if (controlled) {
                const cell = document.querySelector(`.grid-cell[data-x="${controlled.x}"][data-y="${controlled.y}"]`);
                if (cell) {
                    cell.classList.add('controlled-wolf');
                }
            }
        }

        function updateUI() {
            const player = gameState.player;
            healthBar.style.width = `${(player.health / player.maxHealth) * 100}%`;
            hungerBar.style.width = `${(player.hunger / player.maxHunger) * 100}%`;
            staminaBar.style.width = `${(player.stamina / player.maxStamina) * 100}%`;
            xpBar.style.width = `${(player.xp / player.xpToNextLevel) * 100}%`;

            healthValue.textContent = `${Math.floor(player.health)} / ${player.maxHealth}`;
            hungerValue.textContent = `${Math.floor(player.hunger)} / ${player.maxHunger}`;
            staminaValue.textContent = `${Math.floor(player.stamina)} / ${player.maxStamina}`;
            xpValue.textContent = `${player.xp} / ${player.xpToNextLevel}`;
            levelValue.textContent = player.level;
            stageValue.textContent = gameState.currentStage;
            controlledWolfDisplay.textContent = gameState.controlledWolf.charAt(0).toUpperCase() + gameState.controlledWolf.slice(1);
            preyEatenDisplay.textContent = player.preyEaten;
            obstaclesDestroyedDisplay.textContent = player.obstaclesDestroyed;

            // Update pack members list
            packMembersList.innerHTML = '';
            if (gameState.motherWolf.x !== -1) { // Mother wolf exists
                const motherDiv = document.createElement('div');
                motherDiv.classList.add('pack-member');
                motherDiv.innerHTML = `<strong>Mother Wolf:</strong> Health ${Math.floor(gameState.motherWolf.health)}, Hunger ${Math.floor(gameState.motherWolf.hunger)}`;
                packMembersList.appendChild(motherDiv);
            }
            gameState.pack.forEach((packMember, index) => {
                const packDiv = document.createElement('div');
                packDiv.classList.add('pack-member');
                packDiv.innerHTML = `<strong>Pack Wolf ${index + 1}:</strong> Health ${Math.floor(packMember.health)}, Hunger ${Math.floor(packMember.hunger)}`;
                packMembersList.appendChild(packDiv);
            });
            packCount.textContent = gameState.pack.length + (gameState.motherWolf.x !== -1 ? 1 : 0); // Include mother wolf if present

            updateControlledWolfDisplay();
        }

        function getControlledWolf() {
            if (gameState.controlledWolf === 'player') {
                return gameState.player;
            } else if (gameState.controlledWolf === 'mother') {
                return gameState.motherWolf;
            } else if (gameState.controlledWolf === 'pack' && gameState.pack.length > 0) {
                return gameState.pack[0]; // For simplicity, control the first pack member
            }
            return null;
        }

        function move(dy, dx) {
            if (!gameState.gameRunning) return;

            const controlled = getControlledWolf();
            if (!controlled) return;

            const newX = controlled.x + dx;
            const newY = controlled.y + dy;

            if (isValidPosition(newX, newY)) {
                const targetEntity = getEntityAt(newX, newY);

                if (targetEntity) {
                    if (targetEntity.type === entityTypes.PREY) {
                        eatPrey(newX, newY, controlled);
                        moveWolf(controlled, newX, newY);
                    } else if (targetEntity.type === entityTypes.OBSTACLE) {
                        // Cannot move onto an obstacle directly
                        console.log('Obstacle ahead!');
                    } else if (targetEntity.type === entityTypes.WATER) {
                        // Cannot move onto water directly
                        console.log('Water ahead!');
                    } else if (targetEntity.type === entityTypes.ENEMY) {
                        attackEnemy(newX, newY, controlled);
                    } else { // Another wolf, den, item - just move onto it (for now)
                        moveWolf(controlled, newX, newY);
                    }
                } else {
                    moveWolf(controlled, newX, newY);
                }
            }
            updateUI();
            checkGameOver();
        }

        function moveWolf(wolf, newX, newY) {
            removeEntity(wolf.x, wolf.y);
            wolf.x = newX;
            wolf.y = newY;
            placeEntity(wolf.x, wolf.y, entityTypeForWolf(wolf));
            // Decrease stamina and hunger for movement
            wolf.stamina = Math.max(0, wolf.stamina - 1);
            wolf.hunger = Math.max(0, wolf.hunger - 0.5);
            // After player moves, other wolves might move
            if (wolf === gameState.player) {
                moveOtherWolves();
            }
            updateUI();
        }

        function entityTypeForWolf(wolf) {
            if (wolf === gameState.player) return entityTypes.PLAYER;
            if (wolf === gameState.motherWolf) return entityTypes.MOTHER;
            // Find which pack member it is to assign correct type
            const packIndex = gameState.pack.indexOf(wolf);
            if (packIndex !== -1) return entityTypes.PACK;
            return ''; // Should not happen
        }

        function isValidPosition(x, y) {
            return x >= 0 && x < gridSize && y >= 0 && y < gridSize;
        }

        function isOccupied(x, y) {
            const pos = `${x},${y}`;
            return gameState.entities[pos] !== undefined;
        }

        function getEntityAt(x, y) {
            const pos = `${x},${y}`;
            return gameState.entities[pos];
        }

        function eatPrey(x, y, wolf) {
            removeEntity(x, y);
            wolf.hunger = Math.min(wolf.maxHunger, wolf.hunger + 30);
            wolf.health = Math.min(wolf.maxHealth, wolf.health + 5);
            if (wolf === gameState.player) {
                gameState.player.preyEaten++;
                gainXp(10);
            }
            placeRandomEntity(entityTypes.PREY); // Replenish prey
            updateUI();
        }

        function gainXp(amount) {
            gameState.player.xp += amount;
            if (gameState.player.xp >= gameState.player.xpToNextLevel) {
                levelUp();
            }
            updateUI();
        }

        function levelUp() {
            gameState.player.level++;
            gameState.player.xp -= gameState.player.xpToNextLevel;
            gameState.player.xpToNextLevel = Math.floor(gameState.player.xpToNextLevel * 1.5); // XP required for next level increases
            gameState.player.maxHealth += 10;
            gameState.player.health = gameState.player.maxHealth; // Full health on level up
            gameState.player.maxHunger += 5;
            gameState.player.maxStamina += 5;
            gameState.player.attack += 2;
            gameState.player.howlPower += 0.1;

            if (gameState.player.level % packGrowthInterval === 0) {
                addPackMembers(1); // Add a new pack member every X levels
            }

            // Unlock ability to destroy obstacles at level 3
            if (gameState.player.level >= 3) {
                gameState.player.canDestroy = true;
            }

            console.log(`Leveled up to Level ${gameState.player.level}!`);
            updateUI();
        }

        function howl() {
            if (!gameState.gameRunning) return;
            const controlled = getControlledWolf();
            if (!controlled || controlled.stamina < 10) {
                console.log("Not enough stamina to howl!");
                return;
            }

            controlled.stamina = Math.max(0, controlled.stamina - 10);
            console.log(`${controlled === gameState.player ? 'Player' : controlled === gameState.motherWolf ? 'Mother' : 'Pack'} howled!`);

            // Effects of howling (e.g., call pack, intimidate enemies)
            callPackToPlayer(controlled);
            // Future: intimidate nearby enemies

            updateUI();
        }

        function destroyObstacle() {
            if (!gameState.gameRunning) return;
            const controlled = getControlledWolf();
            if (!controlled || !controlled.canDestroy) {
                console.log("Cannot destroy obstacles yet!");
                return;
            }

            // Check adjacent cells for obstacles
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // Right, Left, Down, Up
            for (const [dy, dx] of directions) {
                const targetX = controlled.x + dx;
                const targetY = controlled.y + dy;

                if (isValidPosition(targetX, targetY)) {
                    const entity = getEntityAt(targetX, targetY);
                    if (entity && entity.type === entityTypes.OBSTACLE) {
                        removeEntity(targetX, targetY);
                        gameState.player.obstaclesDestroyed++;
                        gainXp(5); // Gain XP for destroying
                        placeRandomEntity(entityTypes.OBSTACLE); // Replenish
                        console.log(`Obstacle at (${targetX},${targetY}) destroyed!`);
                        updateUI();
                        return; // Destroy only one obstacle per action
                    }
                }
            }
            console.log("No obstacle found next to controlled wolf to destroy.");
        }

        function switchControlledWolf(type) {
            if (type === 'player') {
                gameState.controlledWolf = 'player';
            } else if (type === 'mother' && gameState.motherWolf.x !== -1) {
                gameState.controlledWolf = 'mother';
            } else if (type === 'pack' && gameState.pack.length > 0) {
                gameState.controlledWolf = 'pack';
            }
            updateUI();
        }

        function addPackMembers(count) {
            for (let i = 0; i < count; i++) {
                let px, py;
                do {
                    px = Math.floor(Math.random() * gridSize);
                    py = Math.floor(Math.random() * gridSize);
                } while (isOccupied(px, py));

                const newPackMember = {
                    x: px, y: py,
                    health: 80, maxHealth: 80,
                    hunger: 80, maxHunger: 80,
                    stamina: 80, maxStamina: 80,
                    attack: 8,
                    id: gameState.pack.length // Assign a unique ID
                };
                gameState.pack.push(newPackMember);
                placeEntity(px, py, entityTypes.PACK, newPackMember.id);
            }
            updateUI();
        }

        function callPackToPlayer(callerWolf) {
            const callerPos = { x: callerWolf.x, y: callerWolf.y };
            const wolvesToMove = [gameState.motherWolf, ...gameState.pack].filter(wolf => wolf.x !== -1 && wolf !== callerWolf);

            wolvesToMove.forEach(wolf => {
                const path = findPath(wolf.x, wolf.y, callerPos.x, callerPos.y);
                if (path && path.length > 1) { // Path found and has at least one step
                    const nextStep = path[1]; // The first step in the path after current position
                    moveWolf(wolf, nextStep.x, nextStep.y);
                }
            });
            updateUI();
        }


        // Simple A* pathfinding (can be optimized)
        function findPath(startX, startY, targetX, targetY) {
            const openSet = [];
            const closedSet = new Set();
            const cameFrom = new Map();

            const gScore = new Map(); // Cost from start to current node
            const fScore = new Map(); // Estimated cost from start to target (gScore + heuristic)

            const startNode = { x: startX, y: startY };
            const targetNode = { x: targetX, y: targetY };

            const heuristic = (nodeA, nodeB) => Math.abs(nodeA.x - nodeB.x) + Math.abs(nodeA.y - nodeB.y);

            const getNodeKey = (node) => `${node.x},${node.y}`;

            gScore.set(getNodeKey(startNode), 0);
            fScore.set(getNodeKey(startNode), heuristic(startNode, targetNode));
            openSet.push(startNode);

            while (openSet.length > 0) {
                openSet.sort((a, b) => fScore.get(getNodeKey(a)) - fScore.get(getNodeKey(b)));
                const current = openSet.shift(); // Get node with lowest fScore

                if (current.x === targetNode.x && current.y === targetNode.y) {
                    // Reconstruct path
                    const path = [];
                    let temp = current;
                    while (temp) {
                        path.unshift(temp);
                        temp = cameFrom.get(getNodeKey(temp));
                    }
                    return path;
                }

                closedSet.add(getNodeKey(current));

                const neighbors = [];
                const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]; // 4 directions
                for (const [dy, dx] of directions) {
                    const neighborX = current.x + dx;
                    const neighborY = current.y + dy;

                    if (isValidPosition(neighborX, neighborY)) {
                        const neighborNode = { x: neighborX, y: neighborY };
                        const neighborKey = getNodeKey(neighborNode);

                        // Don't consider obstacles or other wolves as path
                        const entityAtNeighbor = getEntityAt(neighborX, neighborY);
                        if (entityAtNeighbor && (entityAtNeighbor.type === entityTypes.OBSTACLE ||
                                                entityAtNeighbor.type === entityTypes.PLAYER ||
                                                entityAtNeighbor.type === entityTypes.MOTHER ||
                                                entityAtNeighbor.type === entityTypes.PACK ||
                                                entityAtNeighbor.type === entityTypes.WATER)) {
                            continue;
                        }
                        neighbors.push(neighborNode);
                    }
                }

                for (const neighbor of neighbors) {
                    const neighborKey = getNodeKey(neighbor);
                    if (closedSet.has(neighborKey)) {
                        continue;
                    }

                    const tentativeGScore = gScore.get(getNodeKey(current)) + 1; // Distance is 1 for adjacent cells

                    if (!openSet.includes(neighbor) || tentativeGScore < gScore.get(neighborKey)) {
                        cameFrom.set(neighborKey, current);
                        gScore.set(neighborKey, tentativeGScore);
                        fScore.set(neighborKey, tentativeGScore + heuristic(neighbor, targetNode));
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null; // No path found
        }


        function moveOtherWolves() {
            const playerPos = { x: gameState.player.x, y: gameState.player.y };
            const allOtherWolves = [gameState.motherWolf, ...gameState.pack].filter(wolf => wolf.x !== -1 && wolf !== gameState.player);

            allOtherWolves.forEach(wolf => {
                // If a wolf is very close to the player (e.g., 1 cell away), don't move it closer.
                // This prevents them from stacking on top of the player unless forced.
                const dist = Math.abs(wolf.x - playerPos.x) + Math.abs(wolf.y - playerPos.y);
                if (dist <= 1) { // If adjacent or on same spot
                    return;
                }

                // If hungry, try to find food first
                if (wolf.hunger < wolf.maxHunger * 0.5) {
                    const closestPrey = findClosestEntity(wolf.x, wolf.y, entityTypes.PREY);
                    if (closestPrey) {
                        const path = findPath(wolf.x, wolf.y, closestPrey.x, closestPrey.y);
                        if (path && path.length > 1) {
                            const nextStep = path[1];
                            const targetEntity = getEntityAt(nextStep.x, nextStep.y);
                            if (targetEntity && targetEntity.type === entityTypes.PREY) {
                                eatPrey(nextStep.x, nextStep.y, wolf);
                            } else {
                                moveWolf(wolf, nextStep.x, nextStep.y);
                            }
                            return; // Moved towards prey, so don't move towards player in this turn
                        }
                    }
                }

                // Otherwise, move towards the player
                const path = findPath(wolf.x, wolf.y, playerPos.x, playerPos.y);
                if (path && path.length > 1) {
                    const nextStep = path[1];
                    // Ensure the next step isn't already occupied by another wolf or an obstacle
                    const targetEntity = getEntityAt(nextStep.x, nextStep.y);
                    if (!targetEntity || (targetEntity.type !== entityTypes.OBSTACLE &&
                                         targetEntity.type !== entityTypes.PLAYER &&
                                         targetEntity.type !== entityTypes.MOTHER &&
                                         targetEntity.type !== entityTypes.PACK &&
                                         targetEntity.type !== entityTypes.WATER)) {
                        moveWolf(wolf, nextStep.x, nextStep.y);
                    }
                }
            });
        }

        function findClosestEntity(startX, startY, type) {
            let closest = null;
            let minDist = Infinity;

            for (const pos in gameState.entities) {
                const entity = gameState.entities[pos];
                if (entity.type === type) {
                    const [x, y] = pos.split(',').map(Number);
                    const dist = Math.abs(startX - x) + Math.abs(startY - y);
                    if (dist < minDist) {
                        minDist = dist;
                        closest = { x: x, y: y, type: type };
                    }
                }
            }
            return closest;
        }

        function attackEnemy(x, y, wolf) {
            const enemyEntity = getEntityAt(x, y);
            if (enemyEntity && enemyEntity.type === entityTypes.ENEMY) {
                // For simplicity, enemy is removed after attack. In a real game, it would have health.
                removeEntity(x, y);
                gainXp(20);
                // Damage enemy based on wolf's attack power
                console.log(`${wolf === gameState.player ? 'Player' : 'Pack'} attacked enemy!`);
                // Replenish enemy
                placeRandomEntity(entityTypes.ENEMY);
            }
        }

        function checkGameOver() {
            if (gameState.player.health <= 0 || gameState.player.hunger <= 0) {
                gameState.gameRunning = false;
                gameState.gameOverReason = gameState.player.health <= 0 ? "You ran out of health!" : "You starved to death!";
                showGameOverModal();
            }
        }

        function showGameOverModal() {
            gameOverReason.textContent = gameState.gameOverReason;
            finalStageDisplay.textContent = gameState.currentStage;
            finalPreyDisplay.textContent = gameState.player.preyEaten;
            gameOverModal.style.display = 'flex';
        }

        function nextStage() {
            gameState.currentStage++;
            console.log(`Entering Stage ${gameState.currentStage}`);
            // Reset grid and re-populate entities for new stage
            setupGameGrid(); // This also updates the map theme
            placeInitialEntities(); // This will place player and mother wolf again
            // Ensure existing pack members are placed in new grid (update their positions)
            gameState.pack.forEach(packMember => {
                let px, py;
                do {
                    px = Math.floor(Math.random() * gridSize);
                    py = Math.floor(Math.random() * gridSize);
                } while (isOccupied(px, py));
                packMember.x = px;
                packMember.y = py;
                placeEntity(px, py, entityTypes.PACK, packMember.id);
            });

            // Add more entities as stages progress
            for (let i = 0; i < gameState.currentStage; i++) {
                placeRandomEntity(entityTypes.PREY);
                placeRandomEntity(entityTypes.OBSTACLE);
                if (gameState.currentStage % 5 === 0) { // Add enemies every 5 stages
                    placeRandomEntity(entityTypes.ENEMY);
                }
                if (gameState.currentStage % 3 === 0) { // Add water every 3 stages
                    placeRandomEntity(entityTypes.WATER);
                }
            }

            // Slowly increase player stats for challenge
            gameState.player.maxHealth += 2;
            gameState.player.maxHunger += 1;
            gameState.player.maxStamina += 1;

            updateUI();
        }

        // Event Listeners
        restartButton.addEventListener('click', initGame);

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameOverModal').style.display === 'flex') {
                // Disable controls when game over modal is open
                return;
            }
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W': move(-1, 0); break;
                case 'ArrowDown': case 's': case 'S': move(1, 0); break;
                case 'ArrowLeft': case 'a': case 'A': move(0, -1); break;
                case 'ArrowRight': case 'd': case 'D': move(0, 1); break;
                case ' ': howl(); break; // Spacebar for howl
                case 'x': case 'X': destroyObstacle(); break; // 'x' key for destroy
                // New keybinds: 'q' for mother wolf, 'e' for pack
                case 'q': case 'Q': switchControlledWolf('mother'); break;
                case 'e': case 'E': switchControlledWolf('pack'); break;
            }
        });

        // ボタンのイベントリスナーを追加
        howlButton.addEventListener('click', howl);
        destroyButton.addEventListener('click', destroyObstacle);


        // Slowly auto-recover hunger and stamina, and take hunger damage
        setInterval(() => {
            if (gameState.gameRunning) {
                // Hunger recovery
                if (gameState.player.hunger < gameState.player.maxHunger) {
                    gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 0.5);
                }
                // Stamina recovery
                if (gameState.player.stamina < gameState.player.maxStamina) {
                    gameState.player.stamina = Math.min(gameState.player.maxStamina, gameState.player.stamina + 1);
                }

                // Hunger damage (if hunger is too low)
                if (gameState.player.hunger <= 0) {
                    gameState.player.health = Math.max(0, gameState.player.health - 1); // Lose 1 health per tick
                }

                // Pack members also lose hunger
                [gameState.motherWolf, ...gameState.pack].forEach(wolf => {
                    if (wolf.x !== -1) { // Only if wolf is alive/on map
                        wolf.hunger = Math.max(0, wolf.hunger - 0.5); // Pack members also get hungry
                        if (wolf.hunger <= 0) {
                            wolf.health = Math.max(0, wolf.health - 0.5); // Pack members also take hunger damage
                        }
                    }
                });

                // Check for game over (due to hunger damage)
                checkGameOver();
                updateUI();
            }
        }, 1000); // Check every second

        // Advance to next stage periodically (e.g., every 30 seconds)
        setInterval(() => {
            if (gameState.gameRunning) {
                nextStage();
            }
        }, 30000); // Advance stage every 30 seconds for now

        // Initialize game on load
        window.onload = initGame;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Pack Evolution RPG</title>
    <style>
        /* General styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27, #1a1a2e, #16213e);
            min-height: 100vh;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.4);
            max-width: 1300px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #8a2be2;
            font-size: 2.5em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 30px;
            align-items: start;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(12, 45px);
            grid-template-rows: repeat(12, 45px);
            gap: 2px;
            background: #111;
            padding: 10px;
            border-radius: 10px;
            border: 3px solid #8a2be2;
            box-shadow: inset 0 0 20px rgba(138, 43, 226, 0.3);
        }

        .tile {
            width: 45px;
            height: 45px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
        }

        .tile:hover {
            border-color: #8a2be2;
            transform: scale(1.05);
        }

        /* Terrain styles */
        .grass { background: linear-gradient(135deg, #2d5016, #3e6b1f); }
        .forest { background: linear-gradient(135deg, #1a3a1a, #2d5a2d); }
        .mountain { background: linear-gradient(135deg, #4a4a4a, #6a6a6a); }
        .water { background: linear-gradient(135deg, #1e3a5f, #2e5a8f); }
        .goal {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            animation: goalPulse 2s infinite;
        }

        @keyframes goalPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        /* Character styles */
        .player {
            color: #ff1493;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 24px;
            animation: motherWolfGlow 2s infinite;
        }
        .player.controlled {
            border: 3px solid #00ffff; /* Cyan border for controlled Mother Wolf */
        }

        @keyframes motherWolfGlow {
            0%, 100% { filter: drop-shadow(0 0 3px #ff1493); }
            50% { filter: drop-shadow(0 0 8px #ff1493); }
        }

        .pack-icon {
            color: #9370db;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 22px;
            position: relative;
            animation: packPulse 3s infinite;
        }
        .pack-icon.controlled {
            border: 3px solid #00ffff; /* Cyan border for controlled Pack */
        }

        @keyframes packPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pack-size {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ff4444;
            color: white;
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 10px;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .enemy {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 22px;
            position: relative;
        }

        .hp-bar {
            position: absolute;
            bottom: -5px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: #ff4444;
            transition: width 0.3s ease;
        }

        /* UI Panel styles */
        .ui-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(5px);
        }

        .stat-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border-left: 4px solid #8a2be2;
        }

        .stat-bar {
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            height: 22px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        .stat-fill {
            height: 100%;
            transition: width 0.5s ease;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
            position: relative;
        }

        .stat-fill.hunger {
            background: linear-gradient(90deg, #f39c12, #f1c40f);
        }

        .stat-fill.exp {
            background: linear-gradient(90deg, #8a2be2, #9370db);
        }

        .stat-fill.pack-hp {
            background: linear-gradient(90deg, #00bfff, #87cefa);
        }

        /* Controls */
        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px 0;
        }

        .control-btn {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 15px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #6a1b9a, #8a2be2);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .action-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            width: 100%;
            margin: 5px 0;
        }

        .control-selection {
            grid-column: span 3; /* Span full width */
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
            color: #fff;
            font-size: 1.1em;
        }

        .control-selection button {
            padding: 8px 15px;
            font-size: 14px;
            background: #555;
            border: 2px solid #555;
        }
        .control-selection button.active {
            background: #8a2be2;
            border-color: #00ffff;
            box-shadow: 0 0 8px #00ffff;
        }

        /* Message area */
        .message-area {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            border: 2px solid rgba(138, 43, 226, 0.3);
            font-size: 14px;
            line-height: 1.5;
        }

        .message {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
        }

        .message.hunt {
            border-left: 4px solid #e74c3c;
        }

        .message.pack {
            border-left: 4px solid #9370db;
        }

        .message.level {
            border-left: 4px solid #f39c12;
            font-weight: bold;
        }

        .pack-traits {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .trait-badge {
            background: rgba(147, 112, 219, 0.2);
            border: 1px solid #9370db;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .trait-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }

        .stage-info {
            text-align: center;
            font-size: 18px;
            color: #f39c12;
            margin: 10px 0;
        }

        /* Modal for Game Over */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #1a1a2e;
            margin: auto;
            padding: 30px;
            border: 2px solid #8a2be2;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }

        .modal-content h2 {
            color: #ff1493;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal-content p {
            font-size: 1.1em;
            margin-bottom: 25px;
        }

        .modal-content button {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .modal-content button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(135deg, #6a1b9a, #8a2be2);
        }

        /* Responsive design */
        @media (max-width: 768px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .game-grid {
                grid-template-columns: repeat(12, 35px);
                grid-template-rows: repeat(12, 35px);
            }

            .tile {
                width: 35px;
                height: 35px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸº Wolf Pack Evolution ğŸº</h1>

        <div class="stage-info">Stage <span id="stage">1</span> / 50</div>

        <div class="game-area">
            <div class="game-board">
                <div class="game-grid" id="gameGrid"></div>

                <div class="controls">
                    <div class="control-selection">
                        <span>ç¾åœ¨æ“ä½œä¸­: <span id="controlledWolfDisplay">æ¯ã‚¦ãƒ«ãƒ•</span></span>
                        <button id="controlMotherBtn" class="control-btn active" onclick="switchControlledWolf('mother')">æ¯ã‚¦ãƒ«ãƒ•ã‚’æ“ä½œ</button>
                        <button id="controlPackBtn" class="control-btn" onclick="switchControlledWolf('pack')">ç¾¤ã‚Œã‚’æ“ä½œ</button>
                    </div>
                    <!-- Swapped North and West buttons -->
                    <button class="control-btn" onclick="move(0, -1)">â¬…ï¸ è¥¿</button>
                    <button class="control-btn" onclick="move(-1, 0)">â¬†ï¸ åŒ—</button>
                    <button class="control-btn" onclick="move(0, 1)">â¡ï¸ æ±</button>
                    <button class="control-btn"></button>
                    <button class="control-btn" onclick="move(1, 0)">â¬‡ï¸ å—</button>
                    <button class="control-btn"></button>
                    <button class="control-btn action-btn" onclick="howl()">ğŸŒ™ é å ãˆ</button>
                    <button class="control-btn action-btn" onclick="destroyObstacle()">ğŸ’¥ ç ´å£Š</button>
                    <button class="control-btn action-btn" onclick="resetGame()">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
                </div>
            </div>

            <div class="ui-panel">
                <div class="stat-group">
                    <h3>ğŸº æ¯ã‚¦ãƒ«ãƒ•</h3>
                    <div>ãƒ¬ãƒ™ãƒ«: <span id="level">1</span></div>
                    <div>HP: <span id="health">100</span>/<span id="maxHealth">100</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill" id="healthBar" style="width: 100%"></div>
                    </div>
                    <div>æº€è…¹åº¦: <span id="hunger">100</span>/100</div>
                    <div class="stat-bar">
                        <div class="stat-fill hunger" id="hungerBar" style="width: 100%"></div>
                    </div>
                    <div>çµŒé¨“å€¤: <span id="exp">0</span>/100</div>
                    <div class="stat-bar">
                        <div class="stat-fill exp" id="expBar" style="width: 0%"></div>
                    </div>
                    <div>æ”»æ’ƒåŠ›: <span id="attack">20</span></div>
                </div>

                <div class="stat-group">
                    <h3>ğŸº ç¾¤ã‚Œæƒ…å ±</h3>
                    <div>ç·é ­æ•°: <span id="packCount">0</span></div>
                    <div>ç¾¤ã‚ŒHP: <span id="packHealth">0</span>/<span id="packMaxHealth">0</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill pack-hp" id="packHealthBar" style="width: 0%"></div>
                    </div>
                    <div>ç¾¤ã‚Œç·æ”»æ’ƒåŠ›: <span id="packPower">0</span></div>
                    <div class="pack-traits" id="packTraits"></div>
                </div>

                <div class="stat-group">
                    <h3>ğŸ“œ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸</h3>
                    <div class="message-area" id="messages"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2>ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼</h2>
            <p id="gameOverMessage">æ¯ã‚¦ãƒ«ãƒ•ã¯å€’ã‚Œã¾ã—ãŸã€‚ã‚ãªãŸã®æ—…ã¯ã“ã“ã§çµ‚ã‚ã‚Šã¾ã™ã€‚</p>
            <button onclick="resetGame()">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
        </div>
    </div>

    <script>
        // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹
        let gameState = {
            player: { x: 0, y: 0, health: 100, maxHealth: 100, hunger: 100, maxHunger: 100, level: 1, exp: 0, attack: 20 },
            pack: null, // ç¾¤ã‚Œã®ä»£è¡¨ä½ç½®
            packMembers: [], // å„ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ï¼ˆä½“åŠ›ã€æ”»æ’ƒåŠ›ã€ç‰¹æ€§ï¼‰
            packHealth: 0, // ç¾¤ã‚Œã®ç·ä½“åŠ›
            packMaxHealth: 0, // ç¾¤ã‚Œã®æœ€å¤§ç·ä½“åŠ›
            enemies: [], // æ•µã®ãƒªã‚¹ãƒˆ
            grid: [], // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã®åœ°å½¢
            stage: 1, // ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¸
            playerMoveCount: 0, // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•å›æ•°ï¼ˆè‡ªå‹•è¡Œå‹•ã®ãƒˆãƒªã‚¬ãƒ¼ç”¨ï¼‰
            controlledWolf: 'mother' // ç¾åœ¨æ“ä½œã—ã¦ã„ã‚‹ã‚¦ãƒ«ãƒ• ('mother' ã¾ãŸã¯ 'pack')
        };

        // ã‚²ãƒ¼ãƒ å®šæ•°
        const GAME_BOARD_SIZE = 12;
        const MAX_STAGE = 50;
        const BOSS_STAGE_INTERVAL = 10;

        // åœ°å½¢ã‚¿ã‚¤ãƒ—
        const TERRAIN = {
            GRASS: 'grass',
            FOREST: 'forest',
            MOUNTAIN: 'mountain',
            WATER: 'water',
            GOAL: 'goal'
        };

        // æ•µã‚¿ã‚¤ãƒ—ï¼ˆç‰¹æ€§ä»˜ãï¼‰
        const ENEMY_TYPES = [
            { icon: 'ğŸ°', name: 'ã‚¦ã‚µã‚®', baseHealth: 30, baseAttack: 5, exp: 15, speed: 2, trait: 'speed', traitName: 'æ•æ·æ€§' },
            { icon: 'ğŸ¦Œ', name: 'ã‚·ã‚«', baseHealth: 50, baseAttack: 10, exp: 25, speed: 1, trait: 'health', traitName: 'ç”Ÿå‘½åŠ›' },
            { icon: 'ğŸ—', name: 'ã‚¤ãƒã‚·ã‚·', baseHealth: 70, baseAttack: 15, exp: 35, speed: 1, trait: 'attack', traitName: 'åŠ›' },
            { icon: 'ğŸ»', name: 'ã‚¯ãƒ', baseHealth: 100, baseAttack: 20, exp: 50, speed: 1, trait: 'defense', traitName: 'é˜²å¾¡' },
            { icon: 'ğŸ¦…', name: 'ãƒ¯ã‚·', baseHealth: 40, baseAttack: 25, exp: 40, speed: 2, trait: 'vision', traitName: 'è¦–åŠ›' }
        ];

        // ãƒœã‚¹æ•µã‚¿ã‚¤ãƒ—
        const BOSS_TYPES = [
            { icon: 'ğŸº', name: 'ã‚¢ãƒ«ãƒ•ã‚¡ã‚¦ãƒ«ãƒ•', baseHealth: 300, baseAttack: 40, exp: 200, speed: 1, trait: 'leadership', traitName: 'çµ±ç‡åŠ›' }, // Stage 10
            { icon: 'ğŸ…', name: 'ã‚µãƒ¼ãƒ™ãƒ«ã‚¿ã‚¤ã‚¬ãƒ¼', baseHealth: 500, baseAttack: 60, exp: 300, speed: 2, trait: 'ferocity', traitName: 'ç°çŒ›ã•' }, // Stage 20
            { icon: 'ğŸ‰', name: 'å¤ä»£ãƒ‰ãƒ©ã‚´ãƒ³', baseHealth: 800, baseAttack: 80, exp: 500, speed: 1, trait: 'draconic', traitName: 'ç«œã®åŠ›' }, // Stage 30
            { icon: 'ğŸ¦', name: 'ã‚­ãƒ³ã‚°ã‚³ãƒ³ã‚°', baseHealth: 1200, baseAttack: 100, exp: 800, speed: 1, trait: 'goliath', traitName: 'å·¨äººã®åŠ›' }, // Stage 40
            { icon: 'ğŸ”¥', name: 'ã‚¨ãƒ¬ãƒ¡ãƒ³ã‚¿ãƒ«ãƒ­ãƒ¼ãƒ‰', baseHealth: 1500, baseAttack: 120, exp: 1000, speed: 2, trait: 'elemental', traitName: 'å…ƒç´ ã®åŠ›' } // Stage 50
        ];

        // ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
        function initGame() {
            generateTerrain();
            generateEnemies();
            renderGame();
            updatePackHealth(); // ç¾¤ã‚Œã®ä½“åŠ›ã‚’åˆæœŸåŒ–
            addMessage("ğŸŒ™ æ¯ã‚¦ãƒ«ãƒ•ã¨ã—ã¦ã€ç¾¤ã‚Œã‚’å½¢æˆã—ã¾ã—ã‚‡ã†ï¼ç²ç‰©ã‹ã‚‰ç‰¹æ€§ã‚’ç¶™æ‰¿ã—ã€æœ€å¼·ã®ç¾¤ã‚Œã‚’ç¯‰ãã¾ã—ã‚‡ã†ï¼", "level");
            addMessage("ğŸ¯ ã‚´ãƒ¼ãƒ«ï¼ˆé‡‘è‰²ã‚¿ã‚¤ãƒ«ï¼‰ã¸å‘ã‹ã„ã¾ã—ã‚‡ã†ï¼", "level");
            updateControlButtons(); // åˆ¶å¾¡ãƒœã‚¿ãƒ³ã®åˆæœŸçŠ¶æ…‹ã‚’æ›´æ–°
        }

        // åœ°å½¢ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ç”Ÿæˆ
        function generateTerrain() {
            gameState.grid = [];
            const terrainTypes = [TERRAIN.GRASS, TERRAIN.FOREST, TERRAIN.MOUNTAIN, TERRAIN.WATER];

            for (let row = 0; row < GAME_BOARD_SIZE; row++) {
                gameState.grid[row] = [];
                for (let col = 0; col < GAME_BOARD_SIZE; col++) {
                    if (row === 0 && col === 0) {
                        gameState.grid[row][col] = TERRAIN.GRASS; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é–‹å§‹ä½ç½®
                    } else if (row === GAME_BOARD_SIZE - 1 && col === GAME_BOARD_SIZE - 1) {
                        gameState.grid[row][col] = TERRAIN.GOAL; // ã‚´ãƒ¼ãƒ«
                    } else {
                        // é‡ã¿ä»˜ã‘ã•ã‚ŒãŸãƒ©ãƒ³ãƒ€ãƒ ãªåœ°å½¢ç”Ÿæˆ
                        const weights = [40, 30, 20, 10]; // è‰ã€æ£®ã€å±±ã€æ°´
                        const random = Math.random() * 100;
                        let cumulative = 0;
                        for (let i = 0; i < terrainTypes.length; i++) {
                            cumulative += weights[i];
                            if (random < cumulative) {
                                gameState.grid[row][col] = terrainTypes[i];
                                break;
                            }
                        }
                    }
                }
            }

            ensurePathExists();
        }

        // ã‚·ãƒ³ãƒ—ãƒ«ãªè²ªæ¬²æ³•ã§å¸¸ã«ã‚´ãƒ¼ãƒ«ã¸ã®ãƒ‘ã‚¹ãŒå­˜åœ¨ã™ã‚‹ã‚ˆã†ã«ã™ã‚‹
        function ensurePathExists() {
            let x = 0, y = 0;
            while (x < GAME_BOARD_SIZE - 1 || y < GAME_BOARD_SIZE - 1) {
                if (Math.random() < 0.5 && x < GAME_BOARD_SIZE - 1) {
                    x++;
                } else if (y < GAME_BOARD_SIZE - 1) {
                    y++;
                }
                // ãƒ‘ã‚¹ä¸Šã®é€šè¡Œä¸èƒ½ãªåœ°å½¢ã‚’è‰åœ°ã«å¤‰æ›´
                if (gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN) {
                    gameState.grid[x][y] = TERRAIN.GRASS;
                }
            }
        }

        // æ•µã‚’ç”Ÿæˆ
        function generateEnemies() {
            gameState.enemies = [];
            let enemyCount = 8 + Math.floor(gameState.stage / 2); // æ•µã®æ•°ã¯ã‚¹ãƒ†ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ã‚¹ã‚±ãƒ¼ãƒ«

            // ãƒœã‚¹ã‚¹ãƒ†ãƒ¼ã‚¸ã®ç¢ºèª
            if (gameState.stage % BOSS_STAGE_INTERVAL === 0 && gameState.stage <= MAX_STAGE) {
                const bossIndex = (gameState.stage / BOSS_STAGE_INTERVAL) - 1;
                const bossType = BOSS_TYPES[bossIndex];

                let x, y;
                do {
                    x = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    y = Math.floor(Math.random() * GAME_BOARD_SIZE);
                } while ((x === gameState.player.x && y === gameState.player.y) || // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’é¿ã‘ã‚‹
                         (gameState.pack && x === gameState.pack.x && y === gameState.pack.y) || // ç¾¤ã‚Œã®ä½ç½®ã‚’é¿ã‘ã‚‹
                         gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN);

                gameState.enemies.push({
                    x, y,
                    icon: bossType.icon,
                    name: bossType.name,
                    health: bossType.baseHealth + (gameState.stage * 10), // ãƒœã‚¹ã®ä½“åŠ›ã¯ã‚¹ã‚±ãƒ¼ãƒ«
                    maxHealth: bossType.baseHealth + (gameState.stage * 10),
                    attack: bossType.baseAttack + (gameState.stage * 3), // ãƒœã‚¹ã®æ”»æ’ƒåŠ›ã¯ã‚¹ã‚±ãƒ¼ãƒ«
                    exp: bossType.exp + (gameState.stage * 5),
                    speed: bossType.speed,
                    trait: bossType.trait,
                    traitName: bossType.traitName,
                    id: Date.now() + Math.random(),
                    moveCounter: 0,
                    isBoss: true
                });
                enemyCount = 0; // ãƒœã‚¹ã‚¹ãƒ†ãƒ¼ã‚¸ã§ã¯ãƒœã‚¹ã®ã¿
            }


            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                do {
                    x = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    y = Math.floor(Math.random() * GAME_BOARD_SIZE);
                } while ((x === gameState.player.x && y === gameState.player.y) || // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã‚’é¿ã‘ã‚‹
                         (gameState.pack && x === gameState.pack.x && y === gameState.pack.y) || // ç¾¤ã‚Œã®ä½ç½®ã‚’é¿ã‘ã‚‹
                         gameState.enemies.some(e => e.x === x && e.y === y) || // ä»–ã®æ•µã®ä½ç½®ã‚’é¿ã‘ã‚‹
                         gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN);

                // æ•µã®å¼·ã•ã¯ã‚¹ãƒ†ãƒ¼ã‚¸ã¨ã¨ã‚‚ã«ã‚¹ã‚±ãƒ¼ãƒ«
                const typeIndex = Math.min(Math.floor(Math.random() * ENEMY_TYPES.length),
                                          Math.floor(gameState.stage / 5)); // é€²ã‚“ã æ•µã¯å¾Œã§å‡ºç¾
                const enemyType = ENEMY_TYPES[typeIndex];

                gameState.enemies.push({
                    x, y,
                    icon: enemyType.icon,
                    name: enemyType.name,
                    health: enemyType.baseHealth + (gameState.stage * 2), // ä½“åŠ›ã¯ã‚¹ã‚±ãƒ¼ãƒ«
                    maxHealth: enemyType.baseHealth + (gameState.stage * 2),
                    attack: enemyType.baseAttack + Math.floor(gameState.stage / 3), // æ”»æ’ƒåŠ›ã¯ã‚¹ã‚±ãƒ¼ãƒ«
                    exp: enemyType.exp + Math.floor(gameState.stage / 2),
                    speed: enemyType.speed,
                    trait: enemyType.trait,
                    traitName: enemyType.traitName,
                    id: Date.now() + Math.random(),
                    moveCounter: 0,
                    isBoss: false
                });
            }
        }

        // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã®æç”»
        function renderGame() {
            const grid = document.getElementById('gameGrid');
            grid.innerHTML = '';

            for (let row = 0; row < GAME_BOARD_SIZE; row++) {
                for (let col = 0; col < GAME_BOARD_SIZE; col++) {
                    const tile = document.createElement('div');
                    tile.className = `tile ${gameState.grid[row][col]}`;

                    let content = '';

                    // æ¯ã‚¦ãƒ«ãƒ•
                    if (gameState.player.x === row && gameState.player.y === col) {
                        const controlledClass = gameState.controlledWolf === 'mother' ? ' controlled' : '';
                        content = `<span class="player${controlledClass}">ğŸº</span>`;
                    }
                    // ç¾¤ã‚Œ
                    else if (gameState.pack && gameState.pack.x === row && gameState.pack.y === col) {
                        const controlledClass = gameState.controlledWolf === 'pack' ? ' controlled' : '';
                        content = `<span class="pack-icon${controlledClass}">ğŸº<span class="pack-size">${gameState.packMembers.length}</span></span>`;
                    }
                    // æ•µï¼ˆHPãƒãƒ¼ä»˜ãï¼‰
                    else if (gameState.enemies.some(e => e.x === row && e.y === col)) {
                        const enemy = gameState.enemies.find(e => e.x === row && e.y === col);
                        const hpPercent = (enemy.health / enemy.maxHealth) * 100;
                        content = `
                            <span class="enemy">${enemy.icon}</span>
                            <div class="hp-bar">
                                <div class="hp-fill" style="width: ${hpPercent}%"></div>
                            </div>
                        `;
                    }
                    // åœ°å½¢
                    else {
                        switch (gameState.grid[row][col]) {
                            case TERRAIN.GRASS: content = 'ğŸŒ¾'; break;
                            case TERRAIN.FOREST: content = 'ğŸŒ²'; break;
                            case TERRAIN.MOUNTAIN: content = 'â›°ï¸'; break;
                            case TERRAIN.WATER: content = 'ğŸ’§'; break;
                            case TERRAIN.GOAL: content = 'ğŸ'; break;
                        }
                    }

                    tile.innerHTML = content;
                    grid.appendChild(tile);
                }
            }

            updateUI();
        }

        // UIè¦ç´ ã®æ›´æ–°
        function updateUI() {
            document.getElementById('stage').textContent = gameState.stage;
            document.getElementById('level').textContent = gameState.player.level;
            document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.player.health)); // HPãŒè² ã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹
            document.getElementById('maxHealth').textContent = gameState.player.maxHealth;
            document.getElementById('hunger').textContent = Math.floor(gameState.player.hunger);
            document.getElementById('exp').textContent = gameState.player.exp;
            document.getElementById('attack').textContent = gameState.player.attack;
            document.getElementById('packCount').textContent = gameState.packMembers.length;
            document.getElementById('packHealth').textContent = Math.floor(gameState.packHealth);
            document.getElementById('packMaxHealth').textContent = gameState.packMaxHealth;

            // ç¾¤ã‚Œã®ç·æ”»æ’ƒåŠ›ã‚’è¨ˆç®—
            let packPower = 0;
            gameState.packMembers.forEach(member => {
                packPower += member.attack;
            });
            document.getElementById('packPower').textContent = packPower;

            // ãƒãƒ¼ã‚’æ›´æ–°
            const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const hungerPercent = (gameState.player.hunger / gameState.player.maxHunger) * 100;
            const expPercent = (gameState.player.exp / (gameState.player.level * 100)) * 100;
            const packHealthPercent = (gameState.packMembers.length > 0) ? (gameState.packHealth / gameState.packMaxHealth) * 100 : 0;


            document.getElementById('healthBar').style.width = healthPercent + '%';
            document.getElementById('hungerBar').style.width = hungerPercent + '%';
            document.getElementById('expBar').style.width = expPercent + '%';
            document.getElementById('packHealthBar').style.width = packHealthPercent + '%';

            // ç¾¤ã‚Œã®ç‰¹æ€§ã‚’æ›´æ–°
            const traitsDiv = document.getElementById('packTraits');
            traitsDiv.innerHTML = '';

            const traits = {};
            gameState.packMembers.forEach(member => {
                if (member.trait) {
                    traits[member.trait] = (traits[member.trait] || 0) + 1;
                }
            });

            // é€šå¸¸ã®æ•µã¨ãƒœã‚¹ã®ç‰¹æ€§ã‚’çµ„ã¿åˆã‚ã›ã¦è¡¨ç¤º
            const allEnemyTypes = [...ENEMY_TYPES, ...BOSS_TYPES];

            Object.entries(traits).forEach(([trait, count]) => {
                const traitBadge = document.createElement('div');
                traitBadge.className = 'trait-badge';
                const traitInfo = allEnemyTypes.find(e => e.trait === trait); // çµåˆãƒªã‚¹ãƒˆã‹ã‚‰ç‰¹æ€§æƒ…å ±ã‚’æ¤œç´¢
                if (traitInfo) {
                    traitBadge.innerHTML = `
                        <span>${traitInfo.icon}</span>
                        <span>${traitInfo.traitName}</span>
                        <span class="trait-count">Ã—${count}</span>
                    `;
                    traitsDiv.appendChild(traitBadge);
                }
            });

            // åˆ¶å¾¡ä¸­ã®ã‚¦ãƒ«ãƒ•è¡¨ç¤ºã‚’æ›´æ–°
            document.getElementById('controlledWolfDisplay').textContent = gameState.controlledWolf === 'mother' ? 'æ¯ã‚¦ãƒ«ãƒ•' : 'ç¾¤ã‚Œ';
        }

        // ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ã«åŸºã¥ã„ã¦ç¾¤ã‚Œã®ç·ä½“åŠ›ã‚’æ›´æ–°
        function updatePackHealth() {
            let totalPackHealth = 0;
            let totalPackMaxHealth = 0;
            gameState.packMembers.forEach(member => {
                totalPackHealth += member.health;
                totalPackMaxHealth += member.maxHealth;
            });
            gameState.packHealth = totalPackHealth;
            gameState.packMaxHealth = totalPackMaxHealth;
        }

        // åˆ¶å¾¡ã™ã‚‹ã‚¦ãƒ«ãƒ•ã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹
        function switchControlledWolf(target) {
            if (gameState.packMembers.length === 0 && target === 'pack') {
                addMessage("ğŸº ç¾¤ã‚ŒãŒã„ãªã„ãŸã‚ã€ç¾¤ã‚Œã‚’æ“ä½œã§ãã¾ã›ã‚“ï¼", "hunt");
                return;
            }
            gameState.controlledWolf = target;
            addMessage(`æ“ä½œå¯¾è±¡ã‚’${target === 'mother' ? 'æ¯ã‚¦ãƒ«ãƒ•' : 'ç¾¤ã‚Œ'}ã«åˆ‡ã‚Šæ›¿ãˆã¾ã—ãŸã€‚`, "level");
            updateControlButtons();
            renderGame(); // å†æç”»ã—ã¦å¼·èª¿è¡¨ç¤ºã‚’æ›´æ–°
        }

        // åˆ¶å¾¡ãƒœã‚¿ãƒ³ã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
        function updateControlButtons() {
            document.getElementById('controlMotherBtn').classList.remove('active');
            document.getElementById('controlPackBtn').classList.remove('active');
            if (gameState.controlledWolf === 'mother') {
                document.getElementById('controlMotherBtn').classList.add('active');
            } else {
                document.getElementById('controlPackBtn').classList.add('active');
            }
        }


        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•
        function move(dx, dy) {
            let activeUnit; // ç¾åœ¨æ“ä½œä¸­ã®ãƒ¦ãƒ‹ãƒƒãƒˆ
            let isMotherControlled = (gameState.controlledWolf === 'mother');

            if (isMotherControlled) {
                activeUnit = gameState.player;
            } else { // 'pack' is controlled
                if (!gameState.pack || gameState.packMembers.length === 0) {
                    addMessage("ğŸº ç¾¤ã‚ŒãŒã„ãªã„ãŸã‚ã€ç§»å‹•ã§ãã¾ã›ã‚“ï¼æ¯ã‚¦ãƒ«ãƒ•ã«åˆ‡ã‚Šæ›¿ãˆã¦ãã ã•ã„ã€‚", "hunt");
                    switchControlledWolf('mother'); // ç¾¤ã‚ŒãŒã„ãªã„å ´åˆã¯æ¯ã‚¦ãƒ«ãƒ•ã«å¼·åˆ¶åˆ‡ã‚Šæ›¿ãˆ
                    return;
                }
                activeUnit = gameState.pack;
            }

            const newX = activeUnit.x + dx;
            const newY = activeUnit.y + dy;

            // ãƒœãƒ¼ãƒ‰ã®å¢ƒç•Œç·šãƒã‚§ãƒƒã‚¯
            if (newX < 0 || newX >= GAME_BOARD_SIZE || newY < 0 || newY >= GAME_BOARD_SIZE) {
                addMessage("ğŸš« ãƒœãƒ¼ãƒ‰ã®ç«¯ã§ã™ï¼", "hunt");
                return;
            }

            const terrain = gameState.grid[newX][newY];
            if (terrain === TERRAIN.WATER || terrain === TERRAIN.MOUNTAIN) {
                addMessage(`ğŸš« ${terrain === TERRAIN.WATER ? 'æ°´' : 'å±±'}ã‚’é€šéã§ãã¾ã›ã‚“ï¼ç ´å£Šãƒœã‚¿ãƒ³ã§ã‚¯ãƒªã‚¢ã—ã¦ãã ã•ã„ã€‚`, "hunt");
                return;
            }

            // æ“ä½œä¸­ã®ãƒ¦ãƒ‹ãƒƒãƒˆåŒå£«ãŒé‡ãªã‚‹ã®ã‚’é˜²ã
            if (isMotherControlled && gameState.pack && newX === gameState.pack.x && newY === gameState.pack.y) {
                addMessage("ğŸš« æ¯ã‚¦ãƒ«ãƒ•ã¯ç¾¤ã‚Œã®ä¸Šã«ç§»å‹•ã§ãã¾ã›ã‚“ã€‚", "hunt");
                return;
            } else if (!isMotherControlled && newX === gameState.player.x && newY === gameState.player.y) {
                addMessage("ğŸš« ç¾¤ã‚Œã¯æ¯ã‚¦ãƒ«ãƒ•ã®ä¸Šã«ç§»å‹•ã§ãã¾ã›ã‚“ã€‚", "hunt");
                return;
            }


            activeUnit.x = newX;
            activeUnit.y = newY;
            gameState.playerMoveCount++;

            // æ•µã®ãƒã‚§ãƒƒã‚¯ï¼ˆæ“ä½œä¸­ã®ãƒ¦ãƒ‹ãƒƒãƒˆãŒç§»å‹•ã—ãŸå ´æ‰€ï¼‰
            const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
            if (enemy) {
                if (isMotherControlled) {
                    hunt(enemy); // æ¯ã‚¦ãƒ«ãƒ•ãŒç›´æ¥ç‹©ã‚‹
                } else {
                    packAttack(enemy); // ç¾¤ã‚ŒãŒç›´æ¥æ”»æ’ƒã™ã‚‹
                }
            }

            // ã‚´ãƒ¼ãƒ«ã«åˆ°é”ã—ãŸã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæ¯ã‚¦ãƒ«ãƒ•ã®ã¿ï¼‰
            if (gameState.player.x === GAME_BOARD_SIZE - 1 && gameState.player.y === GAME_BOARD_SIZE - 1) {
                nextStage();
                return; // ã‚¹ãƒ†ãƒ¼ã‚¸ãŒé€²è¡Œã—ãŸå ´åˆã¯ã“ã“ã§çµ‚äº†
            }

            // æ¯ã‚¦ãƒ«ãƒ•ã®æº€è…¹åº¦æ¸›å°‘ã¨ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆå¸¸ã«æ¯ã‚¦ãƒ«ãƒ•ã®æº€è…¹åº¦ãŒå½±éŸ¿ï¼‰
            gameState.player.hunger = Math.max(0, gameState.player.hunger - 2);
            if (gameState.player.hunger === 0) {
                gameState.player.health -= 5;
                addMessage("ğŸ– æº€è…¹åº¦ä¸è¶³ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸï¼", "hunt");
                if (gameState.player.health <= 0) {
                    gameOver("æ¯ã‚¦ãƒ«ãƒ•ã¯é£¢ãˆæ­»ã«ã—ã¾ã—ãŸï¼");
                    return;
                }
            }

            // è‡ªå‹•è¡Œå‹•ã™ã‚‹å‘³æ–¹ãƒ¦ãƒ‹ãƒƒãƒˆã®ç§»å‹•
            if (gameState.playerMoveCount % 2 === 0) { // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®2è¡Œå‹•ã”ã¨ã«1å›
                autoMoveFriendly();
            }

            // æ•µã®ç§»å‹•
            moveEnemies();
            renderGame();
        }

        // è‡ªå‹•è¡Œå‹•ã™ã‚‹å‘³æ–¹ãƒ¦ãƒ‹ãƒƒãƒˆã®AI
        function autoMoveFriendly() {
            let autoUnit; // è‡ªå‹•è¡Œå‹•ã™ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆ
            let controlledUnit; // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ“ä½œã—ã¦ã„ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆ

            if (gameState.controlledWolf === 'mother') {
                autoUnit = gameState.pack;
                controlledUnit = gameState.player;
            } else { // 'pack' is controlled
                autoUnit = gameState.player;
                controlledUnit = gameState.pack;
            }

            if (!autoUnit || (autoUnit === gameState.pack && gameState.packMembers.length === 0)) {
                return; // è‡ªå‹•è¡Œå‹•ã™ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
            }

            let targetX = autoUnit.x;
            let targetY = autoUnit.y;
            let foundTarget = false;

            // 1. æœ€ã‚‚è¿‘ã„æ•µã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ
            let nearestEnemy = null;
            let minDistance = Infinity;
            gameState.enemies.forEach(enemy => {
                const distance = Math.abs(enemy.x - autoUnit.x) + Math.abs(enemy.y - autoUnit.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy && minDistance <= 5) { // è¦–ç•Œç¯„å›²å†…ã®æ•µãŒã„ã‚Œã°
                targetX = nearestEnemy.x;
                targetY = nearestEnemy.y;
                foundTarget = true;
            }
            // 2. ã‚´ãƒ¼ãƒ«ã‚’ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆæ¯ã‚¦ãƒ«ãƒ•ãŒè‡ªå‹•è¡Œå‹•ã®å ´åˆã®ã¿ï¼‰
            else if (autoUnit === gameState.player && (autoUnit.x !== GAME_BOARD_SIZE - 1 || autoUnit.y !== GAME_BOARD_SIZE - 1)) {
                targetX = GAME_BOARD_SIZE - 1;
                targetY = GAME_BOARD_SIZE - 1;
                foundTarget = true;
            }
            // 3. æ“ä½œä¸­ã®ãƒ¦ãƒ‹ãƒƒãƒˆã«è¿½å¾“
            else {
                targetX = controlledUnit.x;
                targetY = controlledUnit.y;
                foundTarget = true;
            }

            if (!foundTarget) return; // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒè¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„

            const dx = Math.sign(targetX - autoUnit.x);
            const dy = Math.sign(targetY - autoUnit.y);

            let newX = autoUnit.x;
            let newY = autoUnit.y;

            // ç§»å‹•ãƒ­ã‚¸ãƒƒã‚¯ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¿‘ã¥ãã‚ˆã†ã«å‹•ã
            // ç¸¦æ¨ªç§»å‹•ã‚’å„ªå…ˆã—ã€éšœå®³ç‰©ãŒã‚ã‚Œã°æ–œã‚ã‚‚è©¦ã™
            let moved = false;
            if (dx !== 0 && isValidAutoMove(autoUnit, autoUnit.x + dx, autoUnit.y, controlledUnit)) {
                newX += dx;
                moved = true;
            } else if (dy !== 0 && isValidAutoMove(autoUnit, autoUnit.x, autoUnit.y + dy, controlledUnit)) {
                newY += dy;
                moved = true;
            } else if (dx !== 0 && dy !== 0 && isValidAutoMove(autoUnit, autoUnit.x + dx, autoUnit.y + dy, controlledUnit)) {
                // ç¸¦æ¨ªãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆã€æ–œã‚ç§»å‹•ã‚’è©¦ã™
                newX += dx;
                newY += dy;
                moved = true;
            }

            if (moved) {
                autoUnit.x = newX;
                autoUnit.y = newY;

                // æ•µã¨æ¥è§¦ã—ãŸå ´åˆ
                const encounteredEnemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
                if (encounteredEnemy) {
                    if (autoUnit === gameState.player) {
                        hunt(encounteredEnemy); // æ¯ã‚¦ãƒ«ãƒ•ãŒè‡ªå‹•ã§ç‹©ã‚‹
                    } else {
                        packAttack(encounteredEnemy); // ç¾¤ã‚ŒãŒè‡ªå‹•ã§æ”»æ’ƒã™ã‚‹
                    }
                }
            }
        }

        // è‡ªå‹•è¡Œå‹•ãƒ¦ãƒ‹ãƒƒãƒˆã®ç§»å‹•ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
        function isValidAutoMove(autoUnit, x, y, controlledUnit) {
            if (x < 0 || x >= GAME_BOARD_SIZE || y < 0 || y >= GAME_BOARD_SIZE) return false; // ãƒœãƒ¼ãƒ‰å¤–

            const terrain = gameState.grid[x][y];
            if (terrain === TERRAIN.WATER || terrain === TERRAIN.MOUNTAIN) return false; // é€šè¡Œä¸èƒ½ãªåœ°å½¢

            // æ“ä½œä¸­ã®ãƒ¦ãƒ‹ãƒƒãƒˆã®ä¸Šã«ç§»å‹•ã—ãªã„
            if (x === controlledUnit.x && y === controlledUnit.y) return false;

            // ä»–ã®æ•µã®ä¸Šã«ç§»å‹•ã—ãªã„
            if (gameState.enemies.some(e => e.x === x && e.y === y)) return false;

            return true;
        }

        // æ•µã‚’ç‹©ã‚‹ï¼ˆæ¯ã‚¦ãƒ«ãƒ•ã®è¡Œå‹•ï¼‰
        function hunt(enemy) {
            const playerDamage = gameState.player.attack + Math.floor(Math.random() * (10 + gameState.player.level)); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ€ãƒ¡ãƒ¼ã‚¸ã¯ãƒ¬ãƒ™ãƒ«ã¨ã¨ã‚‚ã«ã‚¹ã‚±ãƒ¼ãƒ«
            enemy.health -= playerDamage;

            addMessage(`ğŸ¦· ã‚ãªãŸã¯${enemy.name}ã«${playerDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸï¼`, "hunt");

            if (enemy.health <= 0) {
                // æ•µã‚’é£Ÿã¹ã‚‹
                gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 40);
                gameState.player.exp += enemy.exp;

                addMessage(`ğŸ– ã‚ãªãŸã¯${enemy.name}ã‚’é£Ÿã¹ã¾ã—ãŸï¼æº€è…¹åº¦ãŒå›å¾©ã—ã€${enemy.exp}çµŒé¨“å€¤ã‚’ç²å¾—ï¼`, "pack");

                // ãƒœã‚¹ã§ãªã‘ã‚Œã°ã€ç‰¹æ€§ã‚’æŒã¤æ–°ã—ã„ã‚¦ãƒ«ãƒ•ã‚’ç”Ÿæˆ
                if (!enemy.isBoss) {
                    addMessage(`âœ¨ '${enemy.traitName}'ã®ç‰¹æ€§ã‚’æŒã¤æ–°ã—ã„å­ç‹¼ãŒç”Ÿã¾ã‚Œã¾ã—ãŸï¼`, "pack");
                    createWolfWithTrait(enemy);
                } else {
                    addMessage(`ğŸ† æã‚‹ã¹ã${enemy.name}ã‚’å€’ã—ã¾ã—ãŸï¼`, "level");
                }

                // æ•µã‚’å‰Šé™¤
                gameState.enemies = gameState.enemies.filter(e => e !== enemy);

                // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
                checkLevelUp();
            } else {
                // æ•µã®åæ’ƒ
                const enemyDamage = enemy.attack + Math.floor(Math.random() * 10);
                gameState.player.health -= enemyDamage;
                addMessage(`ğŸ’¥ ${enemy.name}ãŒåæ’ƒï¼${enemyDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸã€‚`, "hunt");

                if (gameState.player.health <= 0) {
                    gameOver("æ¯ã‚¦ãƒ«ãƒ•ã¯æ•µã«å€’ã•ã‚Œã¾ã—ãŸï¼");
                    return; // ã•ã‚‰ãªã‚‹ã‚²ãƒ¼ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
                }
            }
            renderGame(); // HPãƒãƒ¼ã®å³æ™‚æ›´æ–°ã®ãŸã‚ã«ç‹©çŒŸå¾Œã«å†æç”»
        }

        // ç¶™æ‰¿ã•ã‚ŒãŸç‰¹æ€§ã‚’æŒã¤ã‚¦ãƒ«ãƒ•ã‚’ç”Ÿæˆ
        function createWolfWithTrait(enemy) {
            const baseHealth = 50 + gameState.player.level * 5; // åŸºæœ¬ä½“åŠ›ã¯ã‚¹ã‚±ãƒ¼ãƒ«
            const baseAttack = 15 + gameState.player.level * 2; // åŸºæœ¬æ”»æ’ƒåŠ›ã¯ã‚¹ã‚±ãƒ¼ãƒ«

            const newWolf = {
                health: baseHealth,
                maxHealth: baseHealth,
                attack: baseAttack,
                trait: enemy.trait,
                icon: enemy.icon,
                id: Date.now() + Math.random()
            };

            // ç‰¹æ€§ãƒœãƒ¼ãƒŠã‚¹ã‚’é©ç”¨
            switch (enemy.trait) {
                case 'speed':
                    newWolf.attack += 5; // æ•æ·æ€§ã‚¦ãƒ«ãƒ•ã¯ã‚ãšã‹ãªæ”»æ’ƒåŠ›ãƒœãƒ¼ãƒŠã‚¹
                    break;
                case 'health':
                    newWolf.health += 20;
                    newWolf.maxHealth += 20;
                    break;
                case 'attack':
                    newWolf.attack += 10;
                    break;
                case 'defense':
                    newWolf.health += 10;
                    newWolf.maxHealth += 10;
                    newWolf.attack += 2; // é˜²å¾¡ç”¨ã«ã¯ã‚ãšã‹ãªæ”»æ’ƒåŠ›
                    break;
                case 'vision':
                    // è¦–åŠ›ã¯å—å‹•çš„ãªãƒœãƒ¼ãƒŠã‚¹ã‚„ç¾¤ã‚Œã®è¡Œå‹•ç¯„å›²ã‚’æ‹¡å¤§ã™ã‚‹ã‹ã‚‚ã—ã‚Œãªã„ï¼ˆä»Šã®ã¨ã“ã‚ç›´æ¥çš„ãªã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãªã—ï¼‰
                    break;
            }

            gameState.packMembers.push(newWolf);

            // ç¾¤ã‚Œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
            if (!gameState.pack) {
                // ç¾¤ã‚Œã®åˆæœŸä½ç½®ã¯æ¯ã‚¦ãƒ«ãƒ•ã®éš£ã«è¨­å®šï¼ˆå­˜åœ¨ã—ãªã„å ´åˆï¼‰
                // ãŸã¨ãˆã°ã€æ¯ã‚¦ãƒ«ãƒ•ãŒ(0,0)ãªã‚‰ç¾¤ã‚Œã¯(0,1)
                const px = gameState.player.x;
                const py = gameState.player.y;
                let packX = px;
                let packY = py + 1;

                // ã‚‚ã—(0,1)ãŒãƒœãƒ¼ãƒ‰å¤–ãªã‚‰(1,0)ã‚’è©¦ã™
                if (packY >= GAME_BOARD_SIZE) {
                    packX = px + 1;
                    packY = py;
                }
                // ãã‚Œã‚‚ãƒœãƒ¼ãƒ‰å¤–ãªã‚‰æ¯ã‚¦ãƒ«ãƒ•ã¨åŒã˜ä½ç½®ã«ä¸€æ™‚çš„ã«è¨­å®šã—ã€æ¬¡ã§ãšã‚‰ã™
                if (packX >= GAME_BOARD_SIZE) {
                    packX = px;
                    packY = py;
                }

                gameState.pack = {
                    x: packX,
                    y: packY
                };
            }
            updatePackHealth(); // ç¾¤ã‚Œã®ç·ä½“åŠ›ã‚’æ›´æ–°
        }

        // ç¾¤ã‚Œã®ç§»å‹• (ç¾åœ¨ä½¿ã‚ã‚Œã¦ã„ãªã„ãŒã€å°†æ¥çš„ãªæ‹¡å¼µã®ãŸã‚ã«æ®‹ã™ã‹å‰Šé™¤ã™ã‚‹)
        // ä»Šå›ã®å¤‰æ›´ã§ã“ã®é–¢æ•°ã¯autoMoveFriendlyã«çµ±åˆã•ã‚Œã¾ã™
        /*
        function movePack() {
            if (!gameState.pack || gameState.packMembers.length === 0) return;

            // Find nearest enemy within vision range
            let nearestEnemy = null;
            let minDistance = Infinity;

            // Pack vision range - influenced by 'vision' trait
            const visionWolves = gameState.packMembers.filter(m => m.trait === 'vision').length;
            const visionRange = 4 + (visionWolves > 0 ? visionWolves : 0); // 1 extra range per vision wolf

            gameState.enemies.forEach(enemy => {
                const distance = Math.abs(enemy.x - gameState.pack.x) + Math.abs(enemy.y - gameState.pack.y);
                if (distance <= visionRange && distance < minDistance) {
                    minDistance = distance;
                    nearestEnemy = enemy;
                }
            });

            let targetX, targetY;
            let targetType = null;

            if (nearestEnemy) {
                targetX = nearestEnemy.x;
                targetY = nearestEnemy.y;
                targetType = 'enemy';
            } else {
                // If no enemy in sight, follow player
                targetX = gameState.player.x;
                targetY = gameState.player.y;
                targetType = 'player';
            }

            // Determine move direction towards target
            const dx = Math.sign(targetX - gameState.pack.x);
            const dy = Math.sign(targetY - gameState.pack.y);

            let newX = gameState.pack.x;
            let newY = gameState.pack.y;

            // Prefer moving towards the target's row/column
            if (dx !== 0 && isValidPackMove(gameState.pack.x + dx, gameState.pack.y)) {
                newX += dx;
            } else if (dy !== 0 && isValidPackMove(gameState.pack.x, gameState.pack.y + dy)) {
                newY += dy;
            } else if (dx !== 0 && isValidPackMove(gameState.pack.x + dx, gameState.pack.y + dy)) { // Diagonal if straight is blocked
                 newX += dx;
                 newY += dy;
            } else if (dy !== 0 && isValidPackMove(gameState.pack.x + dx, gameState.pack.y + dy)) { // Diagonal if straight is blocked
                 newX += dx;
                 newY += dy;
            }


            if (newX !== gameState.pack.x || newY !== gameState.pack.y) {
                gameState.pack.x = newX;
                gameState.pack.y = newY;

                // Attack if adjacent or on the same tile as enemy after move
                if (targetType === 'enemy' && nearestEnemy &&
                    ((gameState.pack.x === nearestEnemy.x && Math.abs(gameState.pack.y - nearestEnemy.y) <= 1) ||
                     (gameState.pack.y === nearestEnemy.y && Math.abs(gameState.pack.x - nearestEnemy.x) <= 1)))
                {
                    packAttack(nearestEnemy);
                }
            }
        }
        */
        // ç¾¤ã‚Œã®ç§»å‹•ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚„é€šè¡Œä¸èƒ½ãªåœ°å½¢ã®ä¸Šã«ã¯ç§»å‹•ã§ããªã„ï¼‰
        function isValidPackMove(x, y) {
            return x >= 0 && x < GAME_BOARD_SIZE && y >= 0 && y < GAME_BOARD_SIZE &&
                   gameState.grid[x][y] !== TERRAIN.WATER &&
                   gameState.grid[x][y] !== TERRAIN.MOUNTAIN &&
                   !(gameState.player.x === x && gameState.player.y === y); // ç¾¤ã‚Œã¯æ¯ã‚¦ãƒ«ãƒ•ã®ä¸Šã«ã¯ç§»å‹•ã§ããªã„
        }

        // ç¾¤ã‚ŒãŒæ•µã‚’æ”»æ’ƒ
        function packAttack(enemy) {
            if (gameState.packMembers.length === 0) return;

            let totalDamage = 0;
            let defenseBonus = 0; // ç¾åœ¨æœªä½¿ç”¨ã ãŒã€ç‰¹æ€§ã«ã‚ˆã£ã¦è¿½åŠ å¯èƒ½

            gameState.packMembers.forEach(member => {
                totalDamage += member.attack;
                if (member.trait === 'defense') {
                    defenseBonus += 1; // å„é˜²å¾¡ã‚¦ãƒ«ãƒ•ã¯è¢«ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æ¸›å°‘ã•ã›ã‚‹
                }
            });

            // ç¾¤ã‚Œã®æ•°ã«å¿œã˜ãŸãƒ€ãƒ¡ãƒ¼ã‚¸ãƒœãƒ¼ãƒŠã‚¹
            totalDamage += Math.floor(gameState.packMembers.length * 2);

            // æ•µã®é˜²å¾¡ï¼ˆã‚‚ã—ã‚ã‚Œã°ï¼‰ã‚„ç‰¹æ®Šç‰¹æ€§ã‚’é©ç”¨
            if (enemy.trait === 'defense') { // ä¾‹ï¼šã‚¯ãƒã¯ã€Œé˜²å¾¡ã€ç‰¹æ€§ã‚’æŒã¤
                totalDamage = Math.max(1, totalDamage - (enemy.attack / 2)); // æ•µã®æ”»æ’ƒåŠ›ã®åŠåˆ†ã§ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æ¸›å°‘
            }
            // ãƒœã‚¹ã®å ´åˆã€ãƒ€ãƒ¡ãƒ¼ã‚¸æ¸›å°‘ã‚’ã‚¹ã‚±ãƒ¼ãƒ«
            if (enemy.isBoss) {
                totalDamage = Math.max(1, totalDamage - (enemy.maxHealth / 20)); // ãƒœã‚¹ã¯ã‚ˆã‚Šé«˜ã„åŸºæœ¬é˜²å¾¡åŠ›ã‚’æŒã¤
            }


            enemy.health -= totalDamage;
            addMessage(`ğŸº ã‚ãªãŸã®ç¾¤ã‚Œï¼ˆ${gameState.packMembers.length}é ­ï¼‰ã¯${enemy.name}ã«${totalDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸï¼`, "pack");

            if (enemy.health <= 0) {
                // æ¯ã«çµŒé¨“å€¤ã‚’ä¸ãˆã‚‹
                gameState.player.exp += Math.floor(enemy.exp * 0.8);
                gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                addMessage(`ğŸº ã‚ãªãŸã®ç¾¤ã‚Œã¯${enemy.name}ã‚’å€’ã—ã¾ã—ãŸï¼æ¯ã¯${Math.floor(enemy.exp * 0.8)}çµŒé¨“å€¤ã‚’ç²å¾—ã€‚`, "pack");

                // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
                checkLevelUp();

                // é£Ÿäº‹ã‹ã‚‰ç¾¤ã‚ŒãŒã„ãã‚‰ã‹ä½“åŠ›ã‚’å›å¾© - ç”Ÿå­˜ã—ã¦ã„ã‚‹ãƒ¡ãƒ³ãƒãƒ¼ã«åˆ†é…
                const healAmount = 5 + Math.floor(enemy.exp / 10);
                gameState.packMembers.forEach(member => {
                    member.health = Math.min(member.maxHealth, member.health + healAmount);
                });
                updatePackHealth(); // å›å¾©å¾Œã«ç¾¤ã‚Œã®ç·ä½“åŠ›ã‚’å†è¨ˆç®—
            } else {
                // å€‹ã€…ã®ã‚¦ãƒ«ãƒ•ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’åˆ†é…ã—ã€æ¶ˆè€—ã‚’åæ˜ 
                const individualDamage = Math.ceil(totalDamage / gameState.packMembers.length); // æ”»æ’ƒã§å—ã‘ãŸãƒ€ãƒ¡ãƒ¼ã‚¸ã«å¿œã˜ã¦
                gameState.packMembers.forEach(member => {
                    member.health = Math.max(0, member.health - individualDamage); // å€‹ã€…ã®ãƒ¡ãƒ³ãƒãƒ¼ã®ä½“åŠ›ã‚’æ¸›ã‚‰ã™
                });
                updatePackHealth(); // ãƒ€ãƒ¡ãƒ¼ã‚¸å¾Œã«ç¾¤ã‚Œã®ç·ä½“åŠ›ã‚’æ›´æ–°

                // ä½“åŠ›ãŒ0ä»¥ä¸‹ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’å‰Šé™¤
                let initialPackCount = gameState.packMembers.length;
                gameState.packMembers = gameState.packMembers.filter(member => member.health > 0);
                let lostWolves = initialPackCount - gameState.packMembers.length;

                if (lostWolves > 0) {
                    addMessage(`ğŸ’€ ${lostWolves}é ­ã®ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ãŒæˆ¦é—˜ã§å€’ã‚Œã¾ã—ãŸ...`, "hunt");
                }

                // ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ãªããªã£ãŸã‚‰ç¾¤ã‚Œã‚’è§£æ•£
                if (gameState.packMembers.length === 0) {
                    gameState.pack = null;
                    addMessage("ğŸ¾ ã‚ãªãŸã®ç¾¤ã‚Œã¯è§£æ•£ã—ã¾ã—ãŸï¼", "hunt");
                    if (gameState.controlledWolf === 'pack') {
                        switchControlledWolf('mother'); // æ“ä½œä¸­ã®ç¾¤ã‚ŒãŒãªããªã£ãŸã‚‰æ¯ã‚¦ãƒ«ãƒ•ã«åˆ‡ã‚Šæ›¿ãˆ
                    }
                }
            }
        }


        // æ•µã®ç§»å‹•
        function moveEnemies() {
            gameState.enemies.forEach(enemy => {
                enemy.moveCounter++;

                // ã‚¹ãƒ”ãƒ¼ãƒ‰ã«åŸºã¥ã„ã¦ç§»å‹•ï¼ˆã‚¹ãƒ”ãƒ¼ãƒ‰2ã¯æ¯ã‚¿ãƒ¼ãƒ³ç§»å‹•ã€ã‚¹ãƒ”ãƒ¼ãƒ‰1ã¯éš”ã‚¿ãƒ¼ãƒ³ç§»å‹•ï¼‰
                const moveFrequency = enemy.speed === 2 ? 1 : 2;
                if (enemy.moveCounter % moveFrequency !== 0) return;

                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¾ãŸã¯ç¾¤ã‚Œï¼‰ã‚’è¦‹ã¤ã‘ã‚‹
                let targetX = gameState.player.x;
                let targetY = gameState.player.y;
                let targetType = 'player';

                // ç¾¤ã‚ŒãŒå­˜åœ¨ã—ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ˆã‚Šè¿‘ã„ã‹ãƒã‚§ãƒƒã‚¯
                if (gameState.pack && gameState.packMembers.length > 0) {
                    const packDistance = Math.abs(gameState.pack.x - enemy.x) + Math.abs(gameState.pack.y - enemy.y);
                    const playerDistance = Math.abs(gameState.player.x - enemy.x) + Math.abs(gameState.player.y - enemy.y);

                    if (packDistance <= playerDistance) { // ç¾¤ã‚ŒãŒè¿‘ã„ã‹åŒã˜è·é›¢ã§ã‚ã‚Œã°ã€ç¾¤ã‚Œã‚’æ”»æ’ƒå„ªå…ˆ
                        targetX = gameState.pack.x;
                        targetY = gameState.pack.y;
                        targetType = 'pack';
                    }
                }

                const distance = Math.abs(targetX - enemy.x) + Math.abs(targetY - enemy.y);

                // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãŒæ”»æ’ƒç¯„å›²å†…ã«ã‚ã‚‹å ´åˆã®ã¿ç§»å‹•ï¼ˆã¾ãŸã¯éš£æ¥ã—ã¦ã„ãªã„å ´åˆã¯è¿½è·¡ï¼‰
                if (distance <= (enemy.isBoss ? 8 : 5)) { // ãƒœã‚¹ã¯ã‚ˆã‚Šåºƒã„ã‚¿ãƒ¼ã‚²ãƒƒãƒˆç¯„å›²ã‚’æŒã¤
                    const dx = Math.sign(targetX - enemy.x);
                    const dy = Math.sign(targetY - enemy.y);

                    let newX = enemy.x;
                    let newY = enemy.y;

                    // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å‘ã‹ã£ã¦ç¸¦æ¨ªã«ç§»å‹•ã‚’å„ªå…ˆ
                    if (dx !== 0 && isValidEnemyMove(enemy.x + dx, enemy.y, enemy)) {
                        newX += dx;
                    } else if (dy !== 0 && isValidEnemyMove(enemy.x, enemy.y + dy, enemy)) {
                        newY += dy;
                    } else if (isValidEnemyMove(enemy.x + dx, enemy.y + dy, enemy)) { // ç›´é€²ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆã€æ–œã‚ã‚’è©¦ã™
                        newX += dx;
                        newY += dy;
                    }

                    if (newX !== enemy.x || newY !== enemy.y) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }

                    // ç§»å‹•å¾Œã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«éš£æ¥ã—ã¦ã„ã‚‹å ´åˆï¼ˆã¾ãŸã¯åŒã˜ã‚¿ã‚¤ãƒ«ã«ç§»å‹•ã—ãŸå ´åˆï¼‰æ”»æ’ƒ
                    if ((enemy.x === targetX && Math.abs(enemy.y - targetY) <= 1) ||
                        (enemy.y === targetY && Math.abs(enemy.x - targetX) <= 1))
                    {
                        if (targetType === 'player') {
                            enemyAttackPlayer(enemy);
                        } else if (targetType === 'pack') {
                            enemyAttackPack(enemy);
                        }
                    }
                }
            });
        }

        // æ•µã®ç§»å‹•ãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
        function isValidEnemyMove(x, y, currentEnemy) {
            return x >= 0 && x < GAME_BOARD_SIZE && y >= 0 && y < GAME_BOARD_SIZE &&
                   gameState.grid[x][y] !== TERRAIN.WATER &&
                   gameState.grid[x][y] !== TERRAIN.MOUNTAIN &&
                   !(gameState.player.x === x && gameState.player.y === y) && // æ•µã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸Šã«ç§»å‹•ã§ããªã„
                   !(gameState.pack && gameState.pack.x === x && gameState.pack.y === y) && // æ•µã¯ç¾¤ã‚Œã®ä¸Šã«ç§»å‹•ã§ããªã„
                   !gameState.enemies.some(e => e !== currentEnemy && e.x === x && e.y === y); // æ•µã¯ä»–ã®æ•µã®ä¸Šã«ç§»å‹•ã§ããªã„
        }

        // æ•µãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ”»æ’ƒ
        function enemyAttackPlayer(enemy) {
            const damage = enemy.attack + Math.floor(Math.random() * 10);
            gameState.player.health -= damage;
            addMessage(`ğŸ’¥ ${enemy.name}ãŒã‚ãªãŸã‚’æ”»æ’ƒï¼${damage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ã¾ã—ãŸã€‚`, "hunt");

            if (gameState.player.health <= 0) {
                gameOver("æ¯ã‚¦ãƒ«ãƒ•ã¯æ•µã«å€’ã•ã‚Œã¾ã—ãŸï¼");
                return; // ã•ã‚‰ãªã‚‹ã‚²ãƒ¼ãƒ ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
            }
        }

        // æ•µãŒç¾¤ã‚Œã‚’æ”»æ’ƒ
        function enemyAttackPack(enemy) {
            if (gameState.packMembers.length === 0) return;

            const damage = enemy.attack;
            let actualDamage = damage;

            // ç¾¤ã‚Œãƒ¡ãƒ³ãƒãƒ¼ã‹ã‚‰ã®é˜²å¾¡è¨ˆç®—
            const defenseWolves = gameState.packMembers.filter(m => m.trait === 'defense').length;
            if (defenseWolves > 0) {
                actualDamage = Math.max(1, damage - (defenseWolves * 5)); // å„é˜²å¾¡ã‚¦ãƒ«ãƒ•ã¯å—ã‘ã‚‹ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’æ¸›å°‘ã•ã›ã‚‹
            }

            gameState.packHealth -= actualDamage; // ç¾¤ã‚Œã®ç·ä½“åŠ›ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
            addMessage(`ğŸ’¥ ${enemy.name}ãŒã‚ãªãŸã®ç¾¤ã‚Œã‚’æ”»æ’ƒï¼${actualDamage}ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆã¾ã—ãŸã€‚`, "hunt");

            // ç¾¤ã‚Œã®ä½“åŠ›ãŒé–¾å€¤ã‚’ä¸‹å›ã‚‹ã¨ã€ä¸€éƒ¨ã®ã‚¦ãƒ«ãƒ•ãŒå¤±ã‚ã‚Œã‚‹å¯èƒ½æ€§
            if (gameState.packHealth <= 0) {
                let initialPackCount = gameState.packMembers.length;
                let lostWolves = 0;

                // ä½“åŠ›ãŒæ­£ã«ãªã‚‹ã‹ã€ã‚¦ãƒ«ãƒ•ãŒã„ãªããªã‚‹ã¾ã§æœ€ã‚‚å¼±ã„ã‚¦ãƒ«ãƒ•ã‹ã‚‰å‰Šé™¤
                gameState.packMembers.sort((a, b) => (a.health + a.attack) - (b.health + b.attack)); // å…¨ä½“çš„ãªå¼±ã•ã§ã‚½ãƒ¼ãƒˆ
                while (gameState.packHealth <= 0 && gameState.packMembers.length > 0) {
                    gameState.packMembers.pop(); // ã‚¦ãƒ«ãƒ•ã‚’å‰Šé™¤
                    lostWolves++;
                    // ã‚¦ãƒ«ãƒ•ã‚’å‰Šé™¤ã™ã‚‹ã“ã¨ã§ã€ãã®ã‚¦ãƒ«ãƒ•ã®æœ€å¤§ä½“åŠ›è²¢çŒ®ãŒãªããªã‚‹ãŸã‚ã€ç¾¤ã‚Œã®ä½“åŠ›ãŒåŠ¹æœçš„ã«ã€Œå›å¾©ã€ã•ã‚Œã‚‹
                    updatePackHealth();
                }

                if (lostWolves > 0) {
                    addMessage(`ğŸ’€ ${lostWolves}é ­ã®ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ãŒæˆ¦é—˜ã§å€’ã‚Œã¾ã—ãŸ...`, "hunt");
                }

                // ãƒ¡ãƒ³ãƒãƒ¼ãŒã„ãªããªã£ãŸã‚‰ç¾¤ã‚Œã‚’è§£æ•£
                if (gameState.packMembers.length === 0) {
                    gameState.pack = null;
                    addMessage("ğŸ¾ ã‚ãªãŸã®ç¾¤ã‚Œã¯è§£æ•£ã—ã¾ã—ãŸï¼", "hunt");
                    if (gameState.controlledWolf === 'pack') {
                        switchControlledWolf('mother'); // æ“ä½œä¸­ã®ç¾¤ã‚ŒãŒãªããªã£ãŸã‚‰æ¯ã‚¦ãƒ«ãƒ•ã«åˆ‡ã‚Šæ›¿ãˆ
                    }
                }
            } else {
                // å€‹ã€…ã®ã‚¦ãƒ«ãƒ•ã«ãƒ€ãƒ¡ãƒ¼ã‚¸ã®ä¸€éƒ¨ã‚’åˆ†é…ã—ã€æ¶ˆè€—ã‚’åæ˜ 
                const individualDamage = Math.ceil(actualDamage / gameState.packMembers.length);
                gameState.packMembers.forEach(member => {
                    member.health = Math.max(0, member.health - individualDamage);
                });
            }
            updatePackHealth(); // å¤‰æ›´å¾Œã«å¸¸ã«ç¾¤ã‚Œã®ä½“åŠ›ã‚’æ›´æ–°
        }

        // é å ãˆ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ç¾¤ã‚Œã‚’å›å¾©
        function howl() {
            if (gameState.player.hunger >= 20) {
                gameState.player.hunger -= 20;

                const healAmount = 20 + gameState.player.level * 5;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);

                // å…¨ã¦ã®ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’å›å¾©
                let healedCount = 0;
                gameState.packMembers.forEach(member => {
                    if (member.health < member.maxHealth) {
                        member.health = Math.min(member.maxHealth, member.health + healAmount);
                        healedCount++;
                    }
                });

                updatePackHealth(); // å›å¾©å¾Œã«ç¾¤ã‚Œã®ç·ä½“åŠ›ã‚’å†è¨ˆç®—

                addMessage(`ğŸŒ™ ã‚ãªãŸã¯é å ãˆã‚’ã—ã¾ã—ãŸï¼æ¯ã¨${healedCount}é ­ã®ç¾¤ã‚Œã®ãƒ¡ãƒ³ãƒãƒ¼ãŒ${healAmount}HPå›å¾©ï¼`, "pack");
                renderGame();
            } else {
                addMessage("ğŸš« ç©ºè…¹ã™ãã¦é å ãˆã§ãã¾ã›ã‚“ï¼", "hunt");
            }
        }

        // éšœå®³ç‰©ã‚’ç ´å£Š
        function destroyObstacle() {
            if (gameState.player.level < 3) {
                addMessage("ğŸš« éšœå®³ç‰©ã‚’ç ´å£Šã™ã‚‹ã«ã¯ãƒ¬ãƒ™ãƒ«3ä»¥ä¸ŠãŒå¿…è¦ã§ã™ï¼", "hunt");
                return;
            }
            // æ¯ã‚¦ãƒ«ãƒ•ãŒç¾åœ¨æ“ä½œã—ã¦ã„ã‚‹ãƒ¦ãƒ‹ãƒƒãƒˆã§ã¯ãªã„å ´åˆã€ã‚¹ã‚­ãƒ«ã‚’ä½¿ç”¨ã§ããªã„
            if (gameState.controlledWolf !== 'mother') {
                addMessage("ğŸš« ã“ã®ã‚¹ã‚­ãƒ«ã¯æ¯ã‚¦ãƒ«ãƒ•ã®ã¿ãŒä½¿ç”¨ã§ãã¾ã™ï¼", "hunt");
                return;
            }


            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let destroyed = false;

            directions.forEach(([dx, dy]) => {
                const x = gameState.player.x + dx;
                const y = gameState.player.y + dy;

                if (x >= 0 && x < GAME_BOARD_SIZE && y >= 0 && y < GAME_BOARD_SIZE) {
                    if (gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN) {
                        gameState.grid[x][y] = TERRAIN.GRASS;
                        destroyed = true;
                    }
                }
            });

            if (destroyed) {
                addMessage("ğŸ’¥ éšœå®³ç‰©ã‚’ç ´å£Šã—ã¾ã—ãŸï¼", "level");
                gameState.player.hunger -= 10;
                renderGame();
            } else {
                addMessage("ğŸš« å‘¨å›²ã«ç ´å£Šå¯èƒ½ãªéšœå®³ç‰©ã¯ã‚ã‚Šã¾ã›ã‚“ï¼", "hunt");
            }
        }

        // ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã‚’ãƒã‚§ãƒƒã‚¯
        function checkLevelUp() {
            const requiredExp = gameState.player.level * 100;
            if (gameState.player.exp >= requiredExp) {
                gameState.player.level++;
                gameState.player.exp = gameState.player.exp - requiredExp; // ä½™å‰°çµŒé¨“å€¤ã‚’ç¹°ã‚Šè¶Šã—
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.maxHunger += 20;
                gameState.player.hunger = gameState.player.maxHunger;
                gameState.player.attack += 10;

                addMessage(`ğŸŒŸ ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ï¼ã‚ãªãŸã¯ãƒ¬ãƒ™ãƒ«${gameState.player.level}ã«ãªã‚Šã¾ã—ãŸï¼`, "level");

                if (gameState.player.level === 3) {
                    addMessage("ğŸ’ª ã“ã‚Œã§éšœå®³ç‰©ç ´å£Šã‚¹ã‚­ãƒ«ãŒä½¿ãˆã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸï¼", "level");
                }
            }
        }

        // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
        function gameOver(message) {
            gameState.player.health = 0; // HPãŒã‚¼ãƒ­ã§ã‚ã‚‹ã“ã¨ã‚’ç¢ºèª
            addMessage(`ğŸ’€ ${message} ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ï¼`, "hunt");
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverModal').style.display = 'flex'; // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        }

        // æ¬¡ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã¸
        function nextStage() {
            if (gameState.stage >= MAX_STAGE) {
                // ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼
                addMessage("ğŸ‰ å…¨ã¦ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’åˆ¶è¦‡ã—ã¾ã—ãŸï¼ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ï¼", "level");
                document.getElementById('gameOverMessage').textContent = "ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ã‚ãªãŸã¯ç¾¤ã‚Œã‚’ç‡ã„ã¦æœ€å¼·ã®åœ°ã«å›è‡¨ã—ã¾ã—ãŸï¼";
                document.getElementById('gameOverModal').style.display = 'flex';
                document.getElementById('gameOverModal').querySelector('h2').textContent = "å‹åˆ©ï¼";
                document.getElementById('gameOverModal').querySelector('button').textContent = "ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤";
                return;
            }

            gameState.stage++;
            gameState.player.x = 0;
            gameState.player.y = 0;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.hunger = gameState.player.maxHunger;
            gameState.playerMoveCount = 0; // ç§»å‹•ã‚«ã‚¦ãƒ³ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ

            addMessage(`ğŸ‰ ã‚¹ãƒ†ãƒ¼ã‚¸${gameState.stage}ã¸é€²è¡Œï¼`, "level");
            addMessage("ğŸ’ª ä½“åŠ›ã¨æº€è…¹åº¦ãŒå®Œå…¨ã«å›å¾©ã—ã¾ã—ãŸï¼", "pack");

            // ç¾¤ã‚Œã‚’é–‹å§‹ä½ç½®ã¸ç§»å‹•ã•ã›ã€å›å¾©
            if (gameState.pack) {
                gameState.pack.x = 1;
                gameState.pack.y = 1;

                // å…¨ã¦ã®ç¾¤ã‚Œãƒ¡ãƒ³ãƒãƒ¼ã‚’å…¨å›å¾©
                gameState.packMembers.forEach(member => {
                    member.health = member.maxHealth;
                });
                updatePackHealth(); // å›å¾©å¾Œã«ç¾¤ã‚Œã®ç·ä½“åŠ›ã‚’å†è¨ˆç®—
            }

            generateTerrain();
            generateEnemies(); // æ–°ã—ã„ã‚¹ãƒ†ãƒ¼ã‚¸ã®ãŸã‚ã«æ–°ã—ã„æ•µã‚’ç”Ÿæˆ
            renderGame();
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒ­ã‚°ã«è¿½åŠ 
        function addMessage(text, type = "") {
            const messages = document.getElementById('messages');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            messages.appendChild(message);
            messages.scrollTop = messages.scrollHeight; // è‡ªå‹•çš„ã«ä¸‹ã¸ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«

            // æœ€æ–°ã®10ä»¶ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã¿ã‚’ä¿æŒ
            while (messages.children.length > 10) {
                messages.removeChild(messages.firstChild);
            }
        }

        // ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
        function resetGame() {
            // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’éè¡¨ç¤ºã«ã™ã‚‹
            document.getElementById('gameOverModal').style.display = 'none';

            gameState = {
                player: { x: 0, y: 0, health: 100, maxHealth: 100, hunger: 100, maxHunger: 100, level: 1, exp: 0, attack: 20 },
                pack: null,
                packMembers: [],
                packHealth: 0,
                packMaxHealth: 0,
                enemies: [],
                grid: [],
                stage: 1,
                playerMoveCount: 0,
                controlledWolf: 'mother' // ãƒªã‚»ãƒƒãƒˆæ™‚ã«æ¯ã‚¦ãƒ«ãƒ•ã‚’æ“ä½œã«è¨­å®š
            };

            document.getElementById('messages').innerHTML = ''; // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢
            initGame();
        }

        // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameOverModal').style.display === 'flex') {
                // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã€æ“ä½œã‚’ç„¡åŠ¹åŒ–
                return;
            }
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W': move(-1, 0); break;
                case 'ArrowDown': case 's': case 'S': move(1, 0); break;
                case 'ArrowLeft': case 'a': case 'A': move(0, -1); break;
                case 'ArrowRight': case 'd': case 'D': move(0, 1); break;
                case ' ': howl(); break; // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§é å ãˆ
                case 'x': case 'X': destroyObstacle(); break; // 'x'ã‚­ãƒ¼ã§ç ´å£Š
                // æ–°ã—ã„ã‚­ãƒ¼ãƒã‚¤ãƒ³ãƒ‰: 'q'ã§æ¯ã‚¦ãƒ«ãƒ•ã€'e'ã§ç¾¤ã‚Œã‚’æ“ä½œ
                case 'q': case 'Q': switchControlledWolf('mother'); break;
                case 'e': case 'E': switchControlledWolf('pack'); break;
            }
        });

        // æº€è…¹åº¦ã‚’ã‚†ã£ãã‚Šè‡ªå‹•å›å¾©
        setInterval(() => {
            if (gameState.player.hunger < gameState.player.maxHunger && gameState.player.health > 0) { // ç”Ÿå­˜ã—ã¦ã„ã‚‹å ´åˆã®ã¿å›å¾©
                gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 0.5);
                updateUI();
            }
        }, 3000); // 3ç§’ã”ã¨ã«æº€è…¹åº¦ã‚’å›å¾©

        // ãƒ­ãƒ¼ãƒ‰æ™‚ã«ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–
        window.onload = initGame;
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wolf Pack Evolution RPG</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0e27, #1a1a2e, #16213e);
            min-height: 100vh;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(0, 0, 0, 0.85);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border: 2px solid rgba(138, 43, 226, 0.4);
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #8a2be2;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .game-area {
            display: grid;
            grid-template-columns: 1fr 280px 380px;
            gap: 20px;
            align-items: start;
        }

        .game-grid {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(15, 40px);
            gap: 2px;
            background: #111;
            padding: 10px;
            border-radius: 10px;
            border: 3px solid #8a2be2;
            box-shadow: inset 0 0 20px rgba(138, 43, 226, 0.3);
            justify-content: center;
            align-content: center;
            width: fit-content;
            margin: 0 auto;
        }

        .tile {
            width: 40px;
            height: 40px;
            border: 1px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.3s ease;
            position: relative;
        }

        .tile:hover {
            border-color: #8a2be2;
            transform: scale(1.05);
        }

        /* Terrain styles */
        .grass { background: linear-gradient(135deg, #2d5016, #3e6b1f); }
        .forest { background: linear-gradient(135deg, #1a3a1a, #2d5a2d); }
        .mountain { background: linear-gradient(135deg, #4a4a4a, #6a6a6a); }
        .water { background: linear-gradient(135deg, #1e3a5f, #2e5a8f); }
        .desert { background: linear-gradient(135deg, #c28b3a, #e6b880); }
        .volcano { background: linear-gradient(135deg, #4a0000, #8b0000); }
        .snow { background: linear-gradient(135deg, #e0f2f7, #c6e2e9); }
        .swamp { background: linear-gradient(135deg, #324a3e, #4a6a5e); }
        .crystal { background: linear-gradient(135deg, #a0c4ff, #bdb2ff); }
        .void { background: linear-gradient(135deg, #1a0033, #330066); }

        .goal {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            animation: goalPulse 2s infinite;
        }

        @keyframes goalPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.8); }
        }

        .player {
            width: 40px;
            height: 40px;
            background-image: url('https://github.com/Soyadayo/Mappon/raw/main/mother_wolf.png');
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            animation: motherWolfGlow 2s infinite;
            position: relative;
        }

        .player.pregnant {
            animation: pregnantGlow 2s infinite;
        }

        @keyframes motherWolfGlow {
            0%, 100% { filter: drop-shadow(0 0 3px #ff1493); }
            50% { filter: drop-shadow(0 0 8px #ff1493); }
        }

        @keyframes pregnantGlow {
            0%, 100% { filter: drop-shadow(0 0 5px #ff69b4) drop-shadow(0 0 10px #ffb6c1); }
            50% { filter: drop-shadow(0 0 10px #ff69b4) drop-shadow(0 0 20px #ffb6c1); }
        }

        .pack-icon {
            width: 32px;
            height: 32px;
            background-image: url('https://github.com/Soyadayo/Mappon/raw/main/pack_wolf.png');
            background-size: cover;
            background-position: center;
            border-radius: 50%;
            position: relative;
            animation: packPulse 3s infinite;
        }

        @keyframes packPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .pack-size {
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 68, 68, 0.9);
            color: white;
            font-size: 10px;
            padding: 1px 4px;
            border-radius: 8px;
            font-weight: bold;
            min-width: 16px;
            text-align: center;
            border: 1px solid #fff;
        }

        .enemy {
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-size: 20px;
            position: relative;
        }

        .hp-bar {
            position: absolute;
            bottom: -3px;
            left: 50%;
            transform: translateX(-50%);
            width: 30px;
            height: 3px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            background: #ff4444;
            transition: width 0.3s ease;
        }

        .ui-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(5px);
        }

        .stat-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            border-left: 4px solid #8a2be2;
        }

        .stat-bar {
            background: #222;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
            height: 20px;
        }

        .stat-fill {
            height: 100%;
            transition: width 0.5s ease;
            background: linear-gradient(90deg, #ff6b6b, #ff8e8e);
        }

        .stat-fill.hunger {
            background: linear-gradient(90deg, #f39c12, #f1c40f);
        }

        .stat-fill.exp {
            background: linear-gradient(90deg, #8a2be2, #9370db);
        }

        .stat-fill.pack-hp {
            background: linear-gradient(90deg, #00bfff, #87cefa);
        }

        .stat-fill.pregnancy {
            background: linear-gradient(90deg, #ff69b4, #ffb6c1, #ff1493);
            animation: pregnancyGlow 2s infinite;
        }

        @keyframes pregnancyGlow {
            0%, 100% { 
                background: linear-gradient(90deg, #ff69b4, #ffb6c1, #ff1493);
                box-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
            }
            50% { 
                background: linear-gradient(90deg, #ff1493, #ff69b4, #ffb6c1);
                box-shadow: 0 0 20px rgba(255, 105, 180, 0.8);
            }
        }

        .pregnancy-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 105, 180, 0.1);
            border-radius: 8px;
            border: 2px solid rgba(255, 105, 180, 0.3);
        }

        .accumulated-traits {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .trait-preview {
            background: rgba(255, 105, 180, 0.2);
            border: 1px solid #ff69b4;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .controls-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            backdrop-filter: blur(5px);
            height: fit-content;
        }

        .audio-controls {
            text-align: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .volume-slider {
            width: 100px;
            height: 5px;
            border-radius: 5px;
            background: #333;
            outline: none;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .volume-slider:hover {
            opacity: 1;
        }

        .music-controls {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            justify-content: center;
        }

        .music-btn {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 40px;
        }

        .music-btn:hover {
            transform: translateY(-1px);
            background: linear-gradient(135deg, #6a1b9a, #8a2be2);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        .control-btn {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: translateY(-1px);
            background: linear-gradient(135deg, #6a1b9a, #8a2be2);
        }

        .control-btn.active {
            background: #8a2be2;
            border: 2px solid #00ffff;
            box-shadow: 0 0 6px #00ffff;
        }

        .action-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            font-size: 11px;
        }

        .message-area {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 8px;
            height: 150px;
            overflow-y: auto;
            border: 2px solid rgba(138, 43, 226, 0.3);
            font-size: 14px;
            line-height: 1.5;
        }

        .message {
            margin: 5px 0;
            padding: 5px 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
        }

        .message.hunt {
            border-left: 4px solid #e74c3c;
        }

        .message.pack {
            border-left: 4px solid #9370db;
        }

        .message.level {
            border-left: 4px solid #f39c12;
            font-weight: bold;
        }

        .message.pregnancy {
            border-left: 4px solid #ff69b4;
            background: rgba(255, 105, 180, 0.1);
            font-weight: bold;
        }

        .pack-traits {
            margin-top: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .trait-badge {
            background: rgba(147, 112, 219, 0.2);
            border: 1px solid #9370db;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .trait-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
            font-weight: bold;
        }

        .stage-info {
            text-align: center;
            font-size: 18px;
            color: #f39c12;
            margin: 10px 0;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #1a1a2e;
            padding: 30px;
            border: 2px solid #8a2be2;
            border-radius: 15px;
            width: 80%;
            max-width: 500px;
            text-align: center;
        }

        .modal-content h2 {
            color: #ff1493;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .modal-content button {
            background: linear-gradient(135deg, #8a2be2, #6a1b9a);
            border: none;
            color: white;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
        }

        @media (max-width: 1200px) {
            .game-area {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }

        @media (max-width: 768px) {
            .game-grid {
                grid-template-columns: repeat(15, 30px);
                grid-template-rows: repeat(15, 30px);
            }
            
            .tile {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>üê∫ The Matriarch and the Pack üê∫</h1>

        <div class="stage-info">
            Stage <span id="stage">1</span> / 50
        </div>

        <div class="game-area">
            <!-- Game Board -->
            <div class="game-board">
                <div class="game-grid" id="gameGrid">
                    <!-- Game grid will be generated here -->
                </div>
            </div>

            <!-- Controls Panel -->
            <div class="controls-panel">
                <!-- Audio Controls -->
                <div class="audio-controls">
                    <div style="font-size: 14px; font-weight: bold; margin-bottom: 5px;">üéµ Music</div>
                    <button id="musicToggle" class="control-btn" onclick="toggleMusic()">üéµ Music ON</button>
                    <div class="music-controls">
                        <button class="music-btn" onclick="previousSong()">‚èÆÔ∏è</button>
                        <button class="music-btn" onclick="nextSong()">‚è≠Ô∏è</button>
                    </div>
                    <div style="font-size: 12px; margin: 5px 0;">
                        Track: <span id="currentTrack">1</span>/9
                    </div>
                    <div class="volume-control">
                        <span>üîä</span>
                        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="50" onchange="changeVolume()">
                        <span id="volumeDisplay">50%</span>
                    </div>
                </div>

                <div class="controls">
                    <div style="grid-column: span 3; text-align: center; margin-bottom: 10px;">
                        <div>Controlling: <span id="controlledWolfDisplay">Mother Wolf</span></div>
                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                            <button id="controlMotherBtn" class="control-btn active" onclick="switchControlledWolf('mother')">Mother</button>
                            <button id="controlPackBtn" class="control-btn" onclick="switchControlledWolf('pack')">Pack</button>
                        </div>
                    </div>
                    
                    <button class="control-btn" onclick="move(0, -1)">‚¨ÖÔ∏è West</button>
                    <button class="control-btn" onclick="move(-1, 0)">‚¨ÜÔ∏è North</button>
                    <button class="control-btn" onclick="move(0, 1)">‚û°Ô∏è East</button>
                    <button class="control-btn action-btn" onclick="howl()">üåô Howl</button>
                    <button class="control-btn" onclick="move(1, 0)">‚¨áÔ∏è South</button>
                    <button class="control-btn action-btn" onclick="destroyObstacle()">üí• Destroy</button>
                    
                    <button class="control-btn action-btn" onclick="resetGame()" style="grid-column: span 3;">üîÑ Reset</button>
                    
                    <button class="control-btn" onclick="window.open('https://www.tacorari.eu/wolfex.html', '_blank')" style="grid-column: span 3; background: linear-gradient(135deg, #2ecc71, #27ae60); font-size: 11px;">üìñ How to Play</button>
                </div>
            </div>

            <!-- UI Panel -->
            <div class="ui-panel">
                <div class="stat-group">
                    <h3>üê∫ Mother Wolf</h3>
                    <div>Level: <span id="level">1</span></div>
                    <div>HP: <span id="health">100</span>/<span id="maxHealth">100</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill" id="healthBar" style="width: 100%"></div>
                    </div>
                    <div>Hunger: <span id="hunger">100</span>/100</div>
                    <div class="stat-bar">
                        <div class="stat-fill hunger" id="hungerBar" style="width: 100%"></div>
                    </div>
                    <div>Experience: <span id="exp">0</span>/100</div>
                    <div class="stat-bar">
                        <div class="stat-fill exp" id="expBar" style="width: 0%"></div>
                    </div>
                    <div>Attack: <span id="attack">20</span></div>

                    <!-- Pregnancy section -->
                    <div class="pregnancy-info" id="pregnancyInfo">
                        <div>ü§± Pregnancy: <span id="pregnancyTurns">0</span>/10 turns</div>
                        <div class="stat-bar">
                            <div class="stat-fill pregnancy" id="pregnancyBar" style="width: 0%"></div>
                        </div>
                        <div class="accumulated-traits" id="accumulatedTraits"></div>
                    </div>
                </div>

                <div class="stat-group">
                    <h3>üê∫ Pack Info</h3>
                    <div>Total Count: <span id="packCount">0</span></div>
                    <div>Pack HP: <span id="packHealth">0</span>/<span id="packMaxHealth">0</span></div>
                    <div class="stat-bar">
                        <div class="stat-fill pack-hp" id="packHealthBar" style="width: 0%"></div>
                    </div>
                    <div>Pack Attack: <span id="packPower">0</span></div>
                    <div class="pack-traits" id="packTraits"></div>
                </div>

                <div class="stat-group">
                    <h3>üìú Messages</h3>
                    <div class="message-area" id="messages"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="gameOverModal" class="modal">
        <div class="modal-content">
            <h2 id="gameOverHeading">Game Over!</h2>
            <p id="gameOverMessage">The mother wolf has fallen.</p>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        console.log("üê∫ Game loading...");

        // Game constants
        const GAME_BOARD_SIZE = 15;
        const MAX_STAGE = 50;

        const TERRAIN = {
            GRASS: 'grass',
            FOREST: 'forest',
            MOUNTAIN: 'mountain',
            WATER: 'water',
            DESERT: 'desert',
            VOLCANO: 'volcano',
            SNOW: 'snow',
            SWAMP: 'swamp',
            CRYSTAL: 'crystal',
            VOID: 'void',
            GOAL: 'goal'
        };

        const ENEMY_TYPES = [
            { icon: 'üê∞', name: 'Rabbit', baseHealth: 30, baseAttack: 5, exp: 15, trait: 'speed' },
            { icon: 'ü¶å', name: 'Deer', baseHealth: 50, baseAttack: 10, exp: 25, trait: 'health' },
            { icon: 'üêó', name: 'Boar', baseHealth: 70, baseAttack: 15, exp: 35, trait: 'attack' },
            { icon: 'üêª', name: 'Bear', baseHealth: 100, baseAttack: 20, exp: 50, trait: 'defense' },
            { icon: 'ü¶Ö', name: 'Eagle', baseHealth: 40, baseAttack: 25, exp: 40, trait: 'vision' }
        ];

        const BOSS_TYPES = [
            { icon: 'üê∫', name: 'Alpha Wolf', baseHealth: 300, baseAttack: 40, exp: 200, trait: 'leadership' },
            { icon: 'üêÖ', name: 'Saber Tiger', baseHealth: 500, baseAttack: 60, exp: 300, trait: 'ferocity' },
            { icon: 'üêâ', name: 'Ancient Dragon', baseHealth: 800, baseAttack: 80, exp: 500, trait: 'draconic' }
        ];

        // Game state
        let gameState = {
            player: { x: 7, y: 7, health: 100, maxHealth: 100, hunger: 100, maxHunger: 100, level: 1, exp: 0, attack: 20 },
            pack: null,
            packMembers: [],
            packHealth: 0,
            packMaxHealth: 0,
            enemies: [],
            grid: [],
            stage: 1,
            playerMoveCount: 0,
            controlledWolf: 'mother',
            goalPos: { x: 14, y: 14 },
            pregnancy: {
                isPregnant: false,
                turnsRemaining: 0,
                maxTurns: 10,
                accumulatedTraits: [],
                firstPregnancy: true
            },
            packAutoMode: true,
            currentSongIndex: 0,
            musicPlaying: false
        };

        // Audio system with playlist
        const playlist = [
            "https://github.com/Soyadayo/Mappon/blob/main/music1.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music2.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music3.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music4.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music5.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music6.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music7.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music8.mp3?raw=true",
            "https://github.com/Soyadayo/Mappon/blob/main/music9.mp3?raw=true"
        ];

        let audioPlayer;
        let audioContext;
        let isMusicOn = true;
        let currentVolume = 0.5;

        /**
         * Initialize audio system
         */
        function initAudio() {
            try {
                if (audioPlayer) {
                    audioPlayer.pause();
                    audioPlayer.removeEventListener('ended', nextSong);
                    audioPlayer.removeEventListener('error', nextSong);
                }

                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                audioPlayer = new Audio();
                audioPlayer.volume = currentVolume;
                audioPlayer.loop = false;
                
                audioPlayer.addEventListener('ended', nextSong);
                audioPlayer.addEventListener('error', (e) => {
                    console.log("Music file loading error:", e);
                    nextSong();
                });
                
                if (isMusicOn) {
                    playCurrentSong();
                }
                
                updateTrackDisplay();
                console.log("üéµ Audio system initialized");
            } catch (error) {
                console.log("‚ö†Ô∏è Audio system initialization failed:", error);
            }
        }

        /**
         * Play current song from playlist
         */
        function playCurrentSong() {
            if (!audioPlayer || !isMusicOn) return;
            
            try {
                if (!audioPlayer.paused) {
                    audioPlayer.pause();
                }
                
                audioPlayer.src = playlist[gameState.currentSongIndex];
                audioPlayer.volume = currentVolume;
                audioPlayer.currentTime = 0;
                
                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        gameState.musicPlaying = true;
                        console.log(`üéµ Playing: music${gameState.currentSongIndex + 1}.mp3`);
                        updateTrackDisplay();
                    }).catch(error => {
                        console.log("Music playback error:", error);
                        gameState.musicPlaying = false;
                    });
                }
            } catch (error) {
                console.log("Music playback error:", error);
                nextSong();
            }
        }

        /**
         * Play next song in playlist
         */
        function nextSong() {
            if (!isMusicOn) return;
            
            gameState.currentSongIndex = (gameState.currentSongIndex + 1) % playlist.length;
            
            setTimeout(() => {
                playCurrentSong();
            }, 500);
        }

        /**
         * Play previous song in playlist
         */
        function previousSong() {
            if (!isMusicOn) return;
            
            gameState.currentSongIndex = (gameState.currentSongIndex - 1 + playlist.length) % playlist.length;
            
            setTimeout(() => {
                playCurrentSong();
            }, 500);
        }

        /**
         * Update track display
         */
        function updateTrackDisplay() {
            const trackDisplay = document.getElementById('currentTrack');
            if (trackDisplay) {
                trackDisplay.textContent = gameState.currentSongIndex + 1;
            }
        }

        /**
         * Toggle background music
         */
        function toggleMusic() {
            if (!audioPlayer) {
                initAudio();
                return;
            }

            isMusicOn = !isMusicOn;
            const button = document.getElementById('musicToggle');
            
            if (isMusicOn) {
                button.textContent = 'üéµ Music OFF';
                button.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                
                playCurrentSong();
                addMessage("üéµ Background music turned ON", "level");
            } else {
                button.textContent = 'üéµ Music ON';
                button.style.background = 'linear-gradient(135deg, #8a2be2, #6a1b9a)';
                
                if (audioPlayer) {
                    audioPlayer.pause();
                    gameState.musicPlaying = false;
                }
                
                addMessage("üîá Background music turned OFF", "level");
            }
        }

        /**
         * Change volume
         */
        function changeVolume() {
            const slider = document.getElementById('volumeSlider');
            const display = document.getElementById('volumeDisplay');
            currentVolume = slider.value / 100;
            display.textContent = slider.value + '%';
            
            if (audioPlayer) {
                audioPlayer.volume = currentVolume;
            }
        }

        /**
         * Initialize game
         */
        function initializeGame() {
            console.log("üéÆ Initializing game...");

            try {
                // Reset game state
                gameState.player = { x: 7, y: 7, health: 100, maxHealth: 100, hunger: 100, maxHunger: 100, level: 1, exp: 0, attack: 20 };
                gameState.pack = null;
                gameState.packMembers = [];
                gameState.enemies = [];
                gameState.stage = 1;
                gameState.playerMoveCount = 0;
                gameState.controlledWolf = 'mother';
                gameState.packAutoMode = true;
                gameState.pregnancy = {
                    isPregnant: false,
                    turnsRemaining: 0,
                    maxTurns: 10,
                    accumulatedTraits: [],
                    firstPregnancy: true
                };

                // Generate terrain
                generateTerrain();
                console.log("‚úÖ Terrain generation complete");

                // Generate enemies
                generateEnemies();
                console.log("‚úÖ Enemy generation complete");

                // Clear messages
                clearMessages();
                addMessage("üåô As the mother wolf, form your pack!", "level");
                addMessage("üéØ Head to the goal (golden tile)!", "level");
                addMessage("üê∫ Defeat enemies to get pregnant and birth new pack members!", "pack");

                // Update display
                updatePackHealth();
                updateControlButtons();
                updatePregnancyDisplay();
                renderGame();

                // Start music automatically
                initAudio();
                
                console.log("üéâ Game initialization complete!");
            } catch (error) {
                console.error("‚ùå Initialization error:", error);
                alert("Game initialization failed: " + error.message);
            }
        }

        /**
         * Generate terrain
         */
        function generateTerrain() {
            gameState.grid = [];
            
            const terrainWeights = [
                { terrain: TERRAIN.GRASS, weight: 50 },
                { terrain: TERRAIN.FOREST, weight: 35 },
                { terrain: TERRAIN.MOUNTAIN, weight: 15 }
            ];

            let totalWeight = 0;
            terrainWeights.forEach(tw => totalWeight += tw.weight);

            for (let row = 0; row < GAME_BOARD_SIZE; row++) {
                gameState.grid[row] = [];
                for (let col = 0; col < GAME_BOARD_SIZE; col++) {
                    if (row === 7 && col === 7) {
                        gameState.grid[row][col] = TERRAIN.GRASS;
                    } else if (row === 14 && col === 14) {
                        gameState.grid[row][col] = TERRAIN.GOAL;
                    } else {
                        const random = Math.random() * totalWeight;
                        let currentWeight = 0;
                        
                        for (let tw of terrainWeights) {
                            currentWeight += tw.weight;
                            if (random <= currentWeight) {
                                gameState.grid[row][col] = tw.terrain;
                                break;
                            }
                        }
                    }
                }
            }

            // Ensure basic path to goal
            for (let i = 7; i <= 14; i++) {
                if (gameState.grid[i][7] === TERRAIN.MOUNTAIN) {
                    gameState.grid[i][7] = TERRAIN.GRASS;
                }
                if (gameState.grid[14][i] === TERRAIN.MOUNTAIN) {
                    gameState.grid[14][i] = TERRAIN.GRASS;
                }
            }
        }

        /**
         * Generate enemies
         */
        function generateEnemies() {
            gameState.enemies = [];
            const baseEnemyCount = 6;
            const enemyCount = baseEnemyCount + Math.floor(gameState.stage / 2);

            let availableEnemies = [];
            if (gameState.stage >= 1) availableEnemies.push(ENEMY_TYPES[0]);
            if (gameState.stage >= 3) availableEnemies.push(ENEMY_TYPES[1]);
            if (gameState.stage >= 6) availableEnemies.push(ENEMY_TYPES[2]);
            if (gameState.stage >= 10) availableEnemies.push(ENEMY_TYPES[3]);
            if (gameState.stage >= 15) availableEnemies.push(ENEMY_TYPES[4]);

            const stageMultiplier = 1 + (gameState.stage - 1) * 0.2;

            for (let i = 0; i < enemyCount; i++) {
                let x, y;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    y = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    attempts++;
                } while (attempts < 50 && (
                    (x === gameState.player.x && y === gameState.player.y) ||
                    (x === 14 && y === 14) ||
                    gameState.enemies.some(e => e.x === x && e.y === y) ||
                    gameState.grid[x][y] === TERRAIN.MOUNTAIN
                ));

                if (attempts < 50) {
                    const enemyType = availableEnemies[Math.floor(Math.random() * availableEnemies.length)];
                    
                    gameState.enemies.push({
                        x, y,
                        icon: enemyType.icon,
                        name: enemyType.name,
                        health: Math.floor(enemyType.baseHealth * stageMultiplier),
                        maxHealth: Math.floor(enemyType.baseHealth * stageMultiplier),
                        attack: Math.floor(enemyType.baseAttack * stageMultiplier),
                        exp: Math.floor(enemyType.exp * stageMultiplier),
                        trait: enemyType.trait,
                        id: Date.now() + Math.random() + i,
                        isBoss: false,
                        lastMoveTime: 0,
                        moveSpeed: enemyType.trait === 'speed' ? 800 : 1500,
                        aggroRange: enemyType.trait === 'vision' ? 4 : 2,
                        isAggressive: enemyType.trait === 'attack' || enemyType.trait === 'ferocity'
                    });
                }
            }

            // Generate boss enemies
            if (gameState.stage % 10 === 0 && gameState.stage >= 10) {
                let x, y;
                let attempts = 0;
                do {
                    x = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    y = Math.floor(Math.random() * GAME_BOARD_SIZE);
                    attempts++;
                } while (attempts < 50 && (
                    (x === gameState.player.x && y === gameState.player.y) ||
                    (x === 14 && y === 14) ||
                    gameState.enemies.some(e => e.x === x && e.y === y) ||
                    gameState.grid[x][y] === TERRAIN.MOUNTAIN
                ));

                if (attempts < 50) {
                    const bossIndex = Math.floor((gameState.stage / 10 - 1) % BOSS_TYPES.length);
                    const bossType = BOSS_TYPES[bossIndex];
                    
                    const bossMultiplier = 1.5 + (gameState.stage / 10 - 1) * 0.5;
                    
                    gameState.enemies.push({
                        x, y,
                        icon: bossType.icon,
                        name: `üíÄ ${bossType.name}`,
                        health: Math.floor(bossType.baseHealth * bossMultiplier),
                        maxHealth: Math.floor(bossType.baseHealth * bossMultiplier),
                        attack: Math.floor(bossType.baseAttack * bossMultiplier),
                        exp: Math.floor(bossType.exp * bossMultiplier),
                        trait: bossType.trait,
                        id: Date.now() + Math.random() + 1000,
                        isBoss: true,
                        lastMoveTime: 0,
                        moveSpeed: 1000,
                        aggroRange: 5,
                        isAggressive: true
                    });
                    
                    addMessage(`‚ö†Ô∏è Powerful boss ${bossType.name} appeared!`, "hunt");
                }
            }

            startEnemyAI();
        }

        /**
         * Render game display
         */
        function renderGame() {
            try {
                const grid = document.getElementById('gameGrid');
                if (!grid) {
                    console.error("‚ùå gameGrid element not found");
                    return;
                }

                grid.innerHTML = '';

                for (let row = 0; row < GAME_BOARD_SIZE; row++) {
                    for (let col = 0; col < GAME_BOARD_SIZE; col++) {
                        const tile = document.createElement('div');
                        tile.className = `tile ${gameState.grid[row][col]}`;

                        let content = '';

                        // Player
                        if (gameState.player.x === row && gameState.player.y === col) {
                            const pregnantClass = gameState.pregnancy.isPregnant ? ' pregnant' : '';
                            content = `<div class="player${pregnantClass}"></div>`;
                        }
                        // Pack
                        else if (gameState.pack && gameState.pack.x === row && gameState.pack.y === col) {
                            content = `<div class="pack-icon"></div><span class="pack-size">${gameState.packMembers.length}</span>`;
                        }
                        // Enemies
                        else if (gameState.enemies.some(e => e.x === row && e.y === col)) {
                            const enemy = gameState.enemies.find(e => e.x === row && e.y === col);
                            const hpPercent = (enemy.health / enemy.maxHealth) * 100;
                            const bossClass = enemy.isBoss ? ' boss-enemy' : '';
                            content = `
                                <span class="enemy${bossClass}" style="${enemy.isBoss ? 'font-size: 24px; text-shadow: 3px 3px 6px rgba(255, 0, 0, 0.8);' : ''}">${enemy.icon}</span>
                                <div class="hp-bar">
                                    <div class="hp-fill" style="width: ${hpPercent}%; ${enemy.isBoss ? 'background: linear-gradient(90deg, #ff0000, #ff4444);' : ''}"></div>
                                </div>
                            `;
                        }
                        // Terrain icons
                        else {
                            const terrainIconMap = {
                                [TERRAIN.GRASS]: 'üåæ',
                                [TERRAIN.FOREST]: 'üå≤',
                                [TERRAIN.MOUNTAIN]: '‚õ∞Ô∏è',
                                [TERRAIN.GOAL]: 'üèÅ'
                            };
                            content = terrainIconMap[gameState.grid[row][col]] || '';
                        }

                        tile.innerHTML = content;
                        grid.appendChild(tile);
                    }
                }

                updateUI();
                console.log("‚úÖ Game rendering complete");
            } catch (error) {
                console.error("‚ùå Rendering error:", error);
            }
        }

        /**
         * Update UI elements
         */
        function updateUI() {
            try {
                // Stage
                document.getElementById('stage').textContent = gameState.stage;
                
                // Mother Wolf stats
                document.getElementById('level').textContent = gameState.player.level;
                document.getElementById('health').textContent = Math.max(0, Math.floor(gameState.player.health));
                document.getElementById('maxHealth').textContent = gameState.player.maxHealth;
                document.getElementById('hunger').textContent = Math.floor(gameState.player.hunger);
                document.getElementById('exp').textContent = gameState.player.exp;
                document.getElementById('attack').textContent = gameState.player.attack;

                // Pack stats
                document.getElementById('packCount').textContent = gameState.packMembers.length;
                document.getElementById('packHealth').textContent = Math.floor(gameState.packHealth);
                document.getElementById('packMaxHealth').textContent = gameState.packMaxHealth;

                let packPower = 0;
                gameState.packMembers.forEach(member => {
                    packPower += member.attack;
                });
                document.getElementById('packPower').textContent = packPower;

                // Update stat bars
                const healthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
                const hungerPercent = (gameState.player.hunger / gameState.player.maxHunger) * 100;
                const expPercent = (gameState.player.exp / (gameState.player.level * 100)) * 100;
                const packHealthPercent = (gameState.packMembers.length > 0) ? (gameState.packHealth / gameState.packMaxHealth) * 100 : 0;

                document.getElementById('healthBar').style.width = healthPercent + '%';
                document.getElementById('hungerBar').style.width = hungerPercent + '%';
                document.getElementById('expBar').style.width = expPercent + '%';
                document.getElementById('packHealthBar').style.width = packHealthPercent + '%';

                // Update controlled wolf display
                const unitType = gameState.controlledWolf === 'mother' ? 'Mother Wolf' : 'Pack';
                document.getElementById('controlledWolfDisplay').textContent = unitType;

                // Update pregnancy display
                updatePregnancyDisplay();

                // Update pack traits
                updatePackTraitsDisplay();
            } catch (error) {
                console.error("‚ùå UI update error:", error);
            }
        }

        /**
         * Move function
         */
        function move(dr, dc) {
            try {
                let activeUnit;
                let isMotherControlled = (gameState.controlledWolf === 'mother');

                if (isMotherControlled) {
                    activeUnit = gameState.player;
                } else {
                    if (!gameState.pack || gameState.packMembers.length === 0) {
                        addMessage("üê∫ No pack to move!", "hunt");
                        switchControlledWolf('mother');
                        return;
                    }
                    activeUnit = gameState.pack;
                }

                const newX = activeUnit.x + dr;
                const newY = activeUnit.y + dc;

                // Boundary check
                if (newX < 0 || newX >= GAME_BOARD_SIZE || newY < 0 || newY >= GAME_BOARD_SIZE) {
                    addMessage("üö´ Edge of the world!", "hunt");
                    return;
                }

                // Terrain check
                const terrain = gameState.grid[newX][newY];
                if (terrain === TERRAIN.MOUNTAIN) {
                    addMessage(`üö´ Cannot pass through ${terrain === TERRAIN.MOUNTAIN ? 'mountains' : 'obstacles'}!`, "hunt");
                    return;
                }

                // Collision check
                if (isMotherControlled && gameState.pack && 
                    newX === gameState.pack.x && newY === gameState.pack.y) {
                    addMessage("üö´ Mother wolf cannot move onto pack position.", "hunt");
                    return;
                } else if (!isMotherControlled && 
                           newX === gameState.player.x && newY === gameState.player.y) {
                    addMessage("üö´ Pack cannot move onto mother wolf position.", "hunt");
                    return;
                }

                // Move unit
                activeUnit.x = newX;
                activeUnit.y = newY;
                gameState.playerMoveCount++;

                // Check for enemy encounter
                const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
                if (enemy) {
                    if (isMotherControlled) {
                        hunt(enemy);
                    } else {
                        packAttack(enemy);
                    }
                }

                // Check if goal reached
                if (gameState.player.x === gameState.goalPos.x && 
                    gameState.player.y === gameState.goalPos.y) {
                    nextStage();
                    return;
                }

                // Pack auto movement
                if (isMotherControlled && gameState.pack && gameState.packAutoMode) {
                    setTimeout(() => {
                        autoMovePack();
                    }, 500);
                }

                applyTurnEffects();
                renderGame();
            } catch (error) {
                console.error("‚ùå Move error:", error);
            }
        }

        /**
         * Auto move pack
         */
        function autoMovePack() {
            if (!gameState.pack || gameState.packMembers.length === 0) return;

            // Find nearest enemy
            let nearestEnemy = null;
            let minDistance = Infinity;

            gameState.enemies.forEach(enemy => {
                const distance = Math.abs(enemy.x - gameState.pack.x) + Math.abs(enemy.y - gameState.pack.y);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestEnemy = enemy;
                }
            });

            if (nearestEnemy && minDistance <= 3) {
                // Move towards enemy
                const dx = nearestEnemy.x - gameState.pack.x;
                const dy = nearestEnemy.y - gameState.pack.y;
                
                let moveX = 0, moveY = 0;
                if (Math.abs(dx) > Math.abs(dy)) {
                    moveX = dx > 0 ? 1 : -1;
                } else {
                    moveY = dy > 0 ? 1 : -1;
                }

                const newX = gameState.pack.x + moveX;
                const newY = gameState.pack.y + moveY;

                if (newX >= 0 && newX < GAME_BOARD_SIZE && 
                    newY >= 0 && newY < GAME_BOARD_SIZE &&
                    gameState.grid[newX][newY] !== TERRAIN.MOUNTAIN &&
                    !(newX === gameState.player.x && newY === gameState.player.y)) {
                    
                    gameState.pack.x = newX;
                    gameState.pack.y = newY;

                    const enemy = gameState.enemies.find(e => e.x === newX && e.y === newY);
                    if (enemy) {
                        packAttack(enemy);
                    }

                    renderGame();
                }
            } else {
                // Move towards mother wolf
                const dx = gameState.player.x - gameState.pack.x;
                const dy = gameState.player.y - gameState.pack.y;
                
                if (Math.abs(dx) + Math.abs(dy) > 2) {
                    let moveX = 0, moveY = 0;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        moveX = dx > 0 ? 1 : -1;
                    } else {
                        moveY = dy > 0 ? 1 : -1;
                    }

                    const newX = gameState.pack.x + moveX;
                    const newY = gameState.pack.y + moveY;

                    if (newX >= 0 && newX < GAME_BOARD_SIZE && 
                        newY >= 0 && newY < GAME_BOARD_SIZE &&
                        gameState.grid[newX][newY] !== TERRAIN.MOUNTAIN &&
                        !(newX === gameState.player.x && newY === gameState.player.y)) {
                        
                        gameState.pack.x = newX;
                        gameState.pack.y = newY;
                        renderGame();
                    }
                }
            }
        }

        // Enemy AI system
        let enemyAIInterval;

        /**
         * Start enemy AI system
         */
        function startEnemyAI() {
            if (enemyAIInterval) {
                clearInterval(enemyAIInterval);
            }

            enemyAIInterval = setInterval(() => {
                if (gameState.enemies.length === 0) return;

                gameState.enemies.forEach(enemy => {
                    const currentTime = Date.now();
                    
                    if (currentTime - enemy.lastMoveTime >= enemy.moveSpeed) {
                        enemyAI(enemy);
                        enemy.lastMoveTime = currentTime;
                    }
                });
            }, 500);
        }

        /**
         * Individual enemy AI
         */
        function enemyAI(enemy) {
            if (!enemy) return;

            const playerDistance = Math.abs(enemy.x - gameState.player.x) + Math.abs(enemy.y - gameState.player.y);
            let packDistance = Infinity;
            
            if (gameState.pack) {
                packDistance = Math.abs(enemy.x - gameState.pack.x) + Math.abs(enemy.y - gameState.pack.y);
            }

            const targetIsPlayer = playerDistance <= packDistance;
            const targetDistance = Math.min(playerDistance, packDistance);
            const targetX = targetIsPlayer ? gameState.player.x : (gameState.pack ? gameState.pack.x : gameState.player.x);
            const targetY = targetIsPlayer ? gameState.player.y : (gameState.pack ? gameState.pack.y : gameState.player.y);

            if (targetDistance <= 1) {
                enemyAttack(enemy, targetIsPlayer);
                return;
            }

            if (targetDistance <= enemy.aggroRange || enemy.isAggressive) {
                moveEnemyTowards(enemy, targetX, targetY);
            } else {
                randomEnemyMove(enemy);
            }
        }

        /**
         * Move enemy towards target
         */
        function moveEnemyTowards(enemy, targetX, targetY) {
            const dx = targetX - enemy.x;
            const dy = targetY - enemy.y;
            
            let moveX = 0, moveY = 0;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                moveX = dx > 0 ? 1 : -1;
            } else if (dy !== 0) {
                moveY = dy > 0 ? 1 : -1;
            }

            const newX = enemy.x + moveX;
            const newY = enemy.y + moveY;

            if (isValidEnemyMove(newX, newY, enemy)) {
                enemy.x = newX;
                enemy.y = newY;
                renderGame();
            }
        }

        /**
         * Random enemy movement
         */
        function randomEnemyMove(enemy) {
            if (Math.random() > 0.25) return;

            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const randomDir = directions[Math.floor(Math.random() * directions.length)];
            
            const newX = enemy.x + randomDir[0];
            const newY = enemy.y + randomDir[1];

            if (isValidEnemyMove(newX, newY, enemy)) {
                enemy.x = newX;
                enemy.y = newY;
                renderGame();
            }
        }

        /**
         * Check if enemy move is valid
         */
        function isValidEnemyMove(x, y, movingEnemy) {
            if (x < 0 || x >= GAME_BOARD_SIZE || y < 0 || y >= GAME_BOARD_SIZE) {
                return false;
            }

            if (gameState.grid[x][y] === TERRAIN.MOUNTAIN) {
                return false;
            }

            if (gameState.enemies.some(e => e !== movingEnemy && e.x === x && e.y === y)) {
                return false;
            }

            return true;
        }

        /**
         * Enemy attack
         */
        function enemyAttack(enemy, targetIsPlayer) {
            const damage = enemy.attack + Math.floor(Math.random() * 5);

            if (targetIsPlayer) {
                gameState.player.health -= damage;
                addMessage(`üí• ${enemy.name} attacks mother wolf! ${damage} damage!`, "hunt");

                if (gameState.player.health <= 0) {
                    gameOver("Mother wolf was defeated by enemies!");
                    return;
                }
            } else if (gameState.pack && gameState.packMembers.length > 0) {
                const randomMember = gameState.packMembers[Math.floor(Math.random() * gameState.packMembers.length)];
                randomMember.health -= damage;
                
                addMessage(`üí• ${enemy.name} attacks the pack! ${damage} damage!`, "hunt");

                if (randomMember.health <= 0) {
                    gameState.packMembers = gameState.packMembers.filter(m => m !== randomMember);
                    addMessage(`üíÄ A pack member was defeated...`, "hunt");
                    
                    if (gameState.packMembers.length === 0) {
                        gameState.pack = null;
                        addMessage(`üíÄ The pack has been wiped out!`, "hunt");
                        switchControlledWolf('mother');
                    }
                }
                
                updatePackHealth();
            }

            updateUI();
        }

        /**
         * Apply turn effects
         */
        function applyTurnEffects() {
            gameState.player.hunger = Math.max(0, gameState.player.hunger - 2);
            
            if (gameState.player.hunger === 0) {
                gameState.player.health -= 5;
                addMessage("üçñ Hunger damage taken!", "hunt");
                if (gameState.player.health <= 0) {
                    gameOver("Mother wolf starved to death!");
                    return;
                }
            }

            if (gameState.pregnancy.isPregnant) {
                advancePregnancy();
            }
        }

        /**
         * Hunt enemy
         */
        function hunt(enemy) {
            try {
                const playerDamage = gameState.player.attack + Math.floor(Math.random() * 10);
                enemy.health -= playerDamage;

                addMessage(`ü¶∑ Dealt ${playerDamage} damage to ${enemy.name}!`, "hunt");

                if (enemy.health <= 0) {
                    gameState.player.hunger = Math.min(gameState.player.maxHunger, gameState.player.hunger + 40);
                    gameState.player.exp += enemy.exp;

                    addMessage(`üçñ Ate ${enemy.name}! Gained ${enemy.exp} experience!`, "pack");

                    // 1/3 chance to start pregnancy
                    if (!gameState.pregnancy.isPregnant && Math.random() < 0.33) {
                        startPregnancy();
                    }
                    
                    // Accumulate traits during pregnancy
                    if (gameState.pregnancy.isPregnant) {
                        accumulateTrait(enemy.icon, enemy.name, enemy.trait);
                    }

                    gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                    checkLevelUp();
                } else {
                    // Enemy counterattack
                    const enemyDamage = enemy.attack + Math.floor(Math.random() * 5);
                    gameState.player.health -= enemyDamage;
                    addMessage(`üí• ${enemy.name} counterattacks! ${enemyDamage} damage received.`, "hunt");

                    if (gameState.player.health <= 0) {
                        gameOver("Mother wolf was defeated by enemies!");
                        return;
                    }
                }
            } catch (error) {
                console.error("‚ùå Combat error:", error);
            }
        }

        /**
         * Pack attack
         */
        function packAttack(enemy) {
            if (gameState.packMembers.length === 0) return;

            let totalDamage = 0;
            gameState.packMembers.forEach(member => {
                totalDamage += member.attack;
            });

            enemy.health -= totalDamage;
            addMessage(`üê∫ Pack (${gameState.packMembers.length} wolves) deals ${totalDamage} damage to ${enemy.name}!`, "pack");

            if (enemy.health <= 0) {
                gameState.player.exp += Math.floor(enemy.exp * 0.8);
                gameState.enemies = gameState.enemies.filter(e => e !== enemy);
                addMessage(`üê∫ Pack defeated ${enemy.name}!`, "pack");
                checkLevelUp();
            } else {
                // Enemy counterattack on pack
                const enemyDamage = enemy.attack + Math.floor(Math.random() * 5);
                
                if (gameState.packMembers.length > 0) {
                    const randomMember = gameState.packMembers[Math.floor(Math.random() * gameState.packMembers.length)];
                    randomMember.health -= enemyDamage;
                    
                    if (randomMember.health <= 0) {
                        gameState.packMembers = gameState.packMembers.filter(m => m !== randomMember);
                        addMessage(`üíÄ A pack member was defeated...`, "hunt");
                        
                        if (gameState.packMembers.length === 0) {
                            gameState.pack = null;
                            addMessage(`üíÄ The pack has been wiped out!`, "hunt");
                            switchControlledWolf('mother');
                        }
                    }
                    
                    updatePackHealth();
                }
            }
        }

        // Pregnancy system functions
        function startPregnancy() {
            if (!gameState.pregnancy.isPregnant) {
                gameState.pregnancy.isPregnant = true;
                gameState.pregnancy.turnsRemaining = gameState.pregnancy.maxTurns;
                gameState.pregnancy.accumulatedTraits = [];
                
                addMessage(`üå∏ Mother wolf is pregnant! Birth expected in ${gameState.pregnancy.maxTurns} turns.`, "pregnancy");
                updatePregnancyDisplay();
            }
        }

        function accumulateTrait(enemyIcon, enemyName, enemyTrait) {
            if (gameState.pregnancy.isPregnant) {
                const traitInfo = {
                    icon: enemyIcon,
                    name: enemyName,
                    trait: enemyTrait,
                    traitName: enemyTrait
                };
                
                gameState.pregnancy.accumulatedTraits.push(traitInfo);
                addMessage(`ü§± The unborn pup absorbs ${enemyTrait} nutrients...`, "pregnancy");
                updatePregnancyDisplay();
            }
        }

        function advancePregnancy() {
            if (gameState.pregnancy.isPregnant) {
                gameState.pregnancy.turnsRemaining--;
                
                const currentTurn = gameState.pregnancy.maxTurns - gameState.pregnancy.turnsRemaining;
                
                if (gameState.pregnancy.turnsRemaining <= 0) {
                    giveBirth();
                } else {
                    addMessage(`ü§± Pregnancy turn ${currentTurn}. ${gameState.pregnancy.turnsRemaining} turns until birth.`, "pregnancy");
                }
                
                updatePregnancyDisplay();
            }
        }

        function giveBirth() {
            addMessage("üçº Birth begins!", "pregnancy");
            
            let selectedTrait = null;
            
            if (gameState.pregnancy.accumulatedTraits.length > 0) {
                const randomIndex = Math.floor(Math.random() * gameState.pregnancy.accumulatedTraits.length);
                selectedTrait = gameState.pregnancy.accumulatedTraits[randomIndex];
            } else {
                selectedTrait = {
                    icon: 'üê∫',
                    name: 'Wolf',
                    trait: 'speed',
                    traitName: 'speed'
                };
            }
            
            // Create enhanced wolf
            const baseHealth = 50 + gameState.player.level * 5;
            const baseAttack = 15 + gameState.player.level * 2;
            
            const traitBonus = Math.min(gameState.pregnancy.accumulatedTraits.length * 2, 20);
            
            const newWolf = {
                health: baseHealth + traitBonus,
                maxHealth: baseHealth + traitBonus,
                attack: baseAttack + Math.floor(traitBonus / 2),
                trait: selectedTrait.trait,
                icon: selectedTrait.icon,
                id: Date.now() + Math.random()
            };

            gameState.packMembers.push(newWolf);

            if (!gameState.pack) {
                gameState.pack = { x: gameState.player.x + 1, y: gameState.player.y };
                if (gameState.pack.x >= GAME_BOARD_SIZE) {
                    gameState.pack.x = gameState.player.x;
                    gameState.pack.y = gameState.player.y + 1;
                }
                if (gameState.pack.y >= GAME_BOARD_SIZE) {
                    gameState.pack.y = gameState.player.y;
                }
            }
            
            updatePackHealth();
            
            addMessage(`üçº Healthy pup born with '${selectedTrait.traitName}' trait!`, "pregnancy");
            
            // Reset pregnancy
            gameState.pregnancy.isPregnant = false;
            gameState.pregnancy.turnsRemaining = 0;
            gameState.pregnancy.accumulatedTraits = [];
            gameState.pregnancy.firstPregnancy = false;
            
            updatePregnancyDisplay();
        }

        function updatePregnancyDisplay() {
            try {
                const pregnancyInfo = document.getElementById('pregnancyInfo');
                const pregnancyBar = document.getElementById('pregnancyBar');
                const pregnancyTurns = document.getElementById('pregnancyTurns');
                const accumulatedTraits = document.getElementById('accumulatedTraits');
                
                if (gameState.pregnancy.isPregnant) {
                    const progress = ((gameState.pregnancy.maxTurns - gameState.pregnancy.turnsRemaining) / gameState.pregnancy.maxTurns) * 100;
                    pregnancyBar.style.width = progress + '%';
                    
                    const currentTurn = gameState.pregnancy.maxTurns - gameState.pregnancy.turnsRemaining;
                    pregnancyTurns.textContent = `${currentTurn}/${gameState.pregnancy.maxTurns}`;
                    
                    // Display accumulated traits
                    accumulatedTraits.innerHTML = '';
                    gameState.pregnancy.accumulatedTraits.forEach(trait => {
                        const traitElement = document.createElement('div');
                        traitElement.className = 'trait-preview';
                        traitElement.innerHTML = `
                            <span>${trait.icon}</span>
                            <span>${trait.traitName}</span>
                        `;
                        accumulatedTraits.appendChild(traitElement);
                    });
                } else {
                    pregnancyBar.style.width = '0%';
                    pregnancyTurns.textContent = '0/10';
                    accumulatedTraits.innerHTML = '';
                }
            } catch (error) {
                console.error("‚ùå Pregnancy display update error:", error);
            }
        }

        function updatePackTraitsDisplay() {
            try {
                const traitsDiv = document.getElementById('packTraits');
                traitsDiv.innerHTML = '';

                const traits = {};
                gameState.packMembers.forEach(member => {
                    if (member.trait) {
                        traits[member.trait] = (traits[member.trait] || 0) + 1;
                    }
                });

                Object.entries(traits).forEach(([trait, count]) => {
                    const traitBadge = document.createElement('div');
                    traitBadge.className = 'trait-badge';
                    const enemyType = ENEMY_TYPES.find(e => e.trait === trait) || BOSS_TYPES.find(e => e.trait === trait);
                    if (enemyType) {
                        traitBadge.innerHTML = `
                            <span>${enemyType.icon}</span>
                            <span>${trait}</span>
                            <span class="trait-count">√ó${count}</span>
                        `;
                        traitsDiv.appendChild(traitBadge);
                    }
                });
            } catch (error) {
                console.error("‚ùå Pack traits display error:", error);
            }
        }

        // Other game functions
        function howl() {
            if (gameState.controlledWolf !== 'mother') {
                addMessage("üö´ Only the mother wolf can use this skill!", "hunt");
                return;
            }

            if (gameState.player.hunger >= 20) {
                gameState.player.hunger -= 20;
                const healAmount = 20 + gameState.player.level * 5;
                
                // Heal mother wolf
                const oldHealth = gameState.player.health;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);
                const motherHealed = gameState.player.health - oldHealth;

                // Heal pack
                let healedCount = 0;
                let totalPackHealed = 0;
                gameState.packMembers.forEach(member => {
                    if (member.health < member.maxHealth) {
                        const oldPackHealth = member.health;
                        member.health = Math.min(member.maxHealth, member.health + healAmount);
                        totalPackHealed += (member.health - oldPackHealth);
                        healedCount++;
                    }
                });

                updatePackHealth();
                updateUI();
                
                if (healedCount > 0) {
                    addMessage(`üåô Howled! Mother wolf healed ${motherHealed}HP, ${healedCount} pack members healed ${totalPackHealed}HP total!`, "pack");
                } else {
                    addMessage(`üåô Howled! Mother wolf healed ${motherHealed}HP!`, "pack");
                }
                
                playHowlSound();
            } else {
                addMessage("üö´ Too hungry to howl!", "hunt");
            }
        }

        /**
         * Play howl sound effect
         */
        function playHowlSound() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.5);
                oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 1.0);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(currentVolume * 0.3, audioContext.currentTime + 0.1);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.0);
                
                oscillator.type = 'sine';
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 1.0);
            } catch (error) {
                console.log("Howl sound effect error:", error);
            }
        }

        function destroyObstacle() {
            if (gameState.player.level < 3) {
                addMessage("üö´ Level 3+ required to destroy obstacles!", "hunt");
                return;
            }
            if (gameState.controlledWolf !== 'mother') {
                addMessage("üö´ Only the mother wolf can use this skill!", "hunt");
                return;
            }

            const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            let destroyed = false;

            directions.forEach(([dx, dy]) => {
                const x = gameState.player.x + dx;
                const y = gameState.player.y + dy;

                if (x >= 0 && x < GAME_BOARD_SIZE && y >= 0 && y < GAME_BOARD_SIZE) {
                    if (gameState.grid[x][y] === TERRAIN.WATER || gameState.grid[x][y] === TERRAIN.MOUNTAIN) {
                        gameState.grid[x][y] = TERRAIN.GRASS;
                        destroyed = true;
                    }
                }
            });

            if (destroyed) {
                addMessage("üí• Obstacles destroyed!", "level");
                gameState.player.hunger -= 10;
                
                playDestroySound();
                
                renderGame();
            } else {
                addMessage("üö´ No destroyable obstacles nearby!", "hunt");
            }
        }

        /**
         * Play destroy sound effect
         */
        function playDestroySound() {
            if (!audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                oscillator.frequency.linearRampToValueAtTime(50, audioContext.currentTime + 0.3);
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(currentVolume * 0.4, audioContext.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                
                oscillator.type = 'square';
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.3);
            } catch (error) {
                console.log("Destroy sound effect error:", error);
            }
        }

        function checkLevelUp() {
            const requiredExp = gameState.player.level * 100;
            if (gameState.player.exp >= requiredExp) {
                gameState.player.level++;
                gameState.player.exp = gameState.player.exp - requiredExp;
                gameState.player.maxHealth += 20;
                gameState.player.health = gameState.player.maxHealth;
                gameState.player.maxHunger += 20;
                gameState.player.hunger = gameState.player.maxHunger;
                gameState.player.attack += 10;

                addMessage(`üåü Level up! Reached level ${gameState.player.level}!`, "level");

                if (gameState.player.level === 3) {
                    addMessage("üí™ Obstacle destruction skill unlocked!", "level");
                }
                
                playLevelUpSound();
            }
        }

        /**
         * Play level up sound effect
         */
        function playLevelUpSound() {
            if (!audioContext) return;
            
            try {
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.setValueAtTime(300 + i * 100, audioContext.currentTime);
                        
                        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                        gainNode.gain.linearRampToValueAtTime(currentVolume * 0.2, audioContext.currentTime + 0.1);
                        gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
                        
                        oscillator.type = 'sine';
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                    }, i * 100);
                }
            } catch (error) {
                console.log("Level up sound effect error:", error);
            }
        }

        function switchControlledWolf(target) {
            if (gameState.packMembers.length === 0 && target === 'pack') {
                addMessage("üê∫ No pack to control!", "hunt");
                return;
            }
            
            gameState.controlledWolf = target;
            const unitType = target === 'mother' ? 'Mother Wolf' : 'Pack';
            addMessage(`Switched control to ${unitType}.`, "level");
            updateControlButtons();
            renderGame();
        }

        function updateControlButtons() {
            try {
                document.getElementById('controlMotherBtn').classList.remove('active');
                document.getElementById('controlPackBtn').classList.remove('active');
                if (gameState.controlledWolf === 'mother') {
                    document.getElementById('controlMotherBtn').classList.add('active');
                } else {
                    document.getElementById('controlPackBtn').classList.add('active');
                }
            } catch (error) {
                console.error("‚ùå Button update error:", error);
            }
        }

        function updatePackHealth() {
            let totalPackHealth = 0;
            let totalPackMaxHealth = 0;
            gameState.packMembers.forEach(member => {
                totalPackHealth += member.health;
                totalPackMaxHealth += member.maxHealth;
            });
            gameState.packHealth = totalPackHealth;
            gameState.packMaxHealth = totalPackMaxHealth;
        }

        function nextStage() {
            if (gameState.stage >= MAX_STAGE) {
                addMessage("üéâ All stages conquered! Game cleared!", "level");
                
                document.getElementById('gameOverMessage').textContent = "Congratulations! You have conquered the strongest lands!";
                document.getElementById('gameOverHeading').textContent = "Victory!";
                document.getElementById('gameOverModal').style.display = 'flex';
                return;
            }

            gameState.stage++;
            gameState.player.health = gameState.player.maxHealth;
            gameState.player.hunger = gameState.player.maxHunger;

            addMessage(`üéâ Advanced to stage ${gameState.stage}!`, "level");
            addMessage("üí™ Health and hunger fully recovered!", "pack");

            // Reset positions
            gameState.player.x = 7;
            gameState.player.y = 7;

            if (gameState.pack) {
                gameState.pack.x = 6;
                gameState.pack.y = 7;

                gameState.packMembers.forEach(member => {
                    member.health = member.maxHealth;
                });
                updatePackHealth();
            }

            generateTerrain();
            generateEnemies();
            renderGame();
        }

        function gameOver(message) {
            gameState.player.health = 0;
            addMessage(`üíÄ ${message}`, "hunt");
            
            document.getElementById('gameOverMessage').textContent = message;
            document.getElementById('gameOverHeading').textContent = "Game Over!";
            document.getElementById('gameOverModal').style.display = 'flex';
        }

        function resetGame() {
            document.getElementById('gameOverModal').style.display = 'none';
            
            if (enemyAIInterval) {
                clearInterval(enemyAIInterval);
                enemyAIInterval = null;
            }
            
            initializeGame();
        }

        function addMessage(text, type = "") {
            try {
                const messages = document.getElementById('messages');
                const message = document.createElement('div');
                message.className = `message ${type}`;
                message.textContent = text;
                messages.appendChild(message);
                messages.scrollTop = messages.scrollHeight;

                while (messages.children.length > 10) {
                    messages.removeChild(messages.firstChild);
                }
            } catch (error) {
                console.error("‚ùå Message add error:", error);
            }
        }

        function clearMessages() {
            try {
                document.getElementById('messages').innerHTML = '';
            } catch (error) {
                console.error("‚ùå Message clear error:", error);
            }
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('gameOverModal').style.display === 'flex') {
                return;
            }
            switch(e.key) {
                case 'ArrowUp': case 'w': case 'W': move(-1, 0); break;
                case 'ArrowDown': case 's': case 'S': move(1, 0); break;
                case 'ArrowLeft': case 'a': case 'A': move(0, -1); break;
                case 'ArrowRight': case 'd': case 'D': move(0, 1); break;
                case ' ': e.preventDefault(); howl(); break;
                case 'x': case 'X': destroyObstacle(); break;
                case 'q': case 'Q': switchControlledWolf('mother'); break;
                case 'e': case 'E': switchControlledWolf('pack'); break;
                case 'r': case 'R': resetGame(); break;
                case 'm': case 'M': toggleMusic(); break;
                case 'n': case 'N': nextSong(); break;
                case 'p': case 'P': previousSong(); break;
            }
        });

        // Game initialization
        function startGame() {
            console.log("üöÄ Starting game...");
            
            setTimeout(() => {
                try {
                    const gameGrid = document.getElementById('gameGrid');
                    if (gameGrid) {
                        console.log("‚úÖ DOM elements confirmed");
                        initializeGame();
                        const musicButton = document.getElementById('musicToggle');
                        if (musicButton) {
                            musicButton.textContent = 'üéµ Music OFF';
                            musicButton.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)';
                        }
                    } else {
                        console.error("‚ùå gameGrid element not found");
                        setTimeout(startGame, 100);
                    }
                } catch (error) {
                    console.error("‚ùå Game start error:", error);
                    setTimeout(startGame, 100);
                }
            }, 100);
        }

        // Multiple initialization triggers
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startGame);
        } else {
            startGame();
        }

        // Final fallback
        window.addEventListener('load', () => {
            console.log("üîÑ Window load fallback...");
            const gameGrid = document.getElementById('gameGrid');
            if (!gameGrid || gameGrid.children.length === 0) {
                startGame();
            }
        });

        console.log("üìù Script loading complete");
    </script>
</body>
</html>
